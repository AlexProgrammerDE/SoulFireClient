/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,optimize_code_size,eslint_disable,ts_nocheck
// @generated from protobuf file "soulfire/bot.proto" (package "soulfire.v1", syntax proto3)
// tslint:disable
// @ts-nocheck

import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from "@protobuf-ts/runtime";
import {
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from "@protobuf-ts/runtime";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { Value } from "../google/protobuf/struct";
// ============================================================================
// BotService - Minecraft Bot Control and Information Service
// ============================================================================
//
// The BotService provides comprehensive control and monitoring capabilities for
// Minecraft bots managed by the SoulFire server. It enables clients to:
//
// - Query bot status and live state (position, health, inventory, etc.)
// - Control bot movement (WASD, jump, sneak, sprint)
// - Control bot view direction (yaw/pitch rotation)
// - Manage inventory interactions (clicking slots, opening/closing containers)
// - Render the bot's point-of-view as images
// - Interact with server dialogs (Minecraft 1.21.6+)
// - Update bot-specific configuration
//
// All RPC methods require appropriate permissions checked via the user context.
// Most methods require the bot to be online (connected to a Minecraft server)
// for the operation to succeed.
// ============================================================================

/**
 * Request message for retrieving detailed information about a specific bot.
 * Used by the GetBotInfo RPC to fetch a single bot's live state with full inventory data.
 *
 * @generated from protobuf message soulfire.v1.BotInfoRequest
 */
export interface BotInfoRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   * Must be a valid UUID string format (e.g., "550e8400-e29b-41d4-a716-446655440000").
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot (Minecraft account UUID).
   * Must be a valid UUID string format.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Request message for listing all bots in an instance.
 * Used by the GetBotList RPC to enumerate all configured bots.
 *
 * @generated from protobuf message soulfire.v1.BotListRequest
 */
export interface BotListRequest {
  /**
   * The UUID of the SoulFire instance to list bots from.
   * Must be a valid UUID string format.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
}
/**
 * Entry representing a single bot in the bot list.
 * Contains summary information suitable for display in a list view.
 *
 * @generated from protobuf message soulfire.v1.BotListEntry
 */
export interface BotListEntry {
  /**
   * The Minecraft profile UUID of the bot.
   * This uniquely identifies the bot within the instance.
   *
   * @generated from protobuf field: string profile_id = 1
   */
  profileId: string;
  /**
   * Whether the bot is currently connected to a Minecraft server.
   * When false, the bot exists in configuration but is not active.
   *
   * @generated from protobuf field: bool is_online = 2
   */
  isOnline: boolean;
  /**
   * Live state of the bot if online and player data is available.
   * Will be absent if the bot is offline or the player hasn't fully spawned.
   * Note: For list views, inventory data is NOT included (too expensive).
   *
   * @generated from protobuf field: optional soulfire.v1.BotLiveState live_state = 3
   */
  liveState?: BotLiveState;
}
/**
 * Response containing the list of all bots in an instance.
 *
 * @generated from protobuf message soulfire.v1.BotListResponse
 */
export interface BotListResponse {
  /**
   * All bots configured in the instance, both online and offline.
   * The order is determined by the account configuration order.
   *
   * @generated from protobuf field: repeated soulfire.v1.BotListEntry bots = 1
   */
  bots: BotListEntry[];
}
/**
 * Represents an item in an inventory slot.
 * Used for both container slots and carried (cursor) items.
 *
 * @generated from protobuf message soulfire.v1.InventorySlot
 */
export interface InventorySlot {
  /**
   * The slot index within the container.
   * - For container menus: 0 to (total_slots - 1)
   * - For player inventory: 0-4 crafting, 5-8 armor, 9-35 main inventory, 36-44 hotbar, 45 offhand
   * - For carried items (cursor): -1 is used as a special indicator
   *
   * @generated from protobuf field: int32 slot = 1
   */
  slot: number;
  /**
   * The Minecraft item identifier in namespaced format.
   * Examples: "minecraft:diamond_sword", "minecraft:stone", "minecraft:enchanted_book"
   *
   * @generated from protobuf field: string item_id = 2
   */
  itemId: string;
  /**
   * The number of items in this stack.
   * Range: 1 to the item's maximum stack size (typically 1, 16, or 64).
   *
   * @generated from protobuf field: int32 count = 3
   */
  count: number;
  /**
   * The custom display name of the item, if it has been renamed.
   * Only present when the item has a custom name component (e.g., renamed in an anvil).
   * Contains the plain text string, not JSON text components.
   *
   * @generated from protobuf field: optional string display_name = 4
   */
  displayName?: string;
}
/**
 * Real-time state of a connected bot.
 * Contains position, health, inventory, and other live game data.
 *
 * @generated from protobuf message soulfire.v1.BotLiveState
 */
export interface BotLiveState {
  /**
   * X coordinate in the Minecraft world (east/west axis).
   * East is positive, West is negative.
   *
   * @generated from protobuf field: double x = 1
   */
  x: number;
  /**
   * Y coordinate in the Minecraft world (vertical axis).
   * Increases upward. Sea level is typically around 63.
   *
   * @generated from protobuf field: double y = 2
   */
  y: number;
  /**
   * Z coordinate in the Minecraft world (north/south axis).
   * South is positive, North is negative.
   *
   * @generated from protobuf field: double z = 3
   */
  z: number;
  /**
   * Vertical rotation (pitch) in degrees.
   * Range: -90 (looking straight up) to 90 (looking straight down).
   * 0 is looking at the horizon.
   *
   * @generated from protobuf field: float xRot = 4
   */
  xRot: number;
  /**
   * Horizontal rotation (yaw) in degrees.
   * Range: -180 to 180. 0 = South, 90 = West, -90 = East, +/-180 = North.
   *
   * @generated from protobuf field: float yRot = 5
   */
  yRot: number;
  /**
   * Current health points.
   * Range: 0 (dead) to max_health. 1 point = half a heart in the UI.
   *
   * @generated from protobuf field: float health = 6
   */
  health: number;
  /**
   * Maximum health points the player can have.
   * Default is 20 (10 hearts). Can be modified by effects or attributes.
   *
   * @generated from protobuf field: float max_health = 7
   */
  maxHealth: number;
  /**
   * Current hunger/food level.
   * Range: 0 (starving) to 20 (full). 1 point = half a drumstick in the UI.
   * Below 6, the player cannot sprint. At 0, health starts draining.
   *
   * @generated from protobuf field: int32 food_level = 8
   */
  foodLevel: number;
  /**
   * Current saturation level.
   * Range: 0 to food_level. Acts as a buffer before hunger depletes.
   * When saturation is above 0, hunger bar doesn't decrease while performing actions.
   *
   * @generated from protobuf field: float saturation_level = 9
   */
  saturationLevel: number;
  /**
   * Inventory slots containing items (only non-empty slots are included).
   * For list views (GetBotList), this will be empty for performance.
   * For detail views (GetBotInfo), contains all non-empty slots from the player inventory.
   *
   * @generated from protobuf field: repeated soulfire.v1.InventorySlot inventory = 10
   */
  inventory: InventorySlot[];
  /**
   * Currently selected hotbar slot index.
   * Range: 0 to 8, corresponding to hotbar slots 1-9 in the UI.
   *
   * @generated from protobuf field: int32 selected_hotbar_slot = 11
   */
  selectedHotbarSlot: number;
  /**
   * The dimension the player is currently in.
   * Format: namespaced identifier (e.g., "minecraft:overworld", "minecraft:the_nether", "minecraft:the_end").
   * Custom dimensions will use their server-defined namespace.
   *
   * @generated from protobuf field: string dimension = 12
   */
  dimension: string;
  /**
   * Player's current experience level (the number shown on the XP bar).
   * Range: 0 to theoretically unlimited (typically 0-30+ for enchanting).
   *
   * @generated from protobuf field: int32 experience_level = 13
   */
  experienceLevel: number;
  /**
   * Progress towards the next experience level.
   * Range: 0.0 (just reached current level) to 1.0 (about to level up).
   *
   * @generated from protobuf field: float experience_progress = 14
   */
  experienceProgress: number;
  /**
   * Skin texture hash for avatar rendering.
   * This is the hash extracted from the texture URL in the player's game profile.
   * Can be used with services like mc-heads.net: https://mc-heads.net/body/<hash>
   * Will be absent if the player has no custom skin or skin data is unavailable.
   *
   * @generated from protobuf field: optional string skin_texture_hash = 15
   */
  skinTextureHash?: string;
  /**
   * Current game mode of the player.
   * Determines available actions (breaking blocks, flying, taking damage, etc.).
   *
   * @generated from protobuf field: soulfire.v1.GameMode game_mode = 16
   */
  gameMode: GameMode;
}
/**
 * Response containing detailed information about a specific bot.
 *
 * @generated from protobuf message soulfire.v1.BotInfoResponse
 */
export interface BotInfoResponse {
  /**
   * Live state of the bot including full inventory data.
   * Will be absent if the bot is offline or player data is not available.
   * When present, includes complete inventory slot information.
   *
   * @generated from protobuf field: optional soulfire.v1.BotLiveState live_state = 2
   */
  liveState?: BotLiveState;
}
/**
 * Request to update a single configuration entry for a specific bot.
 * This allows granular updates without replacing the entire configuration.
 *
 * @generated from protobuf message soulfire.v1.BotUpdateConfigEntryRequest
 */
export interface BotUpdateConfigEntryRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to update configuration for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * The settings namespace (e.g., plugin ID or "bot" for core bot settings).
   * Examples: "bot", "auto-reconnect", "chat-message-controller"
   *
   * @generated from protobuf field: string namespace = 3
   */
  namespace: string;
  /**
   * The key within the namespace to update.
   * Must be a valid setting key defined for that namespace.
   *
   * @generated from protobuf field: string key = 4
   */
  key: string;
  /**
   * The new value to set for this configuration entry.
   * Must be a valid protobuf Value (null, number, string, bool, list, or struct).
   *
   * @generated from protobuf field: google.protobuf.Value value = 5
   */
  value?: Value;
}
/**
 * Response for bot configuration entry update.
 * Empty on success; errors are returned via gRPC status.
 *
 * @generated from protobuf message soulfire.v1.BotUpdateConfigEntryResponse
 */
export interface BotUpdateConfigEntryResponse {}
/**
 * Request to render the bot's point-of-view as an image.
 * Uses software rendering to generate a PNG image of what the bot "sees".
 *
 * @generated from protobuf message soulfire.v1.BotRenderPovRequest
 */
export interface BotRenderPovRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to render POV for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * Desired image width in pixels.
   * Default: 854 (if 0 or not provided).
   * Maximum: 1920 (values above this are clamped).
   * Minimum: 1 (values below this are clamped).
   *
   * @generated from protobuf field: int32 width = 3
   */
  width: number;
  /**
   * Desired image height in pixels.
   * Default: 480 (if 0 or not provided).
   * Maximum: 1080 (values above this are clamped).
   * Minimum: 1 (values below this are clamped).
   *
   * @generated from protobuf field: int32 height = 4
   */
  height: number;
}
/**
 * Response containing the rendered POV image.
 *
 * @generated from protobuf message soulfire.v1.BotRenderPovResponse
 */
export interface BotRenderPovResponse {
  /**
   * Base64-encoded PNG image data.
   * Decode with standard Base64 decoder to get raw PNG bytes.
   * The image uses the bot's current render distance setting.
   *
   * @generated from protobuf field: string image_base64 = 1
   */
  imageBase64: string;
}
// ============================================================================
// Inventory Management Messages
// ============================================================================

/**
 * Request to perform a click action on an inventory slot.
 * Simulates the various mouse click interactions available in Minecraft inventory UIs.
 *
 * @generated from protobuf message soulfire.v1.BotInventoryClickRequest
 */
export interface BotInventoryClickRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot performing the inventory action.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * The slot index to click.
   * Valid range depends on the currently open container.
   * Special value: -999 for clicking outside the inventory (dropping items).
   *
   * @generated from protobuf field: int32 slot = 3
   */
  slot: number;
  /**
   * The type of click to perform.
   * Different click types have different effects on items.
   *
   * @generated from protobuf field: soulfire.v1.ClickType click_type = 4
   */
  clickType: ClickType;
  /**
   * For SWAP_HOTBAR click type: which hotbar slot to swap with.
   * Range: 0-8 (corresponding to hotbar slots 1-9).
   * Ignored for other click types.
   *
   * @generated from protobuf field: int32 hotbar_slot = 5
   */
  hotbarSlot: number;
}
/**
 * Response for inventory click action.
 *
 * @generated from protobuf message soulfire.v1.BotInventoryClickResponse
 */
export interface BotInventoryClickResponse {
  /**
   * Whether the click action was successfully sent to the server.
   * Note: This indicates the action was sent, not that the server accepted it.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "Invalid click type"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Request to get the current state of the bot's open container/inventory.
 *
 * @generated from protobuf message soulfire.v1.BotInventoryStateRequest
 */
export interface BotInventoryStateRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to get inventory state for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * A group of slots that should be rendered together in the UI.
 * Defines the layout grid for a section of the inventory.
 *
 * @generated from protobuf message soulfire.v1.SlotRegion
 */
export interface SlotRegion {
  /**
   * Unique identifier for this region within the container.
   * Examples: "container", "player_inventory", "player_hotbar", "crafting_output"
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Display label for this region.
   * Examples: "Chest", "Inventory", "Hotbar", "Crafting Grid"
   *
   * @generated from protobuf field: string label = 2
   */
  label: string;
  /**
   * First slot index belonging to this region.
   * Slots are numbered sequentially from 0 across all regions.
   *
   * @generated from protobuf field: int32 start_index = 3
   */
  startIndex: number;
  /**
   * Total number of slots in this region.
   *
   * @generated from protobuf field: int32 slot_count = 4
   */
  slotCount: number;
  /**
   * Number of columns for grid layout.
   * Common values: 9 (standard inventory width), 3 (dispenser), 1 (armor column)
   *
   * @generated from protobuf field: int32 columns = 5
   */
  columns: number;
  /**
   * The type of region, affecting rendering behavior.
   *
   * @generated from protobuf field: soulfire.v1.SlotRegionType type = 6
   */
  type: SlotRegionType;
}
/**
 * A clickable button in a container menu.
 * Used for special interactions like enchantment selection, stonecutter recipes, trade offers, etc.
 *
 * @generated from protobuf message soulfire.v1.ContainerButton
 */
export interface ContainerButton {
  /**
   * Button ID to send to the server when clicking.
   * The meaning depends on the container type.
   *
   * @generated from protobuf field: int32 button_id = 1
   */
  buttonId: number;
  /**
   * Display label for the button.
   * Examples: "Enchant Slot 1", "Recipe 5", "8x Emerald -> 1x Diamond Pickaxe"
   *
   * @generated from protobuf field: string label = 2
   */
  label: string;
  /**
   * Optional item ID for displaying an icon.
   * Example: "minecraft:enchanted_book", "minecraft:stone_bricks"
   *
   * @generated from protobuf field: optional string icon_item_id = 3
   */
  iconItemId?: string;
  /**
   * Optional tooltip/description text with additional details.
   * Examples: "Requires 3 lapis, 30 levels", "Out of stock"
   *
   * @generated from protobuf field: optional string description = 4
   */
  description?: string;
  /**
   * Whether the button is currently disabled (cannot be clicked).
   * Reasons vary by container: missing materials, out of stock, insufficient levels, etc.
   *
   * @generated from protobuf field: bool disabled = 5
   */
  disabled: boolean;
  /**
   * Whether this button is currently selected/active.
   * Used for toggle-style buttons or to show current selection.
   *
   * @generated from protobuf field: bool selected = 6
   */
  selected: boolean;
}
/**
 * Text input field in a container menu.
 * Currently only used by the anvil for item renaming.
 *
 * @generated from protobuf message soulfire.v1.ContainerTextInput
 */
export interface ContainerTextInput {
  /**
   * Field identifier for the SetContainerText RPC.
   * Currently supported: "item_name" (anvil rename)
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Display label for the input field.
   *
   * @generated from protobuf field: string label = 2
   */
  label: string;
  /**
   * Current text value in the field.
   * For anvil: the item's current custom name, or empty if none.
   *
   * @generated from protobuf field: string current_value = 3
   */
  currentValue: string;
  /**
   * Maximum allowed character length.
   * For anvil: 50 characters.
   * Value of 0 means no limit.
   *
   * @generated from protobuf field: int32 max_length = 4
   */
  maxLength: number;
  /**
   * Placeholder text shown when field is empty.
   *
   * @generated from protobuf field: string placeholder = 5
   */
  placeholder: string;
}
/**
 * A page from a book, used for lectern display.
 *
 * @generated from protobuf message soulfire.v1.BookPage
 */
export interface BookPage {
  /**
   * Zero-indexed page number.
   *
   * @generated from protobuf field: int32 page_number = 1
   */
  pageNumber: number;
  /**
   * Page content text.
   * May contain Minecraft formatting codes (section symbols).
   *
   * @generated from protobuf field: string content = 2
   */
  content: string;
}
/**
 * Complete layout description for an open container menu.
 * Provides all information needed to render the container UI.
 *
 * @generated from protobuf message soulfire.v1.ContainerLayout
 */
export interface ContainerLayout {
  /**
   * Container title/name displayed at the top.
   * Examples: "Chest", "Crafting Table", "Inventory", custom container names.
   *
   * @generated from protobuf field: string title = 1
   */
  title: string;
  /**
   * Ordered list of slot regions defining the container layout.
   * Regions are listed in rendering order (typically container slots first, then player inventory).
   *
   * @generated from protobuf field: repeated soulfire.v1.SlotRegion regions = 2
   */
  regions: SlotRegion[];
  /**
   * Total number of slots in the container.
   * Sum of all region slot_counts.
   *
   * @generated from protobuf field: int32 total_slots = 3
   */
  totalSlots: number;
  /**
   * Available action buttons for this container.
   * Present for: stonecutter (recipes), enchanting table (3 enchant options),
   * loom (patterns), villager trading (trade offers), beacon (effects), etc.
   *
   * @generated from protobuf field: repeated soulfire.v1.ContainerButton buttons = 4
   */
  buttons: ContainerButton[];
  /**
   * Container type identifier for client-specific rendering.
   * Values: "inventory", "chest", "dispenser", "hopper", "furnace", "crafting",
   *         "anvil", "enchanting", "brewing", "beacon", "shulker", "grindstone",
   *         "stonecutter", "loom", "cartography", "smithing", "merchant",
   *         "crafter", "lectern", "generic"
   *
   * @generated from protobuf field: string container_type = 5
   */
  containerType: string;
  /**
   * Text input fields available in this container.
   * Currently only populated for anvil menus.
   *
   * @generated from protobuf field: repeated soulfire.v1.ContainerTextInput text_inputs = 6
   */
  textInputs: ContainerTextInput[];
  /**
   * Book pages for lectern containers.
   * Contains all pages of the book on the lectern.
   *
   * @generated from protobuf field: repeated soulfire.v1.BookPage book_pages = 7
   */
  bookPages: BookPage[];
  /**
   * Current page being displayed (for lectern).
   * Zero-indexed into book_pages.
   *
   * @generated from protobuf field: int32 current_book_page = 8
   */
  currentBookPage: number;
}
/**
 * Response containing the current inventory/container state.
 *
 * @generated from protobuf message soulfire.v1.BotInventoryStateResponse
 */
export interface BotInventoryStateResponse {
  /**
   * Layout information describing the container structure.
   *
   * @generated from protobuf field: soulfire.v1.ContainerLayout layout = 1
   */
  layout?: ContainerLayout;
  /**
   * All slots containing items (empty slots are omitted).
   *
   * @generated from protobuf field: repeated soulfire.v1.InventorySlot slots = 2
   */
  slots: InventorySlot[];
  /**
   * Item currently held on the cursor (being moved).
   * Absent if cursor is empty.
   *
   * @generated from protobuf field: optional soulfire.v1.InventorySlot carried_item = 3
   */
  carriedItem?: InventorySlot;
  /**
   * Currently selected hotbar slot index (0-8).
   *
   * @generated from protobuf field: int32 selected_hotbar_slot = 4
   */
  selectedHotbarSlot: number;
}
/**
 * Request to close the currently open container.
 *
 * @generated from protobuf message soulfire.v1.BotCloseContainerRequest
 */
export interface BotCloseContainerRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to close container for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Response for container close action.
 *
 * @generated from protobuf message soulfire.v1.BotCloseContainerResponse
 */
export interface BotCloseContainerResponse {
  /**
   * Whether the close action was successful.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
}
/**
 * Request to open the player's inventory screen.
 * This sends a packet to the server to open the inventory UI.
 *
 * @generated from protobuf message soulfire.v1.BotOpenInventoryRequest
 */
export interface BotOpenInventoryRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to open inventory for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Response for inventory open action.
 *
 * @generated from protobuf message soulfire.v1.BotOpenInventoryResponse
 */
export interface BotOpenInventoryResponse {
  /**
   * Whether the open inventory action was successful.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
}
// ============================================================================
// Mouse Click Messages
// ============================================================================

/**
 * Request to simulate a mouse click action in the game world.
 * Used for attacking entities, breaking blocks, using items, and interacting with blocks/entities.
 *
 * @generated from protobuf message soulfire.v1.BotMouseClickRequest
 */
export interface BotMouseClickRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot performing the click.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * Which mouse button to simulate clicking.
   *
   * @generated from protobuf field: soulfire.v1.MouseButton button = 3
   */
  button: MouseButton;
}
/**
 * Response for mouse click action.
 *
 * @generated from protobuf message soulfire.v1.BotMouseClickResponse
 */
export interface BotMouseClickResponse {
  /**
   * Whether the click action was successfully performed.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "Invalid mouse button"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Request to click a container-specific action button.
 * Used for stonecutter recipes, enchantment selection, villager trades, beacon effects, etc.
 *
 * @generated from protobuf message soulfire.v1.BotContainerButtonClickRequest
 */
export interface BotContainerButtonClickRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot clicking the button.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * The button ID to click.
   * Valid values depend on container type:
   * - Stonecutter: 0-99 (recipe index)
   * - Enchanting table: 0-2 (enchantment slot)
   * - Loom: 0-99 (pattern index)
   * - Villager: 0 to (offer count - 1)
   * - Beacon: mob effect registry ID, -1 for confirm
   * - Crafter: 0-8 (slot toggle index)
   * - Lectern: 1=prev page, 2=next page, 3=take book
   *
   * @generated from protobuf field: int32 button_id = 3
   */
  buttonId: number;
}
/**
 * Response for container button click action.
 *
 * @generated from protobuf message soulfire.v1.BotContainerButtonClickResponse
 */
export interface BotContainerButtonClickResponse {
  /**
   * Whether the button click was successfully queued.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "Invalid button ID for this container type"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Request to set text in a container text input field.
 * Currently only supports anvil item renaming.
 *
 * @generated from protobuf message soulfire.v1.BotSetContainerTextRequest
 */
export interface BotSetContainerTextRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot setting the text.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * Which field to set the text for.
   * Currently supported: "item_name" (anvil rename)
   *
   * @generated from protobuf field: string field_id = 3
   */
  fieldId: string;
  /**
   * The text value to set.
   * For anvil: max 50 characters for the item name.
   *
   * @generated from protobuf field: string text = 4
   */
  text: string;
}
/**
 * Response for container text input action.
 *
 * @generated from protobuf message soulfire.v1.BotSetContainerTextResponse
 */
export interface BotSetContainerTextResponse {
  /**
   * Whether the text was successfully set.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "Unsupported container or field ID: <type>/<field_id>"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Request to change the selected hotbar slot.
 *
 * @generated from protobuf message soulfire.v1.BotSetHotbarSlotRequest
 */
export interface BotSetHotbarSlotRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to change hotbar selection for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * Hotbar slot index to select.
   * Range: 0-8 (corresponding to slots 1-9 in the UI).
   *
   * @generated from protobuf field: int32 slot = 3
   */
  slot: number;
}
/**
 * Response for hotbar slot selection.
 *
 * @generated from protobuf message soulfire.v1.BotSetHotbarSlotResponse
 */
export interface BotSetHotbarSlotResponse {
  /**
   * Whether the hotbar slot was successfully changed.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "Hotbar slot must be between 0 and 8, got: <slot>",
   *                  "Player is not available"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
// ============================================================================
// Movement Control Messages
// Control bot movement (WASD, jump, sneak, sprint)
// ============================================================================

/**
 * Request to update the bot's movement state.
 * Each field is optional to allow partial updates - only specified fields are changed.
 * The movement state persists until explicitly changed or reset.
 *
 * @generated from protobuf message soulfire.v1.BotSetMovementStateRequest
 */
export interface BotSetMovementStateRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to control.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * W key state - move forward.
   * true = pressing W, false = not pressing W
   *
   * @generated from protobuf field: optional bool forward = 3
   */
  forward?: boolean;
  /**
   * S key state - move backward.
   * true = pressing S, false = not pressing S
   *
   * @generated from protobuf field: optional bool backward = 4
   */
  backward?: boolean;
  /**
   * A key state - strafe left.
   * true = pressing A, false = not pressing A
   *
   * @generated from protobuf field: optional bool left = 5
   */
  left?: boolean;
  /**
   * D key state - strafe right.
   * true = pressing D, false = not pressing D
   *
   * @generated from protobuf field: optional bool right = 6
   */
  right?: boolean;
  /**
   * Space key state - jump.
   * true = pressing Space, false = not pressing Space
   * When held, the bot will jump repeatedly.
   *
   * @generated from protobuf field: optional bool jump = 7
   */
  jump?: boolean;
  /**
   * Shift key state - sneak/crouch.
   * true = sneaking, false = not sneaking
   * While sneaking: slower movement, won't fall off edges, crouching animation.
   *
   * @generated from protobuf field: optional bool sneak = 8
   */
  sneak?: boolean;
  /**
   * Ctrl key state - sprint.
   * true = sprinting, false = not sprinting
   * Requires forward movement and sufficient hunger (food level >= 6).
   *
   * @generated from protobuf field: optional bool sprint = 9
   */
  sprint?: boolean;
}
/**
 * Response for movement state update.
 *
 * @generated from protobuf message soulfire.v1.BotSetMovementStateResponse
 */
export interface BotSetMovementStateResponse {
  /**
   * Whether the movement state was successfully updated.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Request to reset all movement to stopped state.
 * Equivalent to releasing all movement keys (WASD, Space, Shift, Ctrl).
 *
 * @generated from protobuf message soulfire.v1.BotResetMovementRequest
 */
export interface BotResetMovementRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to stop movement for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Response for movement reset.
 *
 * @generated from protobuf message soulfire.v1.BotResetMovementResponse
 */
export interface BotResetMovementResponse {
  /**
   * Whether the movement was successfully reset.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
// ============================================================================
// Rotation Control Messages
// Control bot view direction (yaw/pitch)
// ============================================================================

/**
 * Request to set the bot's view rotation (look direction).
 * Used to aim the bot's view at specific targets or directions.
 *
 * @generated from protobuf message soulfire.v1.BotSetRotationRequest
 */
export interface BotSetRotationRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to rotate.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * Horizontal rotation angle in degrees (yaw).
   * Range: -180 to 180 (values outside this range are normalized).
   * Direction mapping: 0 = South, 90 = West, -90 = East, +/-180 = North.
   *
   * @generated from protobuf field: float yaw = 3
   */
  yaw: number;
  /**
   * Vertical rotation angle in degrees (pitch).
   * Range: -90 to 90 (values outside this range are clamped).
   * Direction mapping: -90 = looking up, 0 = horizon, 90 = looking down.
   *
   * @generated from protobuf field: float pitch = 4
   */
  pitch: number;
}
/**
 * Response for rotation update.
 *
 * @generated from protobuf message soulfire.v1.BotSetRotationResponse
 */
export interface BotSetRotationResponse {
  /**
   * Whether the rotation was successfully set.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "Player is not available"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Body element that can appear in a dialog.
 * Dialogs can contain a mix of text and item displays.
 *
 * @generated from protobuf message soulfire.v1.DialogBodyElement
 */
export interface DialogBodyElement {
  /**
   * @generated from protobuf oneof: element
   */
  element:
    | {
        oneofKind: "plainMessage";
        /**
         * Plain text message element.
         *
         * @generated from protobuf field: soulfire.v1.DialogPlainMessage plain_message = 1
         */
        plainMessage: DialogPlainMessage;
      }
    | {
        oneofKind: "item";
        /**
         * Item display element (shows a Minecraft item).
         *
         * @generated from protobuf field: soulfire.v1.DialogItem item = 2
         */
        item: DialogItem;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * Plain text message in a dialog body.
 *
 * @generated from protobuf message soulfire.v1.DialogPlainMessage
 */
export interface DialogPlainMessage {
  /**
   * Text content, typically a JSON text component string.
   * May contain formatting, colors, click events, etc.
   *
   * @generated from protobuf field: string contents = 1
   */
  contents: string;
  /**
   * Display width in pixels.
   * Range: 1-1024, default: 200.
   *
   * @generated from protobuf field: int32 width = 2
   */
  width: number;
}
/**
 * Item display element in a dialog body.
 *
 * @generated from protobuf message soulfire.v1.DialogItem
 */
export interface DialogItem {
  /**
   * Minecraft item identifier.
   * Example: "minecraft:diamond", "minecraft:netherite_sword"
   *
   * @generated from protobuf field: string item_id = 1
   */
  itemId: string;
  /**
   * Item count/stack size to display.
   *
   * @generated from protobuf field: int32 count = 2
   */
  count: number;
  /**
   * Optional description text below the item.
   *
   * @generated from protobuf field: optional string description = 3
   */
  description?: string;
  /**
   * Whether to show the item frame decoration around the item.
   * Default: true.
   *
   * @generated from protobuf field: bool show_decoration = 4
   */
  showDecoration: boolean;
  /**
   * Whether to show the item tooltip on hover.
   * Default: true.
   *
   * @generated from protobuf field: bool show_tooltip = 5
   */
  showTooltip: boolean;
  /**
   * Display width in pixels.
   * Range: 1-256, default: 16.
   *
   * @generated from protobuf field: int32 width = 6
   */
  width: number;
  /**
   * Display height in pixels.
   * Range: 1-256, default: 16.
   *
   * @generated from protobuf field: int32 height = 7
   */
  height: number;
}
/**
 * Input control that can appear in a dialog.
 * Allows dialogs to gather user input before submission.
 *
 * @generated from protobuf message soulfire.v1.DialogInput
 */
export interface DialogInput {
  /**
   * @generated from protobuf oneof: input
   */
  input:
    | {
        oneofKind: "text";
        /**
         * Text input field (single or multi-line).
         *
         * @generated from protobuf field: soulfire.v1.DialogTextInput text = 1
         */
        text: DialogTextInput;
      }
    | {
        oneofKind: "boolean";
        /**
         * Boolean checkbox input.
         *
         * @generated from protobuf field: soulfire.v1.DialogBooleanInput boolean = 2
         */
        boolean: DialogBooleanInput;
      }
    | {
        oneofKind: "singleOption";
        /**
         * Dropdown/combo box for selecting one option.
         *
         * @generated from protobuf field: soulfire.v1.DialogSingleOptionInput single_option = 3
         */
        singleOption: DialogSingleOptionInput;
      }
    | {
        oneofKind: "numberRange";
        /**
         * Slider for selecting a number in a range.
         *
         * @generated from protobuf field: soulfire.v1.DialogNumberRangeInput number_range = 4
         */
        numberRange: DialogNumberRangeInput;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * Text input field in a dialog.
 *
 * @generated from protobuf message soulfire.v1.DialogTextInput
 */
export interface DialogTextInput {
  /**
   * Identifier used when submitting the dialog.
   *
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * Display label for the field.
   *
   * @generated from protobuf field: string label = 2
   */
  label: string;
  /**
   * Display width in pixels.
   * Range: 1-1024, default: 200.
   *
   * @generated from protobuf field: int32 width = 3
   */
  width: number;
  /**
   * Whether to show the label.
   * Default: true.
   *
   * @generated from protobuf field: bool label_visible = 4
   */
  labelVisible: boolean;
  /**
   * Initial/default value.
   *
   * @generated from protobuf field: string initial = 5
   */
  initial: string;
  /**
   * Maximum character length.
   * Default: 32.
   *
   * @generated from protobuf field: int32 max_length = 6
   */
  maxLength: number;
  /**
   * Whether to allow multi-line input.
   *
   * @generated from protobuf field: bool multiline = 7
   */
  multiline: boolean;
  /**
   * Maximum lines for multiline input.
   *
   * @generated from protobuf field: int32 multiline_max_lines = 8
   */
  multilineMaxLines: number;
  /**
   * Display height for multiline input in pixels.
   *
   * @generated from protobuf field: int32 multiline_height = 9
   */
  multilineHeight: number;
}
/**
 * Boolean checkbox input in a dialog.
 *
 * @generated from protobuf message soulfire.v1.DialogBooleanInput
 */
export interface DialogBooleanInput {
  /**
   * Identifier used when submitting the dialog.
   *
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * Display label for the checkbox.
   *
   * @generated from protobuf field: string label = 2
   */
  label: string;
  /**
   * Initial checked state.
   * Default: false.
   *
   * @generated from protobuf field: bool initial = 3
   */
  initial: boolean;
  /**
   * String value to submit when checked.
   * Default: "true".
   *
   * @generated from protobuf field: string on_true = 4
   */
  onTrue: string;
  /**
   * String value to submit when unchecked.
   * Default: "false".
   *
   * @generated from protobuf field: string on_false = 5
   */
  onFalse: string;
}
/**
 * Single option selection input (dropdown/combo box) in a dialog.
 *
 * @generated from protobuf message soulfire.v1.DialogSingleOptionInput
 */
export interface DialogSingleOptionInput {
  /**
   * Identifier used when submitting the dialog.
   *
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * Display label for the dropdown.
   *
   * @generated from protobuf field: string label = 2
   */
  label: string;
  /**
   * Whether to show the label.
   * Default: true.
   *
   * @generated from protobuf field: bool label_visible = 3
   */
  labelVisible: boolean;
  /**
   * Display width in pixels.
   * Range: 1-1024, default: 200.
   *
   * @generated from protobuf field: int32 width = 4
   */
  width: number;
  /**
   * Available options to choose from.
   *
   * @generated from protobuf field: repeated soulfire.v1.DialogOption options = 5
   */
  options: DialogOption[];
  /**
   * ID of the initially selected option.
   *
   * @generated from protobuf field: string initial_option_id = 6
   */
  initialOptionId: string;
}
/**
 * An option in a single-option input.
 *
 * @generated from protobuf message soulfire.v1.DialogOption
 */
export interface DialogOption {
  /**
   * Option identifier (submitted value).
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Display text for the option.
   * If empty, the id is used for display.
   *
   * @generated from protobuf field: string display = 2
   */
  display: string;
}
/**
 * Number range slider input in a dialog.
 *
 * @generated from protobuf message soulfire.v1.DialogNumberRangeInput
 */
export interface DialogNumberRangeInput {
  /**
   * Identifier used when submitting the dialog.
   *
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * Display label for the slider.
   *
   * @generated from protobuf field: string label = 2
   */
  label: string;
  /**
   * Translation key for formatting the label with the current value.
   *
   * @generated from protobuf field: string label_format = 3
   */
  labelFormat: string;
  /**
   * Display width in pixels.
   * Range: 1-1024, default: 200.
   *
   * @generated from protobuf field: int32 width = 4
   */
  width: number;
  /**
   * Minimum value (left side of slider).
   *
   * @generated from protobuf field: double start = 5
   */
  start: number;
  /**
   * Maximum value (right side of slider).
   *
   * @generated from protobuf field: double end = 6
   */
  end: number;
  /**
   * Step size for discrete values.
   * If 0, continuous values are allowed.
   *
   * @generated from protobuf field: double step = 7
   */
  step: number;
  /**
   * Initial/default value.
   *
   * @generated from protobuf field: double initial = 8
   */
  initial: number;
}
/**
 * Action that can be triggered by a dialog button.
 *
 * @generated from protobuf message soulfire.v1.DialogAction
 */
export interface DialogAction {
  /**
   * @generated from protobuf oneof: action
   */
  action:
    | {
        oneofKind: "openUrl";
        /**
         * Open a URL in the browser.
         *
         * @generated from protobuf field: soulfire.v1.DialogOpenUrlAction open_url = 1
         */
        openUrl: DialogOpenUrlAction;
      }
    | {
        oneofKind: "runCommand";
        /**
         * Run a chat command.
         *
         * @generated from protobuf field: soulfire.v1.DialogRunCommandAction run_command = 2
         */
        runCommand: DialogRunCommandAction;
      }
    | {
        oneofKind: "suggestCommand";
        /**
         * Suggest a command (put in chat box without sending).
         *
         * @generated from protobuf field: soulfire.v1.DialogSuggestCommandAction suggest_command = 3
         */
        suggestCommand: DialogSuggestCommandAction;
      }
    | {
        oneofKind: "copyToClipboard";
        /**
         * Copy text to clipboard.
         *
         * @generated from protobuf field: soulfire.v1.DialogCopyToClipboardAction copy_to_clipboard = 4
         */
        copyToClipboard: DialogCopyToClipboardAction;
      }
    | {
        oneofKind: "showDialog";
        /**
         * Show another dialog.
         *
         * @generated from protobuf field: soulfire.v1.DialogShowDialogAction show_dialog = 5
         */
        showDialog: DialogShowDialogAction;
      }
    | {
        oneofKind: "custom";
        /**
         * Custom server-defined action.
         *
         * @generated from protobuf field: soulfire.v1.DialogCustomAction custom = 6
         */
        custom: DialogCustomAction;
      }
    | {
        oneofKind: "dynamicRunCommand";
        /**
         * Run a command with input placeholders.
         *
         * @generated from protobuf field: soulfire.v1.DialogDynamicRunCommandAction dynamic_run_command = 7
         */
        dynamicRunCommand: DialogDynamicRunCommandAction;
      }
    | {
        oneofKind: "dynamicCustom";
        /**
         * Custom action with additional data.
         *
         * @generated from protobuf field: soulfire.v1.DialogDynamicCustomAction dynamic_custom = 8
         */
        dynamicCustom: DialogDynamicCustomAction;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * Action to open a URL in the user's browser.
 *
 * @generated from protobuf message soulfire.v1.DialogOpenUrlAction
 */
export interface DialogOpenUrlAction {
  /**
   * The URL to open.
   *
   * @generated from protobuf field: string url = 1
   */
  url: string;
}
/**
 * Action to execute a chat command.
 *
 * @generated from protobuf message soulfire.v1.DialogRunCommandAction
 */
export interface DialogRunCommandAction {
  /**
   * The command to run (including the leading /).
   *
   * @generated from protobuf field: string command = 1
   */
  command: string;
}
/**
 * Action to suggest a command (place in chat input).
 *
 * @generated from protobuf message soulfire.v1.DialogSuggestCommandAction
 */
export interface DialogSuggestCommandAction {
  /**
   * The command to suggest.
   *
   * @generated from protobuf field: string command = 1
   */
  command: string;
}
/**
 * Action to copy text to the clipboard.
 *
 * @generated from protobuf message soulfire.v1.DialogCopyToClipboardAction
 */
export interface DialogCopyToClipboardAction {
  /**
   * The text to copy.
   *
   * @generated from protobuf field: string value = 1
   */
  value: string;
}
/**
 * Action to display another dialog.
 *
 * @generated from protobuf message soulfire.v1.DialogShowDialogAction
 */
export interface DialogShowDialogAction {
  /**
   * Dialog ID to show (references a registered dialog).
   *
   * @generated from protobuf field: string dialog_id = 1
   */
  dialogId: string;
}
/**
 * Custom server-defined action.
 *
 * @generated from protobuf message soulfire.v1.DialogCustomAction
 */
export interface DialogCustomAction {
  /**
   * Action identifier known to the server.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Optional JSON payload for the action.
   *
   * @generated from protobuf field: string payload = 2
   */
  payload: string;
}
/**
 * Dynamic command action with input value substitution.
 *
 * @generated from protobuf message soulfire.v1.DialogDynamicRunCommandAction
 */
export interface DialogDynamicRunCommandAction {
  /**
   * Command template with placeholders for input values.
   * Placeholders are replaced with user input before execution.
   *
   * @generated from protobuf field: string template = 1
   */
  template: string;
}
/**
 * Dynamic custom action with additional NBT data.
 *
 * @generated from protobuf message soulfire.v1.DialogDynamicCustomAction
 */
export interface DialogDynamicCustomAction {
  /**
   * Custom action identifier.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Additional NBT data as JSON string.
   *
   * @generated from protobuf field: string additions = 2
   */
  additions: string;
}
/**
 * Button that can appear in a dialog.
 *
 * @generated from protobuf message soulfire.v1.DialogButton
 */
export interface DialogButton {
  /**
   * Button text (may be a JSON text component).
   *
   * @generated from protobuf field: string label = 1
   */
  label: string;
  /**
   * Optional tooltip shown on hover.
   *
   * @generated from protobuf field: optional string tooltip = 2
   */
  tooltip?: string;
  /**
   * Button width in pixels.
   * Range: 1-1024, default: 150.
   *
   * @generated from protobuf field: int32 width = 3
   */
  width: number;
  /**
   * Action to perform when clicked.
   *
   * @generated from protobuf field: optional soulfire.v1.DialogAction action = 4
   */
  action?: DialogAction;
}
/**
 * Complete server dialog definition.
 * Contains all information needed to render and interact with a dialog.
 *
 * @generated from protobuf message soulfire.v1.ServerDialog
 */
export interface ServerDialog {
  /**
   * Dialog identifier from the server.
   * Format: namespaced identifier (e.g., "myserver:welcome_dialog").
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * The type of dialog, determining overall structure.
   *
   * @generated from protobuf field: soulfire.v1.DialogType type = 2
   */
  type: DialogType;
  /**
   * Dialog title (may be a JSON text component).
   *
   * @generated from protobuf field: string title = 3
   */
  title: string;
  /**
   * Button label when shown as an external/minimized button.
   *
   * @generated from protobuf field: optional string external_title = 4
   */
  externalTitle?: string;
  /**
   * Body elements (text and items) displayed in the dialog.
   *
   * @generated from protobuf field: repeated soulfire.v1.DialogBodyElement body = 5
   */
  body: DialogBodyElement[];
  /**
   * Input controls for gathering user data.
   *
   * @generated from protobuf field: repeated soulfire.v1.DialogInput inputs = 6
   */
  inputs: DialogInput[];
  /**
   * Whether ESC key can close the dialog.
   * Default: true.
   *
   * @generated from protobuf field: bool can_close_with_escape = 7
   */
  canCloseWithEscape: boolean;
  /**
   * Whether to pause the game in singleplayer.
   * Default: true. No effect in multiplayer.
   *
   * @generated from protobuf field: bool pause = 8
   */
  pause: boolean;
  /**
   * Behavior after an action button is clicked.
   *
   * @generated from protobuf field: soulfire.v1.DialogAfterAction after_action = 9
   */
  afterAction: DialogAfterAction;
  /**
   * For NOTICE type: the single action button.
   *
   * @generated from protobuf field: optional soulfire.v1.DialogButton action = 10
   */
  action?: DialogButton;
  /**
   * For CONFIRMATION type: the "yes" button.
   *
   * @generated from protobuf field: optional soulfire.v1.DialogButton yes = 11
   */
  yes?: DialogButton;
  /**
   * For CONFIRMATION type: the "no" button.
   *
   * @generated from protobuf field: optional soulfire.v1.DialogButton no = 12
   */
  no?: DialogButton;
  /**
   * For MULTI_ACTION type: list of action buttons.
   *
   * @generated from protobuf field: repeated soulfire.v1.DialogButton actions = 13
   */
  actions: DialogButton[];
  /**
   * For MULTI_ACTION and DIALOG_LIST: number of button columns.
   * Default: 2.
   *
   * @generated from protobuf field: int32 columns = 14
   */
  columns: number;
  /**
   * For MULTI_ACTION, SERVER_LINKS, DIALOG_LIST: exit/close button.
   *
   * @generated from protobuf field: optional soulfire.v1.DialogButton exit_action = 15
   */
  exitAction?: DialogButton;
  /**
   * For SERVER_LINKS and DIALOG_LIST: button width.
   * Default: 150.
   *
   * @generated from protobuf field: int32 button_width = 16
   */
  buttonWidth: number;
}
/**
 * Request to get the currently displayed dialog (if any).
 *
 * @generated from protobuf message soulfire.v1.BotGetDialogRequest
 */
export interface BotGetDialogRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to get dialog for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Response containing the current dialog state.
 *
 * @generated from protobuf message soulfire.v1.BotGetDialogResponse
 */
export interface BotGetDialogResponse {
  /**
   * The currently displayed dialog.
   * Absent if no dialog is being shown.
   *
   * @generated from protobuf field: optional soulfire.v1.ServerDialog dialog = 1
   */
  dialog?: ServerDialog;
}
/**
 * Request to submit a dialog with input values.
 * Used for dialogs that have input fields requiring user data.
 *
 * @generated from protobuf message soulfire.v1.BotSubmitDialogRequest
 */
export interface BotSubmitDialogRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot submitting the dialog.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * Map of input key to value for each input field.
   * Keys must match the `key` field of DialogInput elements.
   *
   * @generated from protobuf field: map<string, string> input_values = 3
   */
  inputValues: {
    [key: string]: string;
  };
}
/**
 * Response for dialog submission.
 *
 * @generated from protobuf message soulfire.v1.BotSubmitDialogResponse
 */
export interface BotSubmitDialogResponse {
  /**
   * Whether the submission was processed successfully.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "No dialog is currently displayed"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Request to click a button in the current dialog.
 *
 * @generated from protobuf message soulfire.v1.BotClickDialogButtonRequest
 */
export interface BotClickDialogButtonRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot clicking the button.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
  /**
   * Index of the button to click.
   * For NOTICE: 0 for the action button
   * For CONFIRMATION: 0 for yes, 1 for no
   * For MULTI_ACTION: index into the actions list
   * Special value: -1 to close/escape the dialog
   *
   * @generated from protobuf field: int32 button_index = 3
   */
  buttonIndex: number;
}
/**
 * Response for dialog button click.
 *
 * @generated from protobuf message soulfire.v1.BotClickDialogButtonResponse
 */
export interface BotClickDialogButtonResponse {
  /**
   * Whether the button click was processed successfully.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   * Possible errors: "No dialog is currently displayed"
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Request to close/dismiss the current dialog.
 *
 * @generated from protobuf message soulfire.v1.BotCloseDialogRequest
 */
export interface BotCloseDialogRequest {
  /**
   * The UUID of the SoulFire instance containing the bot.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The profile UUID of the bot to close dialog for.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Response for dialog close.
 *
 * @generated from protobuf message soulfire.v1.BotCloseDialogResponse
 */
export interface BotCloseDialogResponse {
  /**
   * Whether the dialog was successfully closed.
   *
   * @generated from protobuf field: bool success = 1
   */
  success: boolean;
  /**
   * Error message if success is false.
   *
   * @generated from protobuf field: optional string error = 2
   */
  error?: string;
}
/**
 * Minecraft game modes that determine player capabilities.
 *
 * @generated from protobuf enum soulfire.v1.GameMode
 */
export enum GameMode {
  /**
   * Unknown or not yet determined game mode.
   *
   * @generated from protobuf enum value: GAME_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * Survival mode: resource gathering, health/hunger management, mob combat.
   *
   * @generated from protobuf enum value: GAME_MODE_SURVIVAL = 1;
   */
  SURVIVAL = 1,
  /**
   * Creative mode: unlimited resources, instant block breaking, flying, invulnerability.
   *
   * @generated from protobuf enum value: GAME_MODE_CREATIVE = 2;
   */
  CREATIVE = 2,
  /**
   * Adventure mode: like survival but cannot break/place blocks without proper tools.
   *
   * @generated from protobuf enum value: GAME_MODE_ADVENTURE = 3;
   */
  ADVENTURE = 3,
  /**
   * Spectator mode: invisible, can fly through blocks, cannot interact with the world.
   *
   * @generated from protobuf enum value: GAME_MODE_SPECTATOR = 4;
   */
  SPECTATOR = 4,
}
/**
 * Types of inventory click actions available in Minecraft.
 *
 * @generated from protobuf enum soulfire.v1.ClickType
 */
export enum ClickType {
  /**
   * Invalid/unspecified click type. Will result in an error.
   *
   * @generated from protobuf enum value: CLICK_TYPE_UNSPECIFIED = 0;
   */
  CLICK_TYPE_UNSPECIFIED = 0,
  /**
   * Left mouse click on a slot.
   * - Empty cursor + item in slot: Pick up entire stack to cursor
   * - Item on cursor + empty slot: Place entire stack in slot
   * - Item on cursor + same item in slot: Combine stacks (up to max stack size)
   * - Item on cursor + different item in slot: Swap cursor and slot items
   *
   * @generated from protobuf enum value: LEFT_CLICK = 1;
   */
  LEFT_CLICK = 1,
  /**
   * Right mouse click on a slot.
   * - Empty cursor + item in slot: Pick up half the stack (rounded up)
   * - Item on cursor + empty slot: Place one item from cursor
   * - Item on cursor + same item in slot: Place one item from cursor
   * - Item on cursor + different item in slot: Swap cursor and slot items
   *
   * @generated from protobuf enum value: RIGHT_CLICK = 2;
   */
  RIGHT_CLICK = 2,
  /**
   * Shift + left click on a slot.
   * Quick-moves the item stack to the opposite inventory section.
   * - From player inventory to container (chest, furnace, etc.)
   * - From container to player inventory
   * - Between hotbar and main inventory
   *
   * @generated from protobuf enum value: SHIFT_LEFT_CLICK = 3;
   */
  SHIFT_LEFT_CLICK = 3,
  /**
   * Drop one item from the slot (Q key while hovering over slot).
   * Drops a single item from the stack, leaving the rest.
   *
   * @generated from protobuf enum value: DROP_ONE = 4;
   */
  DROP_ONE = 4,
  /**
   * Drop entire stack from the slot (Ctrl+Q while hovering over slot).
   * Drops all items from the stack at once.
   *
   * @generated from protobuf enum value: DROP_ALL = 5;
   */
  DROP_ALL = 5,
  /**
   * Swap slot contents with a hotbar slot (number keys 1-9).
   * Requires hotbar_slot field to specify which hotbar slot (0-8).
   * Works regardless of what's in the cursor.
   *
   * @generated from protobuf enum value: SWAP_HOTBAR = 6;
   */
  SWAP_HOTBAR = 6,
  /**
   * Middle mouse click (creative mode clone).
   * In creative mode, clones the item to cursor without affecting the slot.
   * No effect in survival mode.
   *
   * @generated from protobuf enum value: MIDDLE_CLICK = 7;
   */
  MIDDLE_CLICK = 7,
}
/**
 * Describes how a region of slots should be rendered in the UI.
 * Different region types have different visual treatments.
 *
 * @generated from protobuf enum soulfire.v1.SlotRegionType
 */
export enum SlotRegionType {
  /**
   * Regular interactive slots that can accept most items.
   *
   * @generated from protobuf enum value: SLOT_REGION_NORMAL = 0;
   */
  SLOT_REGION_NORMAL = 0,
  /**
   * Output-only slots (crafting result, furnace output).
   * Items can only be taken out, not placed in.
   *
   * @generated from protobuf enum value: SLOT_REGION_OUTPUT = 1;
   */
  SLOT_REGION_OUTPUT = 1,
  /**
   * Display-only slots (lectern book display, some special UIs).
   * May not allow any direct interaction.
   *
   * @generated from protobuf enum value: SLOT_REGION_DISPLAY = 2;
   */
  SLOT_REGION_DISPLAY = 2,
  /**
   * Player hotbar slots.
   * Should show selection indicator for the currently selected slot.
   *
   * @generated from protobuf enum value: SLOT_REGION_HOTBAR = 3;
   */
  SLOT_REGION_HOTBAR = 3,
  /**
   * Armor slots in player inventory.
   * May display placeholder armor icons when empty.
   *
   * @generated from protobuf enum value: SLOT_REGION_ARMOR = 4;
   */
  SLOT_REGION_ARMOR = 4,
}
/**
 * Mouse buttons for world interaction.
 *
 * @generated from protobuf enum soulfire.v1.MouseButton
 */
export enum MouseButton {
  /**
   * Invalid/unspecified button. Will result in an error.
   *
   * @generated from protobuf enum value: MOUSE_BUTTON_UNSPECIFIED = 0;
   */
  MOUSE_BUTTON_UNSPECIFIED = 0,
  /**
   * Left mouse button.
   * Actions: Attack entity (if looking at one), start breaking block (if looking at one).
   *
   * @generated from protobuf enum value: LEFT_BUTTON = 1;
   */
  LEFT_BUTTON = 1,
  /**
   * Right mouse button.
   * Actions: Use held item, interact with entity (if looking at one),
   *          interact with block (if looking at one, e.g., open chest, press button).
   *
   * @generated from protobuf enum value: RIGHT_BUTTON = 2;
   */
  RIGHT_BUTTON = 2,
}
// ============================================================================
// Server Dialog Messages (Minecraft 1.21.6+)
// Dialogs are server-sent UI screens that can display information and gather input.
// They were introduced in Minecraft 1.21.6 as a way for servers to create custom UIs.
// ============================================================================

/**
 * Dialog types matching Minecraft's dialog registry.
 * Determines the overall structure and behavior of the dialog.
 *
 * @generated from protobuf enum soulfire.v1.DialogType
 */
export enum DialogType {
  /**
   * Unknown or unrecognized dialog type.
   *
   * @generated from protobuf enum value: DIALOG_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * Notice dialog with a single action button in the footer.
   * Used for informational messages that require acknowledgment.
   *
   * @generated from protobuf enum value: DIALOG_TYPE_NOTICE = 1;
   */
  NOTICE = 1,
  /**
   * Confirmation dialog with Yes/No buttons in the footer.
   * Used for binary choices.
   *
   * @generated from protobuf enum value: DIALOG_TYPE_CONFIRMATION = 2;
   */
  CONFIRMATION = 2,
  /**
   * Multi-action dialog with a scrollable list of action buttons.
   * Used for menus with multiple options.
   *
   * @generated from protobuf enum value: DIALOG_TYPE_MULTI_ACTION = 3;
   */
  MULTI_ACTION = 3,
  /**
   * Server links dialog displaying clickable links.
   * Used to show server website, Discord, etc.
   *
   * @generated from protobuf enum value: DIALOG_TYPE_SERVER_LINKS = 4;
   */
  SERVER_LINKS = 4,
  /**
   * Dialog list with buttons linking to other dialogs.
   * Used for hierarchical menu navigation.
   *
   * @generated from protobuf enum value: DIALOG_TYPE_DIALOG_LIST = 5;
   */
  DIALOG_LIST = 5,
}
/**
 * Behavior after a dialog action is triggered.
 *
 * @generated from protobuf enum soulfire.v1.DialogAfterAction
 */
export enum DialogAfterAction {
  /**
   * Unspecified, use dialog default.
   *
   * @generated from protobuf enum value: DIALOG_AFTER_ACTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * Close the dialog after the action.
   * This is the default behavior.
   *
   * @generated from protobuf enum value: DIALOG_AFTER_ACTION_CLOSE = 1;
   */
  CLOSE = 1,
  /**
   * Keep the dialog open after the action.
   *
   * @generated from protobuf enum value: DIALOG_AFTER_ACTION_NONE = 2;
   */
  NONE = 2,
  /**
   * Show a waiting/loading screen while action processes.
   *
   * @generated from protobuf enum value: DIALOG_AFTER_ACTION_WAIT_FOR_RESPONSE = 3;
   */
  WAIT_FOR_RESPONSE = 3,
}
// @generated message type with reflection information, may provide speed optimized methods
class BotInfoRequest$Type extends MessageType<BotInfoRequest> {
  constructor() {
    super("soulfire.v1.BotInfoRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BotInfoRequest>): BotInfoRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotInfoRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotInfoRequest,
  ): BotInfoRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotInfoRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotInfoRequest
 */
export const BotInfoRequest = new BotInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotListRequest$Type extends MessageType<BotListRequest> {
  constructor() {
    super("soulfire.v1.BotListRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<BotListRequest>): BotListRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    if (value !== undefined)
      reflectionMergePartial<BotListRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotListRequest,
  ): BotListRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotListRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotListRequest
 */
export const BotListRequest = new BotListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotListEntry$Type extends MessageType<BotListEntry> {
  constructor() {
    super("soulfire.v1.BotListEntry", [
      { no: 1, name: "profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "is_online", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: "live_state", kind: "message", T: () => BotLiveState },
    ]);
  }
  create(value?: PartialMessage<BotListEntry>): BotListEntry {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.profileId = "";
    message.isOnline = false;
    if (value !== undefined)
      reflectionMergePartial<BotListEntry>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotListEntry,
  ): BotListEntry {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string profile_id */ 1:
          message.profileId = reader.string();
          break;
        case /* bool is_online */ 2:
          message.isOnline = reader.bool();
          break;
        case /* optional soulfire.v1.BotLiveState live_state */ 3:
          message.liveState = BotLiveState.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.liveState,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotListEntry,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string profile_id = 1; */
    if (message.profileId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.profileId);
    /* bool is_online = 2; */
    if (message.isOnline !== false)
      writer.tag(2, WireType.Varint).bool(message.isOnline);
    /* optional soulfire.v1.BotLiveState live_state = 3; */
    if (message.liveState)
      BotLiveState.internalBinaryWrite(
        message.liveState,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotListEntry
 */
export const BotListEntry = new BotListEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotListResponse$Type extends MessageType<BotListResponse> {
  constructor() {
    super("soulfire.v1.BotListResponse", [
      {
        no: 1,
        name: "bots",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BotListEntry,
      },
    ]);
  }
  create(value?: PartialMessage<BotListResponse>): BotListResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.bots = [];
    if (value !== undefined)
      reflectionMergePartial<BotListResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotListResponse,
  ): BotListResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.BotListEntry bots */ 1:
          message.bots.push(
            BotListEntry.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotListResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.BotListEntry bots = 1; */
    for (let i = 0; i < message.bots.length; i++)
      BotListEntry.internalBinaryWrite(
        message.bots[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotListResponse
 */
export const BotListResponse = new BotListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InventorySlot$Type extends MessageType<InventorySlot> {
  constructor() {
    super("soulfire.v1.InventorySlot", [
      { no: 1, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 4,
        name: "display_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<InventorySlot>): InventorySlot {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.slot = 0;
    message.itemId = "";
    message.count = 0;
    if (value !== undefined)
      reflectionMergePartial<InventorySlot>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: InventorySlot,
  ): InventorySlot {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 slot */ 1:
          message.slot = reader.int32();
          break;
        case /* string item_id */ 2:
          message.itemId = reader.string();
          break;
        case /* int32 count */ 3:
          message.count = reader.int32();
          break;
        case /* optional string display_name */ 4:
          message.displayName = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: InventorySlot,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 slot = 1; */
    if (message.slot !== 0) writer.tag(1, WireType.Varint).int32(message.slot);
    /* string item_id = 2; */
    if (message.itemId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.itemId);
    /* int32 count = 3; */
    if (message.count !== 0)
      writer.tag(3, WireType.Varint).int32(message.count);
    /* optional string display_name = 4; */
    if (message.displayName !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.displayName);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.InventorySlot
 */
export const InventorySlot = new InventorySlot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotLiveState$Type extends MessageType<BotLiveState> {
  constructor() {
    super("soulfire.v1.BotLiveState", [
      { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 3, name: "z", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 4, name: "xRot", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
      { no: 5, name: "yRot", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: "health", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: "max_health", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
      { no: 8, name: "food_level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 9,
        name: "saturation_level",
        kind: "scalar",
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 10,
        name: "inventory",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => InventorySlot,
      },
      {
        no: 11,
        name: "selected_hotbar_slot",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      { no: 12, name: "dimension", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 13,
        name: "experience_level",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 14,
        name: "experience_progress",
        kind: "scalar",
        T: 2 /*ScalarType.FLOAT*/,
      },
      {
        no: 15,
        name: "skin_texture_hash",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 16,
        name: "game_mode",
        kind: "enum",
        T: () => ["soulfire.v1.GameMode", GameMode, "GAME_MODE_"],
      },
    ]);
  }
  create(value?: PartialMessage<BotLiveState>): BotLiveState {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.x = 0;
    message.y = 0;
    message.z = 0;
    message.xRot = 0;
    message.yRot = 0;
    message.health = 0;
    message.maxHealth = 0;
    message.foodLevel = 0;
    message.saturationLevel = 0;
    message.inventory = [];
    message.selectedHotbarSlot = 0;
    message.dimension = "";
    message.experienceLevel = 0;
    message.experienceProgress = 0;
    message.gameMode = 0;
    if (value !== undefined)
      reflectionMergePartial<BotLiveState>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotLiveState,
  ): BotLiveState {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double x */ 1:
          message.x = reader.double();
          break;
        case /* double y */ 2:
          message.y = reader.double();
          break;
        case /* double z */ 3:
          message.z = reader.double();
          break;
        case /* float xRot */ 4:
          message.xRot = reader.float();
          break;
        case /* float yRot */ 5:
          message.yRot = reader.float();
          break;
        case /* float health */ 6:
          message.health = reader.float();
          break;
        case /* float max_health */ 7:
          message.maxHealth = reader.float();
          break;
        case /* int32 food_level */ 8:
          message.foodLevel = reader.int32();
          break;
        case /* float saturation_level */ 9:
          message.saturationLevel = reader.float();
          break;
        case /* repeated soulfire.v1.InventorySlot inventory */ 10:
          message.inventory.push(
            InventorySlot.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* int32 selected_hotbar_slot */ 11:
          message.selectedHotbarSlot = reader.int32();
          break;
        case /* string dimension */ 12:
          message.dimension = reader.string();
          break;
        case /* int32 experience_level */ 13:
          message.experienceLevel = reader.int32();
          break;
        case /* float experience_progress */ 14:
          message.experienceProgress = reader.float();
          break;
        case /* optional string skin_texture_hash */ 15:
          message.skinTextureHash = reader.string();
          break;
        case /* soulfire.v1.GameMode game_mode */ 16:
          message.gameMode = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotLiveState,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double x = 1; */
    if (message.x !== 0) writer.tag(1, WireType.Bit64).double(message.x);
    /* double y = 2; */
    if (message.y !== 0) writer.tag(2, WireType.Bit64).double(message.y);
    /* double z = 3; */
    if (message.z !== 0) writer.tag(3, WireType.Bit64).double(message.z);
    /* float xRot = 4; */
    if (message.xRot !== 0) writer.tag(4, WireType.Bit32).float(message.xRot);
    /* float yRot = 5; */
    if (message.yRot !== 0) writer.tag(5, WireType.Bit32).float(message.yRot);
    /* float health = 6; */
    if (message.health !== 0)
      writer.tag(6, WireType.Bit32).float(message.health);
    /* float max_health = 7; */
    if (message.maxHealth !== 0)
      writer.tag(7, WireType.Bit32).float(message.maxHealth);
    /* int32 food_level = 8; */
    if (message.foodLevel !== 0)
      writer.tag(8, WireType.Varint).int32(message.foodLevel);
    /* float saturation_level = 9; */
    if (message.saturationLevel !== 0)
      writer.tag(9, WireType.Bit32).float(message.saturationLevel);
    /* repeated soulfire.v1.InventorySlot inventory = 10; */
    for (let i = 0; i < message.inventory.length; i++)
      InventorySlot.internalBinaryWrite(
        message.inventory[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 selected_hotbar_slot = 11; */
    if (message.selectedHotbarSlot !== 0)
      writer.tag(11, WireType.Varint).int32(message.selectedHotbarSlot);
    /* string dimension = 12; */
    if (message.dimension !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.dimension);
    /* int32 experience_level = 13; */
    if (message.experienceLevel !== 0)
      writer.tag(13, WireType.Varint).int32(message.experienceLevel);
    /* float experience_progress = 14; */
    if (message.experienceProgress !== 0)
      writer.tag(14, WireType.Bit32).float(message.experienceProgress);
    /* optional string skin_texture_hash = 15; */
    if (message.skinTextureHash !== undefined)
      writer.tag(15, WireType.LengthDelimited).string(message.skinTextureHash);
    /* soulfire.v1.GameMode game_mode = 16; */
    if (message.gameMode !== 0)
      writer.tag(16, WireType.Varint).int32(message.gameMode);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotLiveState
 */
export const BotLiveState = new BotLiveState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotInfoResponse$Type extends MessageType<BotInfoResponse> {
  constructor() {
    super("soulfire.v1.BotInfoResponse", [
      { no: 2, name: "live_state", kind: "message", T: () => BotLiveState },
    ]);
  }
  create(value?: PartialMessage<BotInfoResponse>): BotInfoResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<BotInfoResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotInfoResponse,
  ): BotInfoResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional soulfire.v1.BotLiveState live_state */ 2:
          message.liveState = BotLiveState.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.liveState,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotInfoResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional soulfire.v1.BotLiveState live_state = 2; */
    if (message.liveState)
      BotLiveState.internalBinaryWrite(
        message.liveState,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotInfoResponse
 */
export const BotInfoResponse = new BotInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotUpdateConfigEntryRequest$Type extends MessageType<BotUpdateConfigEntryRequest> {
  constructor() {
    super("soulfire.v1.BotUpdateConfigEntryRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "value", kind: "message", T: () => Value },
    ]);
  }
  create(
    value?: PartialMessage<BotUpdateConfigEntryRequest>,
  ): BotUpdateConfigEntryRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.namespace = "";
    message.key = "";
    if (value !== undefined)
      reflectionMergePartial<BotUpdateConfigEntryRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotUpdateConfigEntryRequest,
  ): BotUpdateConfigEntryRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* string namespace */ 3:
          message.namespace = reader.string();
          break;
        case /* string key */ 4:
          message.key = reader.string();
          break;
        case /* google.protobuf.Value value */ 5:
          message.value = Value.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.value,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotUpdateConfigEntryRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* string namespace = 3; */
    if (message.namespace !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.namespace);
    /* string key = 4; */
    if (message.key !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.key);
    /* google.protobuf.Value value = 5; */
    if (message.value)
      Value.internalBinaryWrite(
        message.value,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotUpdateConfigEntryRequest
 */
export const BotUpdateConfigEntryRequest =
  new BotUpdateConfigEntryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotUpdateConfigEntryResponse$Type extends MessageType<BotUpdateConfigEntryResponse> {
  constructor() {
    super("soulfire.v1.BotUpdateConfigEntryResponse", []);
  }
  create(
    value?: PartialMessage<BotUpdateConfigEntryResponse>,
  ): BotUpdateConfigEntryResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<BotUpdateConfigEntryResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotUpdateConfigEntryResponse,
  ): BotUpdateConfigEntryResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotUpdateConfigEntryResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotUpdateConfigEntryResponse
 */
export const BotUpdateConfigEntryResponse =
  new BotUpdateConfigEntryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotRenderPovRequest$Type extends MessageType<BotRenderPovRequest> {
  constructor() {
    super("soulfire.v1.BotRenderPovRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<BotRenderPovRequest>): BotRenderPovRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.width = 0;
    message.height = 0;
    if (value !== undefined)
      reflectionMergePartial<BotRenderPovRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotRenderPovRequest,
  ): BotRenderPovRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* int32 width */ 3:
          message.width = reader.int32();
          break;
        case /* int32 height */ 4:
          message.height = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotRenderPovRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* int32 width = 3; */
    if (message.width !== 0)
      writer.tag(3, WireType.Varint).int32(message.width);
    /* int32 height = 4; */
    if (message.height !== 0)
      writer.tag(4, WireType.Varint).int32(message.height);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotRenderPovRequest
 */
export const BotRenderPovRequest = new BotRenderPovRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotRenderPovResponse$Type extends MessageType<BotRenderPovResponse> {
  constructor() {
    super("soulfire.v1.BotRenderPovResponse", [
      {
        no: 1,
        name: "image_base64",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<BotRenderPovResponse>): BotRenderPovResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.imageBase64 = "";
    if (value !== undefined)
      reflectionMergePartial<BotRenderPovResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotRenderPovResponse,
  ): BotRenderPovResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string image_base64 */ 1:
          message.imageBase64 = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotRenderPovResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string image_base64 = 1; */
    if (message.imageBase64 !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.imageBase64);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotRenderPovResponse
 */
export const BotRenderPovResponse = new BotRenderPovResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotInventoryClickRequest$Type extends MessageType<BotInventoryClickRequest> {
  constructor() {
    super("soulfire.v1.BotInventoryClickRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 4,
        name: "click_type",
        kind: "enum",
        T: () => ["soulfire.v1.ClickType", ClickType],
      },
      { no: 5, name: "hotbar_slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotInventoryClickRequest>,
  ): BotInventoryClickRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.slot = 0;
    message.clickType = 0;
    message.hotbarSlot = 0;
    if (value !== undefined)
      reflectionMergePartial<BotInventoryClickRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotInventoryClickRequest,
  ): BotInventoryClickRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* int32 slot */ 3:
          message.slot = reader.int32();
          break;
        case /* soulfire.v1.ClickType click_type */ 4:
          message.clickType = reader.int32();
          break;
        case /* int32 hotbar_slot */ 5:
          message.hotbarSlot = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotInventoryClickRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* int32 slot = 3; */
    if (message.slot !== 0) writer.tag(3, WireType.Varint).int32(message.slot);
    /* soulfire.v1.ClickType click_type = 4; */
    if (message.clickType !== 0)
      writer.tag(4, WireType.Varint).int32(message.clickType);
    /* int32 hotbar_slot = 5; */
    if (message.hotbarSlot !== 0)
      writer.tag(5, WireType.Varint).int32(message.hotbarSlot);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotInventoryClickRequest
 */
export const BotInventoryClickRequest = new BotInventoryClickRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotInventoryClickResponse$Type extends MessageType<BotInventoryClickResponse> {
  constructor() {
    super("soulfire.v1.BotInventoryClickResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotInventoryClickResponse>,
  ): BotInventoryClickResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotInventoryClickResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotInventoryClickResponse,
  ): BotInventoryClickResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotInventoryClickResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotInventoryClickResponse
 */
export const BotInventoryClickResponse = new BotInventoryClickResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotInventoryStateRequest$Type extends MessageType<BotInventoryStateRequest> {
  constructor() {
    super("soulfire.v1.BotInventoryStateRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotInventoryStateRequest>,
  ): BotInventoryStateRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotInventoryStateRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotInventoryStateRequest,
  ): BotInventoryStateRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotInventoryStateRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotInventoryStateRequest
 */
export const BotInventoryStateRequest = new BotInventoryStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlotRegion$Type extends MessageType<SlotRegion> {
  constructor() {
    super("soulfire.v1.SlotRegion", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "start_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "slot_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 5, name: "columns", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 6,
        name: "type",
        kind: "enum",
        T: () => ["soulfire.v1.SlotRegionType", SlotRegionType],
      },
    ]);
  }
  create(value?: PartialMessage<SlotRegion>): SlotRegion {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.label = "";
    message.startIndex = 0;
    message.slotCount = 0;
    message.columns = 0;
    message.type = 0;
    if (value !== undefined)
      reflectionMergePartial<SlotRegion>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SlotRegion,
  ): SlotRegion {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string label */ 2:
          message.label = reader.string();
          break;
        case /* int32 start_index */ 3:
          message.startIndex = reader.int32();
          break;
        case /* int32 slot_count */ 4:
          message.slotCount = reader.int32();
          break;
        case /* int32 columns */ 5:
          message.columns = reader.int32();
          break;
        case /* soulfire.v1.SlotRegionType type */ 6:
          message.type = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SlotRegion,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string label = 2; */
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    /* int32 start_index = 3; */
    if (message.startIndex !== 0)
      writer.tag(3, WireType.Varint).int32(message.startIndex);
    /* int32 slot_count = 4; */
    if (message.slotCount !== 0)
      writer.tag(4, WireType.Varint).int32(message.slotCount);
    /* int32 columns = 5; */
    if (message.columns !== 0)
      writer.tag(5, WireType.Varint).int32(message.columns);
    /* soulfire.v1.SlotRegionType type = 6; */
    if (message.type !== 0) writer.tag(6, WireType.Varint).int32(message.type);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.SlotRegion
 */
export const SlotRegion = new SlotRegion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerButton$Type extends MessageType<ContainerButton> {
  constructor() {
    super("soulfire.v1.ContainerButton", [
      { no: 1, name: "button_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "icon_item_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "description",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 5, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 6, name: "selected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<ContainerButton>): ContainerButton {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.buttonId = 0;
    message.label = "";
    message.disabled = false;
    message.selected = false;
    if (value !== undefined)
      reflectionMergePartial<ContainerButton>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ContainerButton,
  ): ContainerButton {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 button_id */ 1:
          message.buttonId = reader.int32();
          break;
        case /* string label */ 2:
          message.label = reader.string();
          break;
        case /* optional string icon_item_id */ 3:
          message.iconItemId = reader.string();
          break;
        case /* optional string description */ 4:
          message.description = reader.string();
          break;
        case /* bool disabled */ 5:
          message.disabled = reader.bool();
          break;
        case /* bool selected */ 6:
          message.selected = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ContainerButton,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 button_id = 1; */
    if (message.buttonId !== 0)
      writer.tag(1, WireType.Varint).int32(message.buttonId);
    /* string label = 2; */
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    /* optional string icon_item_id = 3; */
    if (message.iconItemId !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.iconItemId);
    /* optional string description = 4; */
    if (message.description !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.description);
    /* bool disabled = 5; */
    if (message.disabled !== false)
      writer.tag(5, WireType.Varint).bool(message.disabled);
    /* bool selected = 6; */
    if (message.selected !== false)
      writer.tag(6, WireType.Varint).bool(message.selected);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ContainerButton
 */
export const ContainerButton = new ContainerButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerTextInput$Type extends MessageType<ContainerTextInput> {
  constructor() {
    super("soulfire.v1.ContainerTextInput", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "current_value",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "max_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 5,
        name: "placeholder",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<ContainerTextInput>): ContainerTextInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.label = "";
    message.currentValue = "";
    message.maxLength = 0;
    message.placeholder = "";
    if (value !== undefined)
      reflectionMergePartial<ContainerTextInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ContainerTextInput,
  ): ContainerTextInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string label */ 2:
          message.label = reader.string();
          break;
        case /* string current_value */ 3:
          message.currentValue = reader.string();
          break;
        case /* int32 max_length */ 4:
          message.maxLength = reader.int32();
          break;
        case /* string placeholder */ 5:
          message.placeholder = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ContainerTextInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string label = 2; */
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    /* string current_value = 3; */
    if (message.currentValue !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.currentValue);
    /* int32 max_length = 4; */
    if (message.maxLength !== 0)
      writer.tag(4, WireType.Varint).int32(message.maxLength);
    /* string placeholder = 5; */
    if (message.placeholder !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.placeholder);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ContainerTextInput
 */
export const ContainerTextInput = new ContainerTextInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BookPage$Type extends MessageType<BookPage> {
  constructor() {
    super("soulfire.v1.BookPage", [
      { no: 1, name: "page_number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "content", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BookPage>): BookPage {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.pageNumber = 0;
    message.content = "";
    if (value !== undefined)
      reflectionMergePartial<BookPage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BookPage,
  ): BookPage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 page_number */ 1:
          message.pageNumber = reader.int32();
          break;
        case /* string content */ 2:
          message.content = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BookPage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 page_number = 1; */
    if (message.pageNumber !== 0)
      writer.tag(1, WireType.Varint).int32(message.pageNumber);
    /* string content = 2; */
    if (message.content !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.content);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BookPage
 */
export const BookPage = new BookPage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ContainerLayout$Type extends MessageType<ContainerLayout> {
  constructor() {
    super("soulfire.v1.ContainerLayout", [
      { no: 1, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "regions",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SlotRegion,
      },
      { no: 3, name: "total_slots", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 4,
        name: "buttons",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ContainerButton,
      },
      {
        no: 5,
        name: "container_type",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "text_inputs",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ContainerTextInput,
      },
      {
        no: 7,
        name: "book_pages",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BookPage,
      },
      {
        no: 8,
        name: "current_book_page",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<ContainerLayout>): ContainerLayout {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.title = "";
    message.regions = [];
    message.totalSlots = 0;
    message.buttons = [];
    message.containerType = "";
    message.textInputs = [];
    message.bookPages = [];
    message.currentBookPage = 0;
    if (value !== undefined)
      reflectionMergePartial<ContainerLayout>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ContainerLayout,
  ): ContainerLayout {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string title */ 1:
          message.title = reader.string();
          break;
        case /* repeated soulfire.v1.SlotRegion regions */ 2:
          message.regions.push(
            SlotRegion.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* int32 total_slots */ 3:
          message.totalSlots = reader.int32();
          break;
        case /* repeated soulfire.v1.ContainerButton buttons */ 4:
          message.buttons.push(
            ContainerButton.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string container_type */ 5:
          message.containerType = reader.string();
          break;
        case /* repeated soulfire.v1.ContainerTextInput text_inputs */ 6:
          message.textInputs.push(
            ContainerTextInput.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated soulfire.v1.BookPage book_pages */ 7:
          message.bookPages.push(
            BookPage.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* int32 current_book_page */ 8:
          message.currentBookPage = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ContainerLayout,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string title = 1; */
    if (message.title !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.title);
    /* repeated soulfire.v1.SlotRegion regions = 2; */
    for (let i = 0; i < message.regions.length; i++)
      SlotRegion.internalBinaryWrite(
        message.regions[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 total_slots = 3; */
    if (message.totalSlots !== 0)
      writer.tag(3, WireType.Varint).int32(message.totalSlots);
    /* repeated soulfire.v1.ContainerButton buttons = 4; */
    for (let i = 0; i < message.buttons.length; i++)
      ContainerButton.internalBinaryWrite(
        message.buttons[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string container_type = 5; */
    if (message.containerType !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.containerType);
    /* repeated soulfire.v1.ContainerTextInput text_inputs = 6; */
    for (let i = 0; i < message.textInputs.length; i++)
      ContainerTextInput.internalBinaryWrite(
        message.textInputs[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.BookPage book_pages = 7; */
    for (let i = 0; i < message.bookPages.length; i++)
      BookPage.internalBinaryWrite(
        message.bookPages[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 current_book_page = 8; */
    if (message.currentBookPage !== 0)
      writer.tag(8, WireType.Varint).int32(message.currentBookPage);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ContainerLayout
 */
export const ContainerLayout = new ContainerLayout$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotInventoryStateResponse$Type extends MessageType<BotInventoryStateResponse> {
  constructor() {
    super("soulfire.v1.BotInventoryStateResponse", [
      { no: 1, name: "layout", kind: "message", T: () => ContainerLayout },
      {
        no: 2,
        name: "slots",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => InventorySlot,
      },
      { no: 3, name: "carried_item", kind: "message", T: () => InventorySlot },
      {
        no: 4,
        name: "selected_hotbar_slot",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotInventoryStateResponse>,
  ): BotInventoryStateResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.slots = [];
    message.selectedHotbarSlot = 0;
    if (value !== undefined)
      reflectionMergePartial<BotInventoryStateResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotInventoryStateResponse,
  ): BotInventoryStateResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.ContainerLayout layout */ 1:
          message.layout = ContainerLayout.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.layout,
          );
          break;
        case /* repeated soulfire.v1.InventorySlot slots */ 2:
          message.slots.push(
            InventorySlot.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* optional soulfire.v1.InventorySlot carried_item */ 3:
          message.carriedItem = InventorySlot.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.carriedItem,
          );
          break;
        case /* int32 selected_hotbar_slot */ 4:
          message.selectedHotbarSlot = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotInventoryStateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.ContainerLayout layout = 1; */
    if (message.layout)
      ContainerLayout.internalBinaryWrite(
        message.layout,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.InventorySlot slots = 2; */
    for (let i = 0; i < message.slots.length; i++)
      InventorySlot.internalBinaryWrite(
        message.slots[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional soulfire.v1.InventorySlot carried_item = 3; */
    if (message.carriedItem)
      InventorySlot.internalBinaryWrite(
        message.carriedItem,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 selected_hotbar_slot = 4; */
    if (message.selectedHotbarSlot !== 0)
      writer.tag(4, WireType.Varint).int32(message.selectedHotbarSlot);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotInventoryStateResponse
 */
export const BotInventoryStateResponse = new BotInventoryStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotCloseContainerRequest$Type extends MessageType<BotCloseContainerRequest> {
  constructor() {
    super("soulfire.v1.BotCloseContainerRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotCloseContainerRequest>,
  ): BotCloseContainerRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotCloseContainerRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotCloseContainerRequest,
  ): BotCloseContainerRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotCloseContainerRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotCloseContainerRequest
 */
export const BotCloseContainerRequest = new BotCloseContainerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotCloseContainerResponse$Type extends MessageType<BotCloseContainerResponse> {
  constructor() {
    super("soulfire.v1.BotCloseContainerResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotCloseContainerResponse>,
  ): BotCloseContainerResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotCloseContainerResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotCloseContainerResponse,
  ): BotCloseContainerResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotCloseContainerResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotCloseContainerResponse
 */
export const BotCloseContainerResponse = new BotCloseContainerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotOpenInventoryRequest$Type extends MessageType<BotOpenInventoryRequest> {
  constructor() {
    super("soulfire.v1.BotOpenInventoryRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotOpenInventoryRequest>,
  ): BotOpenInventoryRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotOpenInventoryRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotOpenInventoryRequest,
  ): BotOpenInventoryRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotOpenInventoryRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotOpenInventoryRequest
 */
export const BotOpenInventoryRequest = new BotOpenInventoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotOpenInventoryResponse$Type extends MessageType<BotOpenInventoryResponse> {
  constructor() {
    super("soulfire.v1.BotOpenInventoryResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotOpenInventoryResponse>,
  ): BotOpenInventoryResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotOpenInventoryResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotOpenInventoryResponse,
  ): BotOpenInventoryResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotOpenInventoryResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotOpenInventoryResponse
 */
export const BotOpenInventoryResponse = new BotOpenInventoryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotMouseClickRequest$Type extends MessageType<BotMouseClickRequest> {
  constructor() {
    super("soulfire.v1.BotMouseClickRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "button",
        kind: "enum",
        T: () => ["soulfire.v1.MouseButton", MouseButton],
      },
    ]);
  }
  create(value?: PartialMessage<BotMouseClickRequest>): BotMouseClickRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.button = 0;
    if (value !== undefined)
      reflectionMergePartial<BotMouseClickRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotMouseClickRequest,
  ): BotMouseClickRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* soulfire.v1.MouseButton button */ 3:
          message.button = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotMouseClickRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* soulfire.v1.MouseButton button = 3; */
    if (message.button !== 0)
      writer.tag(3, WireType.Varint).int32(message.button);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotMouseClickRequest
 */
export const BotMouseClickRequest = new BotMouseClickRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotMouseClickResponse$Type extends MessageType<BotMouseClickResponse> {
  constructor() {
    super("soulfire.v1.BotMouseClickResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<BotMouseClickResponse>): BotMouseClickResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotMouseClickResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotMouseClickResponse,
  ): BotMouseClickResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotMouseClickResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotMouseClickResponse
 */
export const BotMouseClickResponse = new BotMouseClickResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotContainerButtonClickRequest$Type extends MessageType<BotContainerButtonClickRequest> {
  constructor() {
    super("soulfire.v1.BotContainerButtonClickRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "button_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotContainerButtonClickRequest>,
  ): BotContainerButtonClickRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.buttonId = 0;
    if (value !== undefined)
      reflectionMergePartial<BotContainerButtonClickRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotContainerButtonClickRequest,
  ): BotContainerButtonClickRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* int32 button_id */ 3:
          message.buttonId = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotContainerButtonClickRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* int32 button_id = 3; */
    if (message.buttonId !== 0)
      writer.tag(3, WireType.Varint).int32(message.buttonId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotContainerButtonClickRequest
 */
export const BotContainerButtonClickRequest =
  new BotContainerButtonClickRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotContainerButtonClickResponse$Type extends MessageType<BotContainerButtonClickResponse> {
  constructor() {
    super("soulfire.v1.BotContainerButtonClickResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotContainerButtonClickResponse>,
  ): BotContainerButtonClickResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotContainerButtonClickResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotContainerButtonClickResponse,
  ): BotContainerButtonClickResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotContainerButtonClickResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotContainerButtonClickResponse
 */
export const BotContainerButtonClickResponse =
  new BotContainerButtonClickResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetContainerTextRequest$Type extends MessageType<BotSetContainerTextRequest> {
  constructor() {
    super("soulfire.v1.BotSetContainerTextRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "field_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotSetContainerTextRequest>,
  ): BotSetContainerTextRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.fieldId = "";
    message.text = "";
    if (value !== undefined)
      reflectionMergePartial<BotSetContainerTextRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetContainerTextRequest,
  ): BotSetContainerTextRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* string field_id */ 3:
          message.fieldId = reader.string();
          break;
        case /* string text */ 4:
          message.text = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetContainerTextRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* string field_id = 3; */
    if (message.fieldId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.fieldId);
    /* string text = 4; */
    if (message.text !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.text);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetContainerTextRequest
 */
export const BotSetContainerTextRequest = new BotSetContainerTextRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetContainerTextResponse$Type extends MessageType<BotSetContainerTextResponse> {
  constructor() {
    super("soulfire.v1.BotSetContainerTextResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotSetContainerTextResponse>,
  ): BotSetContainerTextResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotSetContainerTextResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetContainerTextResponse,
  ): BotSetContainerTextResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetContainerTextResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetContainerTextResponse
 */
export const BotSetContainerTextResponse =
  new BotSetContainerTextResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetHotbarSlotRequest$Type extends MessageType<BotSetHotbarSlotRequest> {
  constructor() {
    super("soulfire.v1.BotSetHotbarSlotRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotSetHotbarSlotRequest>,
  ): BotSetHotbarSlotRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.slot = 0;
    if (value !== undefined)
      reflectionMergePartial<BotSetHotbarSlotRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetHotbarSlotRequest,
  ): BotSetHotbarSlotRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* int32 slot */ 3:
          message.slot = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetHotbarSlotRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* int32 slot = 3; */
    if (message.slot !== 0) writer.tag(3, WireType.Varint).int32(message.slot);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetHotbarSlotRequest
 */
export const BotSetHotbarSlotRequest = new BotSetHotbarSlotRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetHotbarSlotResponse$Type extends MessageType<BotSetHotbarSlotResponse> {
  constructor() {
    super("soulfire.v1.BotSetHotbarSlotResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotSetHotbarSlotResponse>,
  ): BotSetHotbarSlotResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotSetHotbarSlotResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetHotbarSlotResponse,
  ): BotSetHotbarSlotResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetHotbarSlotResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetHotbarSlotResponse
 */
export const BotSetHotbarSlotResponse = new BotSetHotbarSlotResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetMovementStateRequest$Type extends MessageType<BotSetMovementStateRequest> {
  constructor() {
    super("soulfire.v1.BotSetMovementStateRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "forward",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "backward",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "left",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 6,
        name: "right",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 7,
        name: "jump",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 8,
        name: "sneak",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 9,
        name: "sprint",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotSetMovementStateRequest>,
  ): BotSetMovementStateRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotSetMovementStateRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetMovementStateRequest,
  ): BotSetMovementStateRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* optional bool forward */ 3:
          message.forward = reader.bool();
          break;
        case /* optional bool backward */ 4:
          message.backward = reader.bool();
          break;
        case /* optional bool left */ 5:
          message.left = reader.bool();
          break;
        case /* optional bool right */ 6:
          message.right = reader.bool();
          break;
        case /* optional bool jump */ 7:
          message.jump = reader.bool();
          break;
        case /* optional bool sneak */ 8:
          message.sneak = reader.bool();
          break;
        case /* optional bool sprint */ 9:
          message.sprint = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetMovementStateRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* optional bool forward = 3; */
    if (message.forward !== undefined)
      writer.tag(3, WireType.Varint).bool(message.forward);
    /* optional bool backward = 4; */
    if (message.backward !== undefined)
      writer.tag(4, WireType.Varint).bool(message.backward);
    /* optional bool left = 5; */
    if (message.left !== undefined)
      writer.tag(5, WireType.Varint).bool(message.left);
    /* optional bool right = 6; */
    if (message.right !== undefined)
      writer.tag(6, WireType.Varint).bool(message.right);
    /* optional bool jump = 7; */
    if (message.jump !== undefined)
      writer.tag(7, WireType.Varint).bool(message.jump);
    /* optional bool sneak = 8; */
    if (message.sneak !== undefined)
      writer.tag(8, WireType.Varint).bool(message.sneak);
    /* optional bool sprint = 9; */
    if (message.sprint !== undefined)
      writer.tag(9, WireType.Varint).bool(message.sprint);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetMovementStateRequest
 */
export const BotSetMovementStateRequest = new BotSetMovementStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetMovementStateResponse$Type extends MessageType<BotSetMovementStateResponse> {
  constructor() {
    super("soulfire.v1.BotSetMovementStateResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotSetMovementStateResponse>,
  ): BotSetMovementStateResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotSetMovementStateResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetMovementStateResponse,
  ): BotSetMovementStateResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetMovementStateResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetMovementStateResponse
 */
export const BotSetMovementStateResponse =
  new BotSetMovementStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotResetMovementRequest$Type extends MessageType<BotResetMovementRequest> {
  constructor() {
    super("soulfire.v1.BotResetMovementRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<BotResetMovementRequest>,
  ): BotResetMovementRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotResetMovementRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotResetMovementRequest,
  ): BotResetMovementRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotResetMovementRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotResetMovementRequest
 */
export const BotResetMovementRequest = new BotResetMovementRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotResetMovementResponse$Type extends MessageType<BotResetMovementResponse> {
  constructor() {
    super("soulfire.v1.BotResetMovementResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotResetMovementResponse>,
  ): BotResetMovementResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotResetMovementResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotResetMovementResponse,
  ): BotResetMovementResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotResetMovementResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotResetMovementResponse
 */
export const BotResetMovementResponse = new BotResetMovementResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetRotationRequest$Type extends MessageType<BotSetRotationRequest> {
  constructor() {
    super("soulfire.v1.BotSetRotationRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "yaw", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: "pitch", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
    ]);
  }
  create(value?: PartialMessage<BotSetRotationRequest>): BotSetRotationRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.yaw = 0;
    message.pitch = 0;
    if (value !== undefined)
      reflectionMergePartial<BotSetRotationRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetRotationRequest,
  ): BotSetRotationRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* float yaw */ 3:
          message.yaw = reader.float();
          break;
        case /* float pitch */ 4:
          message.pitch = reader.float();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetRotationRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* float yaw = 3; */
    if (message.yaw !== 0) writer.tag(3, WireType.Bit32).float(message.yaw);
    /* float pitch = 4; */
    if (message.pitch !== 0) writer.tag(4, WireType.Bit32).float(message.pitch);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetRotationRequest
 */
export const BotSetRotationRequest = new BotSetRotationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSetRotationResponse$Type extends MessageType<BotSetRotationResponse> {
  constructor() {
    super("soulfire.v1.BotSetRotationResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotSetRotationResponse>,
  ): BotSetRotationResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotSetRotationResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSetRotationResponse,
  ): BotSetRotationResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSetRotationResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSetRotationResponse
 */
export const BotSetRotationResponse = new BotSetRotationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogBodyElement$Type extends MessageType<DialogBodyElement> {
  constructor() {
    super("soulfire.v1.DialogBodyElement", [
      {
        no: 1,
        name: "plain_message",
        kind: "message",
        oneof: "element",
        T: () => DialogPlainMessage,
      },
      {
        no: 2,
        name: "item",
        kind: "message",
        oneof: "element",
        T: () => DialogItem,
      },
    ]);
  }
  create(value?: PartialMessage<DialogBodyElement>): DialogBodyElement {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.element = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<DialogBodyElement>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogBodyElement,
  ): DialogBodyElement {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.DialogPlainMessage plain_message */ 1:
          message.element = {
            oneofKind: "plainMessage",
            plainMessage: DialogPlainMessage.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.element as any).plainMessage,
            ),
          };
          break;
        case /* soulfire.v1.DialogItem item */ 2:
          message.element = {
            oneofKind: "item",
            item: DialogItem.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.element as any).item,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogBodyElement,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.DialogPlainMessage plain_message = 1; */
    if (message.element.oneofKind === "plainMessage")
      DialogPlainMessage.internalBinaryWrite(
        message.element.plainMessage,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogItem item = 2; */
    if (message.element.oneofKind === "item")
      DialogItem.internalBinaryWrite(
        message.element.item,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogBodyElement
 */
export const DialogBodyElement = new DialogBodyElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogPlainMessage$Type extends MessageType<DialogPlainMessage> {
  constructor() {
    super("soulfire.v1.DialogPlainMessage", [
      { no: 1, name: "contents", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<DialogPlainMessage>): DialogPlainMessage {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.contents = "";
    message.width = 0;
    if (value !== undefined)
      reflectionMergePartial<DialogPlainMessage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogPlainMessage,
  ): DialogPlainMessage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string contents */ 1:
          message.contents = reader.string();
          break;
        case /* int32 width */ 2:
          message.width = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogPlainMessage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string contents = 1; */
    if (message.contents !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contents);
    /* int32 width = 2; */
    if (message.width !== 0)
      writer.tag(2, WireType.Varint).int32(message.width);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogPlainMessage
 */
export const DialogPlainMessage = new DialogPlainMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogItem$Type extends MessageType<DialogItem> {
  constructor() {
    super("soulfire.v1.DialogItem", [
      { no: 1, name: "item_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "show_decoration",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      { no: 5, name: "show_tooltip", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 6, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<DialogItem>): DialogItem {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.itemId = "";
    message.count = 0;
    message.showDecoration = false;
    message.showTooltip = false;
    message.width = 0;
    message.height = 0;
    if (value !== undefined)
      reflectionMergePartial<DialogItem>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogItem,
  ): DialogItem {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string item_id */ 1:
          message.itemId = reader.string();
          break;
        case /* int32 count */ 2:
          message.count = reader.int32();
          break;
        case /* optional string description */ 3:
          message.description = reader.string();
          break;
        case /* bool show_decoration */ 4:
          message.showDecoration = reader.bool();
          break;
        case /* bool show_tooltip */ 5:
          message.showTooltip = reader.bool();
          break;
        case /* int32 width */ 6:
          message.width = reader.int32();
          break;
        case /* int32 height */ 7:
          message.height = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogItem,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string item_id = 1; */
    if (message.itemId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.itemId);
    /* int32 count = 2; */
    if (message.count !== 0)
      writer.tag(2, WireType.Varint).int32(message.count);
    /* optional string description = 3; */
    if (message.description !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    /* bool show_decoration = 4; */
    if (message.showDecoration !== false)
      writer.tag(4, WireType.Varint).bool(message.showDecoration);
    /* bool show_tooltip = 5; */
    if (message.showTooltip !== false)
      writer.tag(5, WireType.Varint).bool(message.showTooltip);
    /* int32 width = 6; */
    if (message.width !== 0)
      writer.tag(6, WireType.Varint).int32(message.width);
    /* int32 height = 7; */
    if (message.height !== 0)
      writer.tag(7, WireType.Varint).int32(message.height);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogItem
 */
export const DialogItem = new DialogItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogInput$Type extends MessageType<DialogInput> {
  constructor() {
    super("soulfire.v1.DialogInput", [
      {
        no: 1,
        name: "text",
        kind: "message",
        oneof: "input",
        T: () => DialogTextInput,
      },
      {
        no: 2,
        name: "boolean",
        kind: "message",
        oneof: "input",
        T: () => DialogBooleanInput,
      },
      {
        no: 3,
        name: "single_option",
        kind: "message",
        oneof: "input",
        T: () => DialogSingleOptionInput,
      },
      {
        no: 4,
        name: "number_range",
        kind: "message",
        oneof: "input",
        T: () => DialogNumberRangeInput,
      },
    ]);
  }
  create(value?: PartialMessage<DialogInput>): DialogInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.input = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<DialogInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogInput,
  ): DialogInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.DialogTextInput text */ 1:
          message.input = {
            oneofKind: "text",
            text: DialogTextInput.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.input as any).text,
            ),
          };
          break;
        case /* soulfire.v1.DialogBooleanInput boolean */ 2:
          message.input = {
            oneofKind: "boolean",
            boolean: DialogBooleanInput.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.input as any).boolean,
            ),
          };
          break;
        case /* soulfire.v1.DialogSingleOptionInput single_option */ 3:
          message.input = {
            oneofKind: "singleOption",
            singleOption: DialogSingleOptionInput.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.input as any).singleOption,
            ),
          };
          break;
        case /* soulfire.v1.DialogNumberRangeInput number_range */ 4:
          message.input = {
            oneofKind: "numberRange",
            numberRange: DialogNumberRangeInput.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.input as any).numberRange,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.DialogTextInput text = 1; */
    if (message.input.oneofKind === "text")
      DialogTextInput.internalBinaryWrite(
        message.input.text,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogBooleanInput boolean = 2; */
    if (message.input.oneofKind === "boolean")
      DialogBooleanInput.internalBinaryWrite(
        message.input.boolean,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogSingleOptionInput single_option = 3; */
    if (message.input.oneofKind === "singleOption")
      DialogSingleOptionInput.internalBinaryWrite(
        message.input.singleOption,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogNumberRangeInput number_range = 4; */
    if (message.input.oneofKind === "numberRange")
      DialogNumberRangeInput.internalBinaryWrite(
        message.input.numberRange,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogInput
 */
export const DialogInput = new DialogInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogTextInput$Type extends MessageType<DialogTextInput> {
  constructor() {
    super("soulfire.v1.DialogTextInput", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 4,
        name: "label_visible",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      { no: 5, name: "initial", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: "max_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: "multiline", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 8,
        name: "multiline_max_lines",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 9,
        name: "multiline_height",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<DialogTextInput>): DialogTextInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    message.label = "";
    message.width = 0;
    message.labelVisible = false;
    message.initial = "";
    message.maxLength = 0;
    message.multiline = false;
    message.multilineMaxLines = 0;
    message.multilineHeight = 0;
    if (value !== undefined)
      reflectionMergePartial<DialogTextInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogTextInput,
  ): DialogTextInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string label */ 2:
          message.label = reader.string();
          break;
        case /* int32 width */ 3:
          message.width = reader.int32();
          break;
        case /* bool label_visible */ 4:
          message.labelVisible = reader.bool();
          break;
        case /* string initial */ 5:
          message.initial = reader.string();
          break;
        case /* int32 max_length */ 6:
          message.maxLength = reader.int32();
          break;
        case /* bool multiline */ 7:
          message.multiline = reader.bool();
          break;
        case /* int32 multiline_max_lines */ 8:
          message.multilineMaxLines = reader.int32();
          break;
        case /* int32 multiline_height */ 9:
          message.multilineHeight = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogTextInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string label = 2; */
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    /* int32 width = 3; */
    if (message.width !== 0)
      writer.tag(3, WireType.Varint).int32(message.width);
    /* bool label_visible = 4; */
    if (message.labelVisible !== false)
      writer.tag(4, WireType.Varint).bool(message.labelVisible);
    /* string initial = 5; */
    if (message.initial !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.initial);
    /* int32 max_length = 6; */
    if (message.maxLength !== 0)
      writer.tag(6, WireType.Varint).int32(message.maxLength);
    /* bool multiline = 7; */
    if (message.multiline !== false)
      writer.tag(7, WireType.Varint).bool(message.multiline);
    /* int32 multiline_max_lines = 8; */
    if (message.multilineMaxLines !== 0)
      writer.tag(8, WireType.Varint).int32(message.multilineMaxLines);
    /* int32 multiline_height = 9; */
    if (message.multilineHeight !== 0)
      writer.tag(9, WireType.Varint).int32(message.multilineHeight);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogTextInput
 */
export const DialogTextInput = new DialogTextInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogBooleanInput$Type extends MessageType<DialogBooleanInput> {
  constructor() {
    super("soulfire.v1.DialogBooleanInput", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "initial", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "on_true", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "on_false", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DialogBooleanInput>): DialogBooleanInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    message.label = "";
    message.initial = false;
    message.onTrue = "";
    message.onFalse = "";
    if (value !== undefined)
      reflectionMergePartial<DialogBooleanInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogBooleanInput,
  ): DialogBooleanInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string label */ 2:
          message.label = reader.string();
          break;
        case /* bool initial */ 3:
          message.initial = reader.bool();
          break;
        case /* string on_true */ 4:
          message.onTrue = reader.string();
          break;
        case /* string on_false */ 5:
          message.onFalse = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogBooleanInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string label = 2; */
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    /* bool initial = 3; */
    if (message.initial !== false)
      writer.tag(3, WireType.Varint).bool(message.initial);
    /* string on_true = 4; */
    if (message.onTrue !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.onTrue);
    /* string on_false = 5; */
    if (message.onFalse !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.onFalse);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogBooleanInput
 */
export const DialogBooleanInput = new DialogBooleanInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogSingleOptionInput$Type extends MessageType<DialogSingleOptionInput> {
  constructor() {
    super("soulfire.v1.DialogSingleOptionInput", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "label_visible",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      { no: 4, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 5,
        name: "options",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => DialogOption,
      },
      {
        no: 6,
        name: "initial_option_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<DialogSingleOptionInput>,
  ): DialogSingleOptionInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    message.label = "";
    message.labelVisible = false;
    message.width = 0;
    message.options = [];
    message.initialOptionId = "";
    if (value !== undefined)
      reflectionMergePartial<DialogSingleOptionInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogSingleOptionInput,
  ): DialogSingleOptionInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string label */ 2:
          message.label = reader.string();
          break;
        case /* bool label_visible */ 3:
          message.labelVisible = reader.bool();
          break;
        case /* int32 width */ 4:
          message.width = reader.int32();
          break;
        case /* repeated soulfire.v1.DialogOption options */ 5:
          message.options.push(
            DialogOption.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string initial_option_id */ 6:
          message.initialOptionId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogSingleOptionInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string label = 2; */
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    /* bool label_visible = 3; */
    if (message.labelVisible !== false)
      writer.tag(3, WireType.Varint).bool(message.labelVisible);
    /* int32 width = 4; */
    if (message.width !== 0)
      writer.tag(4, WireType.Varint).int32(message.width);
    /* repeated soulfire.v1.DialogOption options = 5; */
    for (let i = 0; i < message.options.length; i++)
      DialogOption.internalBinaryWrite(
        message.options[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string initial_option_id = 6; */
    if (message.initialOptionId !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.initialOptionId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogSingleOptionInput
 */
export const DialogSingleOptionInput = new DialogSingleOptionInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogOption$Type extends MessageType<DialogOption> {
  constructor() {
    super("soulfire.v1.DialogOption", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "display", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DialogOption>): DialogOption {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.display = "";
    if (value !== undefined)
      reflectionMergePartial<DialogOption>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogOption,
  ): DialogOption {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string display */ 2:
          message.display = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogOption,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string display = 2; */
    if (message.display !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.display);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogOption
 */
export const DialogOption = new DialogOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogNumberRangeInput$Type extends MessageType<DialogNumberRangeInput> {
  constructor() {
    super("soulfire.v1.DialogNumberRangeInput", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "label_format",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 5, name: "start", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 6, name: "end", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 7, name: "step", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 8, name: "initial", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
    ]);
  }
  create(
    value?: PartialMessage<DialogNumberRangeInput>,
  ): DialogNumberRangeInput {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    message.label = "";
    message.labelFormat = "";
    message.width = 0;
    message.start = 0;
    message.end = 0;
    message.step = 0;
    message.initial = 0;
    if (value !== undefined)
      reflectionMergePartial<DialogNumberRangeInput>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogNumberRangeInput,
  ): DialogNumberRangeInput {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* string label */ 2:
          message.label = reader.string();
          break;
        case /* string label_format */ 3:
          message.labelFormat = reader.string();
          break;
        case /* int32 width */ 4:
          message.width = reader.int32();
          break;
        case /* double start */ 5:
          message.start = reader.double();
          break;
        case /* double end */ 6:
          message.end = reader.double();
          break;
        case /* double step */ 7:
          message.step = reader.double();
          break;
        case /* double initial */ 8:
          message.initial = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogNumberRangeInput,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* string label = 2; */
    if (message.label !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.label);
    /* string label_format = 3; */
    if (message.labelFormat !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.labelFormat);
    /* int32 width = 4; */
    if (message.width !== 0)
      writer.tag(4, WireType.Varint).int32(message.width);
    /* double start = 5; */
    if (message.start !== 0)
      writer.tag(5, WireType.Bit64).double(message.start);
    /* double end = 6; */
    if (message.end !== 0) writer.tag(6, WireType.Bit64).double(message.end);
    /* double step = 7; */
    if (message.step !== 0) writer.tag(7, WireType.Bit64).double(message.step);
    /* double initial = 8; */
    if (message.initial !== 0)
      writer.tag(8, WireType.Bit64).double(message.initial);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogNumberRangeInput
 */
export const DialogNumberRangeInput = new DialogNumberRangeInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogAction$Type extends MessageType<DialogAction> {
  constructor() {
    super("soulfire.v1.DialogAction", [
      {
        no: 1,
        name: "open_url",
        kind: "message",
        oneof: "action",
        T: () => DialogOpenUrlAction,
      },
      {
        no: 2,
        name: "run_command",
        kind: "message",
        oneof: "action",
        T: () => DialogRunCommandAction,
      },
      {
        no: 3,
        name: "suggest_command",
        kind: "message",
        oneof: "action",
        T: () => DialogSuggestCommandAction,
      },
      {
        no: 4,
        name: "copy_to_clipboard",
        kind: "message",
        oneof: "action",
        T: () => DialogCopyToClipboardAction,
      },
      {
        no: 5,
        name: "show_dialog",
        kind: "message",
        oneof: "action",
        T: () => DialogShowDialogAction,
      },
      {
        no: 6,
        name: "custom",
        kind: "message",
        oneof: "action",
        T: () => DialogCustomAction,
      },
      {
        no: 7,
        name: "dynamic_run_command",
        kind: "message",
        oneof: "action",
        T: () => DialogDynamicRunCommandAction,
      },
      {
        no: 8,
        name: "dynamic_custom",
        kind: "message",
        oneof: "action",
        T: () => DialogDynamicCustomAction,
      },
    ]);
  }
  create(value?: PartialMessage<DialogAction>): DialogAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.action = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<DialogAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogAction,
  ): DialogAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.DialogOpenUrlAction open_url */ 1:
          message.action = {
            oneofKind: "openUrl",
            openUrl: DialogOpenUrlAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).openUrl,
            ),
          };
          break;
        case /* soulfire.v1.DialogRunCommandAction run_command */ 2:
          message.action = {
            oneofKind: "runCommand",
            runCommand: DialogRunCommandAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).runCommand,
            ),
          };
          break;
        case /* soulfire.v1.DialogSuggestCommandAction suggest_command */ 3:
          message.action = {
            oneofKind: "suggestCommand",
            suggestCommand: DialogSuggestCommandAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).suggestCommand,
            ),
          };
          break;
        case /* soulfire.v1.DialogCopyToClipboardAction copy_to_clipboard */ 4:
          message.action = {
            oneofKind: "copyToClipboard",
            copyToClipboard: DialogCopyToClipboardAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).copyToClipboard,
            ),
          };
          break;
        case /* soulfire.v1.DialogShowDialogAction show_dialog */ 5:
          message.action = {
            oneofKind: "showDialog",
            showDialog: DialogShowDialogAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).showDialog,
            ),
          };
          break;
        case /* soulfire.v1.DialogCustomAction custom */ 6:
          message.action = {
            oneofKind: "custom",
            custom: DialogCustomAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).custom,
            ),
          };
          break;
        case /* soulfire.v1.DialogDynamicRunCommandAction dynamic_run_command */ 7:
          message.action = {
            oneofKind: "dynamicRunCommand",
            dynamicRunCommand: DialogDynamicRunCommandAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).dynamicRunCommand,
            ),
          };
          break;
        case /* soulfire.v1.DialogDynamicCustomAction dynamic_custom */ 8:
          message.action = {
            oneofKind: "dynamicCustom",
            dynamicCustom: DialogDynamicCustomAction.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.action as any).dynamicCustom,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.DialogOpenUrlAction open_url = 1; */
    if (message.action.oneofKind === "openUrl")
      DialogOpenUrlAction.internalBinaryWrite(
        message.action.openUrl,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogRunCommandAction run_command = 2; */
    if (message.action.oneofKind === "runCommand")
      DialogRunCommandAction.internalBinaryWrite(
        message.action.runCommand,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogSuggestCommandAction suggest_command = 3; */
    if (message.action.oneofKind === "suggestCommand")
      DialogSuggestCommandAction.internalBinaryWrite(
        message.action.suggestCommand,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogCopyToClipboardAction copy_to_clipboard = 4; */
    if (message.action.oneofKind === "copyToClipboard")
      DialogCopyToClipboardAction.internalBinaryWrite(
        message.action.copyToClipboard,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogShowDialogAction show_dialog = 5; */
    if (message.action.oneofKind === "showDialog")
      DialogShowDialogAction.internalBinaryWrite(
        message.action.showDialog,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogCustomAction custom = 6; */
    if (message.action.oneofKind === "custom")
      DialogCustomAction.internalBinaryWrite(
        message.action.custom,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogDynamicRunCommandAction dynamic_run_command = 7; */
    if (message.action.oneofKind === "dynamicRunCommand")
      DialogDynamicRunCommandAction.internalBinaryWrite(
        message.action.dynamicRunCommand,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DialogDynamicCustomAction dynamic_custom = 8; */
    if (message.action.oneofKind === "dynamicCustom")
      DialogDynamicCustomAction.internalBinaryWrite(
        message.action.dynamicCustom,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogAction
 */
export const DialogAction = new DialogAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogOpenUrlAction$Type extends MessageType<DialogOpenUrlAction> {
  constructor() {
    super("soulfire.v1.DialogOpenUrlAction", [
      { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DialogOpenUrlAction>): DialogOpenUrlAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.url = "";
    if (value !== undefined)
      reflectionMergePartial<DialogOpenUrlAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogOpenUrlAction,
  ): DialogOpenUrlAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string url */ 1:
          message.url = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogOpenUrlAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string url = 1; */
    if (message.url !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.url);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogOpenUrlAction
 */
export const DialogOpenUrlAction = new DialogOpenUrlAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogRunCommandAction$Type extends MessageType<DialogRunCommandAction> {
  constructor() {
    super("soulfire.v1.DialogRunCommandAction", [
      { no: 1, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DialogRunCommandAction>,
  ): DialogRunCommandAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.command = "";
    if (value !== undefined)
      reflectionMergePartial<DialogRunCommandAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogRunCommandAction,
  ): DialogRunCommandAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string command */ 1:
          message.command = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogRunCommandAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string command = 1; */
    if (message.command !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.command);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogRunCommandAction
 */
export const DialogRunCommandAction = new DialogRunCommandAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogSuggestCommandAction$Type extends MessageType<DialogSuggestCommandAction> {
  constructor() {
    super("soulfire.v1.DialogSuggestCommandAction", [
      { no: 1, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DialogSuggestCommandAction>,
  ): DialogSuggestCommandAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.command = "";
    if (value !== undefined)
      reflectionMergePartial<DialogSuggestCommandAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogSuggestCommandAction,
  ): DialogSuggestCommandAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string command */ 1:
          message.command = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogSuggestCommandAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string command = 1; */
    if (message.command !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.command);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogSuggestCommandAction
 */
export const DialogSuggestCommandAction = new DialogSuggestCommandAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogCopyToClipboardAction$Type extends MessageType<DialogCopyToClipboardAction> {
  constructor() {
    super("soulfire.v1.DialogCopyToClipboardAction", [
      { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DialogCopyToClipboardAction>,
  ): DialogCopyToClipboardAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.value = "";
    if (value !== undefined)
      reflectionMergePartial<DialogCopyToClipboardAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogCopyToClipboardAction,
  ): DialogCopyToClipboardAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogCopyToClipboardAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.value);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogCopyToClipboardAction
 */
export const DialogCopyToClipboardAction =
  new DialogCopyToClipboardAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogShowDialogAction$Type extends MessageType<DialogShowDialogAction> {
  constructor() {
    super("soulfire.v1.DialogShowDialogAction", [
      { no: 1, name: "dialog_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DialogShowDialogAction>,
  ): DialogShowDialogAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.dialogId = "";
    if (value !== undefined)
      reflectionMergePartial<DialogShowDialogAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogShowDialogAction,
  ): DialogShowDialogAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string dialog_id */ 1:
          message.dialogId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogShowDialogAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string dialog_id = 1; */
    if (message.dialogId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.dialogId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogShowDialogAction
 */
export const DialogShowDialogAction = new DialogShowDialogAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogCustomAction$Type extends MessageType<DialogCustomAction> {
  constructor() {
    super("soulfire.v1.DialogCustomAction", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "payload", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DialogCustomAction>): DialogCustomAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.payload = "";
    if (value !== undefined)
      reflectionMergePartial<DialogCustomAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogCustomAction,
  ): DialogCustomAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string payload */ 2:
          message.payload = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogCustomAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string payload = 2; */
    if (message.payload !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.payload);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogCustomAction
 */
export const DialogCustomAction = new DialogCustomAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogDynamicRunCommandAction$Type extends MessageType<DialogDynamicRunCommandAction> {
  constructor() {
    super("soulfire.v1.DialogDynamicRunCommandAction", [
      { no: 1, name: "template", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DialogDynamicRunCommandAction>,
  ): DialogDynamicRunCommandAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.template = "";
    if (value !== undefined)
      reflectionMergePartial<DialogDynamicRunCommandAction>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogDynamicRunCommandAction,
  ): DialogDynamicRunCommandAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string template */ 1:
          message.template = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogDynamicRunCommandAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string template = 1; */
    if (message.template !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.template);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogDynamicRunCommandAction
 */
export const DialogDynamicRunCommandAction =
  new DialogDynamicRunCommandAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogDynamicCustomAction$Type extends MessageType<DialogDynamicCustomAction> {
  constructor() {
    super("soulfire.v1.DialogDynamicCustomAction", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "additions", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DialogDynamicCustomAction>,
  ): DialogDynamicCustomAction {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.additions = "";
    if (value !== undefined)
      reflectionMergePartial<DialogDynamicCustomAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogDynamicCustomAction,
  ): DialogDynamicCustomAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string additions */ 2:
          message.additions = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogDynamicCustomAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string additions = 2; */
    if (message.additions !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.additions);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogDynamicCustomAction
 */
export const DialogDynamicCustomAction = new DialogDynamicCustomAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DialogButton$Type extends MessageType<DialogButton> {
  constructor() {
    super("soulfire.v1.DialogButton", [
      { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "tooltip",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "action", kind: "message", T: () => DialogAction },
    ]);
  }
  create(value?: PartialMessage<DialogButton>): DialogButton {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.label = "";
    message.width = 0;
    if (value !== undefined)
      reflectionMergePartial<DialogButton>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DialogButton,
  ): DialogButton {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string label */ 1:
          message.label = reader.string();
          break;
        case /* optional string tooltip */ 2:
          message.tooltip = reader.string();
          break;
        case /* int32 width */ 3:
          message.width = reader.int32();
          break;
        case /* optional soulfire.v1.DialogAction action */ 4:
          message.action = DialogAction.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.action,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DialogButton,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string label = 1; */
    if (message.label !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.label);
    /* optional string tooltip = 2; */
    if (message.tooltip !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.tooltip);
    /* int32 width = 3; */
    if (message.width !== 0)
      writer.tag(3, WireType.Varint).int32(message.width);
    /* optional soulfire.v1.DialogAction action = 4; */
    if (message.action)
      DialogAction.internalBinaryWrite(
        message.action,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DialogButton
 */
export const DialogButton = new DialogButton$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerDialog$Type extends MessageType<ServerDialog> {
  constructor() {
    super("soulfire.v1.ServerDialog", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "type",
        kind: "enum",
        T: () => ["soulfire.v1.DialogType", DialogType, "DIALOG_TYPE_"],
      },
      { no: 3, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "external_title",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "body",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => DialogBodyElement,
      },
      {
        no: 6,
        name: "inputs",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => DialogInput,
      },
      {
        no: 7,
        name: "can_close_with_escape",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      { no: 8, name: "pause", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 9,
        name: "after_action",
        kind: "enum",
        T: () => [
          "soulfire.v1.DialogAfterAction",
          DialogAfterAction,
          "DIALOG_AFTER_ACTION_",
        ],
      },
      { no: 10, name: "action", kind: "message", T: () => DialogButton },
      { no: 11, name: "yes", kind: "message", T: () => DialogButton },
      { no: 12, name: "no", kind: "message", T: () => DialogButton },
      {
        no: 13,
        name: "actions",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => DialogButton,
      },
      { no: 14, name: "columns", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 15, name: "exit_action", kind: "message", T: () => DialogButton },
      {
        no: 16,
        name: "button_width",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<ServerDialog>): ServerDialog {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.type = 0;
    message.title = "";
    message.body = [];
    message.inputs = [];
    message.canCloseWithEscape = false;
    message.pause = false;
    message.afterAction = 0;
    message.actions = [];
    message.columns = 0;
    message.buttonWidth = 0;
    if (value !== undefined)
      reflectionMergePartial<ServerDialog>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServerDialog,
  ): ServerDialog {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* soulfire.v1.DialogType type */ 2:
          message.type = reader.int32();
          break;
        case /* string title */ 3:
          message.title = reader.string();
          break;
        case /* optional string external_title */ 4:
          message.externalTitle = reader.string();
          break;
        case /* repeated soulfire.v1.DialogBodyElement body */ 5:
          message.body.push(
            DialogBodyElement.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated soulfire.v1.DialogInput inputs */ 6:
          message.inputs.push(
            DialogInput.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* bool can_close_with_escape */ 7:
          message.canCloseWithEscape = reader.bool();
          break;
        case /* bool pause */ 8:
          message.pause = reader.bool();
          break;
        case /* soulfire.v1.DialogAfterAction after_action */ 9:
          message.afterAction = reader.int32();
          break;
        case /* optional soulfire.v1.DialogButton action */ 10:
          message.action = DialogButton.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.action,
          );
          break;
        case /* optional soulfire.v1.DialogButton yes */ 11:
          message.yes = DialogButton.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.yes,
          );
          break;
        case /* optional soulfire.v1.DialogButton no */ 12:
          message.no = DialogButton.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.no,
          );
          break;
        case /* repeated soulfire.v1.DialogButton actions */ 13:
          message.actions.push(
            DialogButton.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* int32 columns */ 14:
          message.columns = reader.int32();
          break;
        case /* optional soulfire.v1.DialogButton exit_action */ 15:
          message.exitAction = DialogButton.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.exitAction,
          );
          break;
        case /* int32 button_width */ 16:
          message.buttonWidth = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ServerDialog,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* soulfire.v1.DialogType type = 2; */
    if (message.type !== 0) writer.tag(2, WireType.Varint).int32(message.type);
    /* string title = 3; */
    if (message.title !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.title);
    /* optional string external_title = 4; */
    if (message.externalTitle !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.externalTitle);
    /* repeated soulfire.v1.DialogBodyElement body = 5; */
    for (let i = 0; i < message.body.length; i++)
      DialogBodyElement.internalBinaryWrite(
        message.body[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.DialogInput inputs = 6; */
    for (let i = 0; i < message.inputs.length; i++)
      DialogInput.internalBinaryWrite(
        message.inputs[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bool can_close_with_escape = 7; */
    if (message.canCloseWithEscape !== false)
      writer.tag(7, WireType.Varint).bool(message.canCloseWithEscape);
    /* bool pause = 8; */
    if (message.pause !== false)
      writer.tag(8, WireType.Varint).bool(message.pause);
    /* soulfire.v1.DialogAfterAction after_action = 9; */
    if (message.afterAction !== 0)
      writer.tag(9, WireType.Varint).int32(message.afterAction);
    /* optional soulfire.v1.DialogButton action = 10; */
    if (message.action)
      DialogButton.internalBinaryWrite(
        message.action,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional soulfire.v1.DialogButton yes = 11; */
    if (message.yes)
      DialogButton.internalBinaryWrite(
        message.yes,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional soulfire.v1.DialogButton no = 12; */
    if (message.no)
      DialogButton.internalBinaryWrite(
        message.no,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.DialogButton actions = 13; */
    for (let i = 0; i < message.actions.length; i++)
      DialogButton.internalBinaryWrite(
        message.actions[i],
        writer.tag(13, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 columns = 14; */
    if (message.columns !== 0)
      writer.tag(14, WireType.Varint).int32(message.columns);
    /* optional soulfire.v1.DialogButton exit_action = 15; */
    if (message.exitAction)
      DialogButton.internalBinaryWrite(
        message.exitAction,
        writer.tag(15, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int32 button_width = 16; */
    if (message.buttonWidth !== 0)
      writer.tag(16, WireType.Varint).int32(message.buttonWidth);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ServerDialog
 */
export const ServerDialog = new ServerDialog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotGetDialogRequest$Type extends MessageType<BotGetDialogRequest> {
  constructor() {
    super("soulfire.v1.BotGetDialogRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BotGetDialogRequest>): BotGetDialogRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotGetDialogRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotGetDialogRequest,
  ): BotGetDialogRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotGetDialogRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotGetDialogRequest
 */
export const BotGetDialogRequest = new BotGetDialogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotGetDialogResponse$Type extends MessageType<BotGetDialogResponse> {
  constructor() {
    super("soulfire.v1.BotGetDialogResponse", [
      { no: 1, name: "dialog", kind: "message", T: () => ServerDialog },
    ]);
  }
  create(value?: PartialMessage<BotGetDialogResponse>): BotGetDialogResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<BotGetDialogResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotGetDialogResponse,
  ): BotGetDialogResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional soulfire.v1.ServerDialog dialog */ 1:
          message.dialog = ServerDialog.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dialog,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotGetDialogResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional soulfire.v1.ServerDialog dialog = 1; */
    if (message.dialog)
      ServerDialog.internalBinaryWrite(
        message.dialog,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotGetDialogResponse
 */
export const BotGetDialogResponse = new BotGetDialogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSubmitDialogRequest$Type extends MessageType<BotSubmitDialogRequest> {
  constructor() {
    super("soulfire.v1.BotSubmitDialogRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "input_values",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      },
    ]);
  }
  create(
    value?: PartialMessage<BotSubmitDialogRequest>,
  ): BotSubmitDialogRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.inputValues = {};
    if (value !== undefined)
      reflectionMergePartial<BotSubmitDialogRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSubmitDialogRequest,
  ): BotSubmitDialogRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* map<string, string> input_values */ 3:
          this.binaryReadMap3(message.inputValues, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap3(
    map: BotSubmitDialogRequest["inputValues"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof BotSubmitDialogRequest["inputValues"] | undefined,
      val: BotSubmitDialogRequest["inputValues"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.string();
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for soulfire.v1.BotSubmitDialogRequest.input_values",
          );
      }
    }
    map[key ?? ""] = val ?? "";
  }
  internalBinaryWrite(
    message: BotSubmitDialogRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* map<string, string> input_values = 3; */
    for (let k of globalThis.Object.keys(message.inputValues))
      writer
        .tag(3, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.LengthDelimited)
        .string(message.inputValues[k])
        .join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSubmitDialogRequest
 */
export const BotSubmitDialogRequest = new BotSubmitDialogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotSubmitDialogResponse$Type extends MessageType<BotSubmitDialogResponse> {
  constructor() {
    super("soulfire.v1.BotSubmitDialogResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotSubmitDialogResponse>,
  ): BotSubmitDialogResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotSubmitDialogResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotSubmitDialogResponse,
  ): BotSubmitDialogResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotSubmitDialogResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotSubmitDialogResponse
 */
export const BotSubmitDialogResponse = new BotSubmitDialogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotClickDialogButtonRequest$Type extends MessageType<BotClickDialogButtonRequest> {
  constructor() {
    super("soulfire.v1.BotClickDialogButtonRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "button_index",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotClickDialogButtonRequest>,
  ): BotClickDialogButtonRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    message.buttonIndex = 0;
    if (value !== undefined)
      reflectionMergePartial<BotClickDialogButtonRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotClickDialogButtonRequest,
  ): BotClickDialogButtonRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        case /* int32 button_index */ 3:
          message.buttonIndex = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotClickDialogButtonRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    /* int32 button_index = 3; */
    if (message.buttonIndex !== 0)
      writer.tag(3, WireType.Varint).int32(message.buttonIndex);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotClickDialogButtonRequest
 */
export const BotClickDialogButtonRequest =
  new BotClickDialogButtonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotClickDialogButtonResponse$Type extends MessageType<BotClickDialogButtonResponse> {
  constructor() {
    super("soulfire.v1.BotClickDialogButtonResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotClickDialogButtonResponse>,
  ): BotClickDialogButtonResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotClickDialogButtonResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotClickDialogButtonResponse,
  ): BotClickDialogButtonResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotClickDialogButtonResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotClickDialogButtonResponse
 */
export const BotClickDialogButtonResponse =
  new BotClickDialogButtonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotCloseDialogRequest$Type extends MessageType<BotCloseDialogRequest> {
  constructor() {
    super("soulfire.v1.BotCloseDialogRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BotCloseDialogRequest>): BotCloseDialogRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotCloseDialogRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotCloseDialogRequest,
  ): BotCloseDialogRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotCloseDialogRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotCloseDialogRequest
 */
export const BotCloseDialogRequest = new BotCloseDialogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotCloseDialogResponse$Type extends MessageType<BotCloseDialogResponse> {
  constructor() {
    super("soulfire.v1.BotCloseDialogResponse", [
      { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: "error",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<BotCloseDialogResponse>,
  ): BotCloseDialogResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<BotCloseDialogResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotCloseDialogResponse,
  ): BotCloseDialogResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* bool success */ 1:
          message.success = reader.bool();
          break;
        case /* optional string error */ 2:
          message.error = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotCloseDialogResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bool success = 1; */
    if (message.success !== false)
      writer.tag(1, WireType.Varint).bool(message.success);
    /* optional string error = 2; */
    if (message.error !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.error);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotCloseDialogResponse
 */
export const BotCloseDialogResponse = new BotCloseDialogResponse$Type();
/**
 * @generated ServiceType for protobuf service soulfire.v1.BotService
 */
export const BotService = new ServiceType("soulfire.v1.BotService", [
  { name: "GetBotList", options: {}, I: BotListRequest, O: BotListResponse },
  { name: "GetBotInfo", options: {}, I: BotInfoRequest, O: BotInfoResponse },
  {
    name: "UpdateBotConfigEntry",
    options: {},
    I: BotUpdateConfigEntryRequest,
    O: BotUpdateConfigEntryResponse,
  },
  {
    name: "RenderBotPov",
    options: {},
    I: BotRenderPovRequest,
    O: BotRenderPovResponse,
  },
  {
    name: "ClickInventorySlot",
    options: {},
    I: BotInventoryClickRequest,
    O: BotInventoryClickResponse,
  },
  {
    name: "GetInventoryState",
    options: {},
    I: BotInventoryStateRequest,
    O: BotInventoryStateResponse,
  },
  {
    name: "CloseContainer",
    options: {},
    I: BotCloseContainerRequest,
    O: BotCloseContainerResponse,
  },
  {
    name: "OpenInventory",
    options: {},
    I: BotOpenInventoryRequest,
    O: BotOpenInventoryResponse,
  },
  {
    name: "MouseClick",
    options: {},
    I: BotMouseClickRequest,
    O: BotMouseClickResponse,
  },
  {
    name: "ClickContainerButton",
    options: {},
    I: BotContainerButtonClickRequest,
    O: BotContainerButtonClickResponse,
  },
  {
    name: "SetContainerText",
    options: {},
    I: BotSetContainerTextRequest,
    O: BotSetContainerTextResponse,
  },
  {
    name: "SetHotbarSlot",
    options: {},
    I: BotSetHotbarSlotRequest,
    O: BotSetHotbarSlotResponse,
  },
  {
    name: "SetMovementState",
    options: {},
    I: BotSetMovementStateRequest,
    O: BotSetMovementStateResponse,
  },
  {
    name: "ResetMovement",
    options: {},
    I: BotResetMovementRequest,
    O: BotResetMovementResponse,
  },
  {
    name: "SetRotation",
    options: {},
    I: BotSetRotationRequest,
    O: BotSetRotationResponse,
  },
  {
    name: "GetDialog",
    options: {},
    I: BotGetDialogRequest,
    O: BotGetDialogResponse,
  },
  {
    name: "SubmitDialog",
    options: {},
    I: BotSubmitDialogRequest,
    O: BotSubmitDialogResponse,
  },
  {
    name: "ClickDialogButton",
    options: {},
    I: BotClickDialogButtonRequest,
    O: BotClickDialogButtonResponse,
  },
  {
    name: "CloseDialog",
    options: {},
    I: BotCloseDialogRequest,
    O: BotCloseDialogResponse,
  },
]);
