/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,optimize_code_size,eslint_disable,ts_nocheck
// @generated from protobuf file "soulfire/command.proto" (package "soulfire.v1", syntax proto3)
// tslint:disable
// @ts-nocheck

import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from "@protobuf-ts/runtime";
import {
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from "@protobuf-ts/runtime";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
/**
 * Represents an unrestricted global command scope.
 * Commands executed in this scope have access to all instances and bots.
 * Requires the GLOBAL_COMMAND_EXECUTION permission.
 *
 * @generated from protobuf message soulfire.v1.GlobalCommandScope
 */
export interface GlobalCommandScope {}
/**
 * Represents a command scope restricted to a specific instance.
 * Commands executed in this scope can only affect the specified instance and its bots.
 * Requires the INSTANCE_COMMAND_EXECUTION permission for the specified instance.
 *
 * @generated from protobuf message soulfire.v1.InstanceCommandScope
 */
export interface InstanceCommandScope {
  /**
   * The unique identifier (UUID) of the instance to scope commands to.
   * Must be a valid UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
}
/**
 * Represents a command scope restricted to a specific bot within an instance.
 * Commands executed in this scope can only affect the specified bot.
 * Requires the INSTANCE_COMMAND_EXECUTION permission for the parent instance.
 *
 * @generated from protobuf message soulfire.v1.BotCommandScope
 */
export interface BotCommandScope {
  /**
   * The unique identifier (UUID) of the instance containing the bot.
   * Must be a valid UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The unique identifier (UUID) of the bot (profile ID) to scope commands to.
   * Must be a valid UUID string matching the bot's account profile ID.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Defines the execution context for a command, determining which instances
 * and bots the command can affect. The scope also determines required permissions.
 *
 * @generated from protobuf message soulfire.v1.CommandScope
 */
export interface CommandScope {
  /**
   * @generated from protobuf oneof: scope
   */
  scope:
    | {
        oneofKind: "global";
        /**
         * Execute command with global (unrestricted) access to all instances and bots.
         *
         * @generated from protobuf field: soulfire.v1.GlobalCommandScope global = 1
         */
        global: GlobalCommandScope;
      }
    | {
        oneofKind: "instance";
        /**
         * Execute command restricted to a specific instance and its bots.
         *
         * @generated from protobuf field: soulfire.v1.InstanceCommandScope instance = 2
         */
        instance: InstanceCommandScope;
      }
    | {
        oneofKind: "bot";
        /**
         * Execute command restricted to a specific bot within an instance.
         *
         * @generated from protobuf field: soulfire.v1.BotCommandScope bot = 3
         */
        bot: BotCommandScope;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * Request message for executing a server command.
 *
 * @generated from protobuf message soulfire.v1.CommandRequest
 */
export interface CommandRequest {
  /**
   * The execution scope that determines which instances/bots the command can affect
   * and what permissions are required. Must be set to one of the scope options.
   *
   * @generated from protobuf field: soulfire.v1.CommandScope scope = 4
   */
  scope?: CommandScope;
  /**
   * The command string to execute. This follows the Brigadier command format,
   * e.g., "help", "move 100 64 200", "say Hello world".
   * Leading/trailing whitespace will be stripped before execution.
   *
   * @generated from protobuf field: string command = 3
   */
  command: string;
}
/**
 * Response message containing the result of command execution.
 *
 * @generated from protobuf message soulfire.v1.CommandResponse
 */
export interface CommandResponse {
  /**
   * The exit code returned by the command.
   * - 0: Command failed or had no effect (e.g., syntax error, no targets found)
   * - 1 (Command.SINGLE_SUCCESS): Command executed successfully
   * - >1: Command succeeded and affected multiple targets (count of affected items)
   * Note: Syntax errors return 0 and error details are sent via the logging system.
   *
   * @generated from protobuf field: int32 code = 1
   */
  code: number;
}
/**
 * Request message for getting tab-completion suggestions for a partial command.
 *
 * @generated from protobuf message soulfire.v1.CommandCompletionRequest
 */
export interface CommandCompletionRequest {
  /**
   * The execution scope that determines which instances/bots are visible
   * for completion suggestions. Must be set to one of the scope options.
   *
   * @generated from protobuf field: soulfire.v1.CommandScope scope = 5
   */
  scope?: CommandScope;
  /**
   * The partial command string to complete. May be an incomplete command
   * that the user is typing, e.g., "mov" or "move 100 ".
   *
   * @generated from protobuf field: string command = 3
   */
  command: string;
  /**
   * The cursor position within the command string (0-indexed).
   * Completions will be generated for the token at this position.
   * Typically this is the length of the command string for end-of-line completion.
   *
   * @generated from protobuf field: int32 cursor = 4
   */
  cursor: number;
}
/**
 * A single tab-completion suggestion.
 *
 * @generated from protobuf message soulfire.v1.CommandCompletion
 */
export interface CommandCompletion {
  /**
   * The suggested text to insert at the cursor position.
   * This is the actual completion value, not the full command.
   *
   * @generated from protobuf field: string suggestion = 1
   */
  suggestion: string;
  /**
   * Optional tooltip providing additional context about this suggestion.
   * May contain formatted text explaining what the suggestion does.
   * If not present, no tooltip should be displayed.
   *
   * @generated from protobuf field: optional string tooltip = 2
   */
  tooltip?: string;
}
/**
 * Response message containing tab-completion suggestions.
 *
 * @generated from protobuf message soulfire.v1.CommandCompletionResponse
 */
export interface CommandCompletionResponse {
  /**
   * List of completion suggestions for the partial command.
   * May be empty if no completions are available.
   * Suggestions are generated based on the command's Brigadier definition
   * and the current execution scope's visibility.
   *
   * @generated from protobuf field: repeated soulfire.v1.CommandCompletion suggestions = 1
   */
  suggestions: CommandCompletion[];
}
// @generated message type with reflection information, may provide speed optimized methods
class GlobalCommandScope$Type extends MessageType<GlobalCommandScope> {
  constructor() {
    super("soulfire.v1.GlobalCommandScope", []);
  }
  create(value?: PartialMessage<GlobalCommandScope>): GlobalCommandScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<GlobalCommandScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GlobalCommandScope,
  ): GlobalCommandScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GlobalCommandScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GlobalCommandScope
 */
export const GlobalCommandScope = new GlobalCommandScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceCommandScope$Type extends MessageType<InstanceCommandScope> {
  constructor() {
    super("soulfire.v1.InstanceCommandScope", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<InstanceCommandScope>): InstanceCommandScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    if (value !== undefined)
      reflectionMergePartial<InstanceCommandScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: InstanceCommandScope,
  ): InstanceCommandScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: InstanceCommandScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.InstanceCommandScope
 */
export const InstanceCommandScope = new InstanceCommandScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotCommandScope$Type extends MessageType<BotCommandScope> {
  constructor() {
    super("soulfire.v1.BotCommandScope", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BotCommandScope>): BotCommandScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotCommandScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotCommandScope,
  ): BotCommandScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotCommandScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotCommandScope
 */
export const BotCommandScope = new BotCommandScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandScope$Type extends MessageType<CommandScope> {
  constructor() {
    super("soulfire.v1.CommandScope", [
      {
        no: 1,
        name: "global",
        kind: "message",
        oneof: "scope",
        T: () => GlobalCommandScope,
      },
      {
        no: 2,
        name: "instance",
        kind: "message",
        oneof: "scope",
        T: () => InstanceCommandScope,
      },
      {
        no: 3,
        name: "bot",
        kind: "message",
        oneof: "scope",
        T: () => BotCommandScope,
      },
    ]);
  }
  create(value?: PartialMessage<CommandScope>): CommandScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scope = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<CommandScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommandScope,
  ): CommandScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.GlobalCommandScope global */ 1:
          message.scope = {
            oneofKind: "global",
            global: GlobalCommandScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).global,
            ),
          };
          break;
        case /* soulfire.v1.InstanceCommandScope instance */ 2:
          message.scope = {
            oneofKind: "instance",
            instance: InstanceCommandScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).instance,
            ),
          };
          break;
        case /* soulfire.v1.BotCommandScope bot */ 3:
          message.scope = {
            oneofKind: "bot",
            bot: BotCommandScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).bot,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CommandScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.GlobalCommandScope global = 1; */
    if (message.scope.oneofKind === "global")
      GlobalCommandScope.internalBinaryWrite(
        message.scope.global,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.InstanceCommandScope instance = 2; */
    if (message.scope.oneofKind === "instance")
      InstanceCommandScope.internalBinaryWrite(
        message.scope.instance,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.BotCommandScope bot = 3; */
    if (message.scope.oneofKind === "bot")
      BotCommandScope.internalBinaryWrite(
        message.scope.bot,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CommandScope
 */
export const CommandScope = new CommandScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandRequest$Type extends MessageType<CommandRequest> {
  constructor() {
    super("soulfire.v1.CommandRequest", [
      { no: 4, name: "scope", kind: "message", T: () => CommandScope },
      { no: 3, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<CommandRequest>): CommandRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.command = "";
    if (value !== undefined)
      reflectionMergePartial<CommandRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommandRequest,
  ): CommandRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.CommandScope scope */ 4:
          message.scope = CommandScope.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.scope,
          );
          break;
        case /* string command */ 3:
          message.command = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CommandRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string command = 3; */
    if (message.command !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.command);
    /* soulfire.v1.CommandScope scope = 4; */
    if (message.scope)
      CommandScope.internalBinaryWrite(
        message.scope,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CommandRequest
 */
export const CommandRequest = new CommandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandResponse$Type extends MessageType<CommandResponse> {
  constructor() {
    super("soulfire.v1.CommandResponse", [
      { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<CommandResponse>): CommandResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.code = 0;
    if (value !== undefined)
      reflectionMergePartial<CommandResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommandResponse,
  ): CommandResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 code */ 1:
          message.code = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CommandResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 code = 1; */
    if (message.code !== 0) writer.tag(1, WireType.Varint).int32(message.code);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CommandResponse
 */
export const CommandResponse = new CommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCompletionRequest$Type extends MessageType<CommandCompletionRequest> {
  constructor() {
    super("soulfire.v1.CommandCompletionRequest", [
      { no: 5, name: "scope", kind: "message", T: () => CommandScope },
      { no: 3, name: "command", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "cursor", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(
    value?: PartialMessage<CommandCompletionRequest>,
  ): CommandCompletionRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.command = "";
    message.cursor = 0;
    if (value !== undefined)
      reflectionMergePartial<CommandCompletionRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommandCompletionRequest,
  ): CommandCompletionRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.CommandScope scope */ 5:
          message.scope = CommandScope.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.scope,
          );
          break;
        case /* string command */ 3:
          message.command = reader.string();
          break;
        case /* int32 cursor */ 4:
          message.cursor = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CommandCompletionRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string command = 3; */
    if (message.command !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.command);
    /* int32 cursor = 4; */
    if (message.cursor !== 0)
      writer.tag(4, WireType.Varint).int32(message.cursor);
    /* soulfire.v1.CommandScope scope = 5; */
    if (message.scope)
      CommandScope.internalBinaryWrite(
        message.scope,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CommandCompletionRequest
 */
export const CommandCompletionRequest = new CommandCompletionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCompletion$Type extends MessageType<CommandCompletion> {
  constructor() {
    super("soulfire.v1.CommandCompletion", [
      { no: 1, name: "suggestion", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "tooltip",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<CommandCompletion>): CommandCompletion {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.suggestion = "";
    if (value !== undefined)
      reflectionMergePartial<CommandCompletion>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommandCompletion,
  ): CommandCompletion {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string suggestion */ 1:
          message.suggestion = reader.string();
          break;
        case /* optional string tooltip */ 2:
          message.tooltip = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CommandCompletion,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string suggestion = 1; */
    if (message.suggestion !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.suggestion);
    /* optional string tooltip = 2; */
    if (message.tooltip !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.tooltip);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CommandCompletion
 */
export const CommandCompletion = new CommandCompletion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommandCompletionResponse$Type extends MessageType<CommandCompletionResponse> {
  constructor() {
    super("soulfire.v1.CommandCompletionResponse", [
      {
        no: 1,
        name: "suggestions",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CommandCompletion,
      },
    ]);
  }
  create(
    value?: PartialMessage<CommandCompletionResponse>,
  ): CommandCompletionResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.suggestions = [];
    if (value !== undefined)
      reflectionMergePartial<CommandCompletionResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommandCompletionResponse,
  ): CommandCompletionResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.CommandCompletion suggestions */ 1:
          message.suggestions.push(
            CommandCompletion.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CommandCompletionResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.CommandCompletion suggestions = 1; */
    for (let i = 0; i < message.suggestions.length; i++)
      CommandCompletion.internalBinaryWrite(
        message.suggestions[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CommandCompletionResponse
 */
export const CommandCompletionResponse = new CommandCompletionResponse$Type();
/**
 * @generated ServiceType for protobuf service soulfire.v1.CommandService
 */
export const CommandService = new ServiceType("soulfire.v1.CommandService", [
  {
    name: "ExecuteCommand",
    options: {},
    I: CommandRequest,
    O: CommandResponse,
  },
  {
    name: "TabCompleteCommand",
    options: {},
    I: CommandCompletionRequest,
    O: CommandCompletionResponse,
  },
]);
