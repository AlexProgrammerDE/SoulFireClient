/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,optimize_code_size,eslint_disable,ts_nocheck
// @generated from protobuf file "soulfire/common.proto" (package "soulfire.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from "@protobuf-ts/runtime";
import {
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from "@protobuf-ts/runtime";
import { Struct, Value } from "../google/protobuf/struct";
/**
 * Represents a network proxy configuration used for routing bot connections.
 * Proxies can be used to mask the origin of bot traffic or to distribute connections
 * across multiple IP addresses. Used in instance configuration and proxy checking services.
 *
 * @generated from protobuf message soulfire.v1.ProxyProto
 */
export interface ProxyProto {
  /**
   * The proxy protocol type. Determines how the connection is established.
   *
   * @generated from protobuf field: soulfire.v1.ProxyProto.Type type = 1
   */
  type: ProxyProto_Type;
  /**
   * The proxy server address in "host:port" format (e.g., "proxy.example.com:8080").
   * The address must be resolvable and the port must be valid (1-65535).
   *
   * @generated from protobuf field: string address = 2
   */
  address: string;
  /**
   * Optional username for proxy authentication.
   * Required if the proxy server requires authentication.
   * If password is set, username must also be set.
   *
   * @generated from protobuf field: optional string username = 3
   */
  username?: string;
  /**
   * Optional password for proxy authentication.
   * Used with username for SOCKS5 or HTTP proxy authentication.
   * Not supported for SOCKS4 proxies (will cause an error if set).
   *
   * @generated from protobuf field: optional string password = 4
   */
  password?: string;
}
/**
 * The type of proxy protocol to use for the connection.
 *
 * @generated from protobuf enum soulfire.v1.ProxyProto.Type
 */
export enum ProxyProto_Type {
  /**
   * HTTP/HTTPS proxy using the CONNECT method.
   * Does not support UDP traffic. Suitable for basic HTTP tunneling.
   *
   * @generated from protobuf enum value: HTTP = 0;
   */
  HTTP = 0,
  /**
   * SOCKS4 proxy protocol.
   * Does not support UDP traffic or authentication passwords (username only via IDENT).
   * Note: If a password is provided for SOCKS4, it will be rejected.
   *
   * @generated from protobuf enum value: SOCKS4 = 1;
   */
  SOCKS4 = 1,
  /**
   * SOCKS5 proxy protocol.
   * Supports both TCP and UDP traffic, as well as full username/password authentication.
   * Recommended for most use cases due to its flexibility.
   *
   * @generated from protobuf enum value: SOCKS5 = 2;
   */
  SOCKS5 = 2,
}
/**
 * Represents an authenticated Minecraft account that can be used by bots.
 * This can be a premium Microsoft account (Java or Bedrock) or an offline account.
 * The account contains authentication data, profile information, and per-account settings.
 * Used throughout the system for instance configuration and bot management.
 *
 * @generated from protobuf message soulfire.v1.MinecraftAccountProto
 */
export interface MinecraftAccountProto {
  /**
   * The authentication type used for this account.
   * Determines which account_data field is populated.
   *
   * @generated from protobuf field: soulfire.v1.MinecraftAccountProto.AccountTypeProto type = 1
   */
  type: MinecraftAccountProto_AccountTypeProto;
  /**
   * The unique profile identifier (UUID) for this account.
   * For online accounts: The official Minecraft profile UUID from Microsoft.
   * For offline accounts: A deterministic UUID derived from the username.
   * Format: Standard UUID string (e.g., "550e8400-e29b-41d4-a716-446655440000").
   *
   * @generated from protobuf field: string profile_id = 2
   */
  profileId: string;
  /**
   * The last known username/gamertag for this account.
   * Updated during authentication and refresh operations.
   * For Java: The Minecraft username (up to 16 characters).
   * For Bedrock: The Xbox gamertag.
   *
   * @generated from protobuf field: string last_known_name = 3
   */
  lastKnownName: string;
  /**
   * The platform-specific authentication data.
   * Exactly one of these fields will be set based on the account type.
   *
   * @generated from protobuf oneof: account_data
   */
  accountData:
    | {
        oneofKind: "onlineChainJavaData";
        /**
         * Authentication chain for online Java accounts (Microsoft-authenticated).
         *
         * @generated from protobuf field: soulfire.v1.MinecraftAccountProto.OnlineChainJavaData online_chain_java_data = 5
         */
        onlineChainJavaData: MinecraftAccountProto_OnlineChainJavaData;
      }
    | {
        oneofKind: "offlineJavaData";
        /**
         * Data for offline Java accounts (no authentication required).
         *
         * @generated from protobuf field: soulfire.v1.MinecraftAccountProto.OfflineJavaData offline_java_data = 6
         */
        offlineJavaData: MinecraftAccountProto_OfflineJavaData;
      }
    | {
        oneofKind: "bedrockData";
        /**
         * Authentication chain for Bedrock accounts (Microsoft-authenticated).
         *
         * @generated from protobuf field: soulfire.v1.MinecraftAccountProto.BedrockData bedrock_data = 7
         */
        bedrockData: MinecraftAccountProto_BedrockData;
      }
    | {
        oneofKind: undefined;
      };
  /**
   * Per-bot configuration settings stored with the account.
   * Organized as namespace -> key -> value mappings.
   * These settings override instance-level settings when the bot is running.
   * Typically includes bot-specific behavior settings.
   *
   * @generated from protobuf field: repeated soulfire.v1.SettingsNamespace config = 8
   */
  config: SettingsNamespace[];
  /**
   * Persistent metadata stored with the account across sessions.
   * Organized as namespace -> key -> value mappings.
   * Used by plugins and the system to store account-specific state
   * that should persist across bot restarts (e.g., last position, inventory cache).
   *
   * @generated from protobuf field: repeated soulfire.v1.SettingsNamespace persistent_metadata = 9
   */
  persistentMetadata: SettingsNamespace[];
}
/**
 * Authentication chain data for online Java Edition accounts.
 * Contains OAuth tokens, Minecraft profile data, and Xbox Live authentication details.
 * Used for Microsoft-authenticated Java accounts to maintain session state.
 *
 * @generated from protobuf message soulfire.v1.MinecraftAccountProto.OnlineChainJavaData
 */
export interface MinecraftAccountProto_OnlineChainJavaData {
  /**
   * JSON structure containing the complete authentication chain from minecraftauth library.
   * Includes Microsoft OAuth tokens, Xbox Live tokens, and Minecraft access tokens.
   * This data can be refreshed to obtain new tokens without re-authentication.
   *
   * @generated from protobuf field: google.protobuf.Struct auth_chain = 3
   */
  authChain?: Struct;
}
/**
 * Account data for offline mode Java accounts.
 * Contains no authentication data since offline accounts don't require Microsoft auth.
 * The profile UUID is derived deterministically from the username.
 *
 * Empty message - offline accounts have no persistent auth data.
 * UUID is calculated as: UUID.nameUUIDFromBytes("OfflinePlayer:<username>")
 *
 * @generated from protobuf message soulfire.v1.MinecraftAccountProto.OfflineJavaData
 */
export interface MinecraftAccountProto_OfflineJavaData {}
/**
 * Authentication chain data for Bedrock Edition accounts.
 * Contains Xbox Live and Bedrock-specific authentication details.
 * Used for Microsoft-authenticated Bedrock accounts.
 *
 * @generated from protobuf message soulfire.v1.MinecraftAccountProto.BedrockData
 */
export interface MinecraftAccountProto_BedrockData {
  /**
   * JSON structure containing the complete Bedrock authentication chain.
   * Includes Xbox Live tokens and Bedrock-specific session data.
   * Compatible with the ViaBedrock protocol implementation.
   *
   * @generated from protobuf field: google.protobuf.Struct auth_chain = 7
   */
  authChain?: Struct;
}
/**
 * The type of authentication that was used to create this account.
 * Determines which account_data oneof field is populated and how the account
 * can be refreshed or re-authenticated.
 *
 * @generated from protobuf enum soulfire.v1.MinecraftAccountProto.AccountTypeProto
 */
export enum MinecraftAccountProto_AccountTypeProto {
  /**
   * Authenticated via Microsoft Java credentials (email/password).
   * Account data stored in OnlineChainJavaData.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_CREDENTIALS = 0;
   */
  MICROSOFT_JAVA_CREDENTIALS = 0,
  /**
   * Authenticated via Microsoft Bedrock credentials (email/password).
   * Account data stored in BedrockData.
   *
   * @generated from protobuf enum value: MICROSOFT_BEDROCK_CREDENTIALS = 1;
   */
  MICROSOFT_BEDROCK_CREDENTIALS = 1,
  /**
   * Offline mode account (no Microsoft authentication).
   * Account data stored in OfflineJavaData.
   * UUID is derived from username, cannot join online-mode servers.
   *
   * @generated from protobuf enum value: OFFLINE = 4;
   */
  OFFLINE = 4,
  /**
   * Authenticated via Microsoft Java device code flow.
   * Account data stored in OnlineChainJavaData.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_DEVICE_CODE = 5;
   */
  MICROSOFT_JAVA_DEVICE_CODE = 5,
  /**
   * Authenticated via Microsoft Bedrock device code flow.
   * Account data stored in BedrockData.
   *
   * @generated from protobuf enum value: MICROSOFT_BEDROCK_DEVICE_CODE = 6;
   */
  MICROSOFT_BEDROCK_DEVICE_CODE = 6,
  /**
   * Authenticated via Microsoft Java refresh token.
   * Account data stored in OnlineChainJavaData.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_REFRESH_TOKEN = 7;
   */
  MICROSOFT_JAVA_REFRESH_TOKEN = 7,
  /**
   * Authenticated via raw Minecraft access token.
   * Account data stored in OnlineChainJavaData.
   * Cannot be refreshed.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_ACCESS_TOKEN = 8;
   */
  MICROSOFT_JAVA_ACCESS_TOKEN = 8,
}
/**
 * A collection of settings entries grouped under a common namespace.
 * Used to organize configuration values hierarchically, where each namespace
 * represents a logical grouping (e.g., plugin name, feature area).
 * Part of the instance configuration, server configuration, and account settings.
 *
 * @generated from protobuf message soulfire.v1.SettingsNamespace
 */
export interface SettingsNamespace {
  /**
   * The namespace identifier that groups related settings together.
   * Typically matches a plugin ID or internal system component name.
   * Examples: "bot", "account", "auto-reconnect", "anti-afk".
   *
   * @generated from protobuf field: string namespace = 1
   */
  namespace: string;
  /**
   * The list of setting entries within this namespace.
   * Each entry has a unique key within the namespace.
   *
   * @generated from protobuf field: repeated soulfire.v1.SettingsNamespace.SettingsEntry entries = 2
   */
  entries: SettingsNamespace_SettingsEntry[];
}
/**
 * A single key-value setting entry within a namespace.
 *
 * @generated from protobuf message soulfire.v1.SettingsNamespace.SettingsEntry
 */
export interface SettingsNamespace_SettingsEntry {
  /**
   * The unique key identifying this setting within its namespace.
   * Should be a valid identifier (alphanumeric with underscores/dashes).
   *
   * @generated from protobuf field: string key = 1
   */
  key: string;
  /**
   * The value of this setting as a protobuf Value.
   * Can be a string, number, boolean, list, or nested object.
   * The expected type depends on the setting definition (see SettingsDefinition).
   *
   * @generated from protobuf field: google.protobuf.Value value = 2
   */
  value?: Value;
}
/**
 * Uniquely identifies a single setting entry by its namespace and key.
 * Used to reference settings in page definitions and for granular updates.
 * The combination of namespace + key must be unique within a configuration scope.
 *
 * @generated from protobuf message soulfire.v1.SettingsEntryIdentifier
 */
export interface SettingsEntryIdentifier {
  /**
   * The namespace containing this setting.
   * Must match a namespace from a registered SettingsNamespace.
   *
   * @generated from protobuf field: string namespace = 1
   */
  namespace: string;
  /**
   * The key of the setting within its namespace.
   * Must match a key from a SettingsEntry in the corresponding namespace.
   *
   * @generated from protobuf field: string key = 2
   */
  key: string;
}
/**
 * UI definition for a string/text setting.
 * Used to render text input fields in the client UI with appropriate validation
 * and visual styling based on the input type.
 *
 * @generated from protobuf message soulfire.v1.StringSetting
 */
export interface StringSetting {
  /**
   * The display name shown in the UI label for this setting.
   *
   * @generated from protobuf field: string ui_name = 1
   */
  uiName: string;
  /**
   * A longer description explaining what this setting does.
   * Typically shown as a tooltip or help text.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * The default value used when no value is configured.
   *
   * @generated from protobuf field: string def = 3
   */
  def: string;
  /**
   * The type of input field to render (affects keyboard, validation, and display).
   *
   * @generated from protobuf field: soulfire.v1.StringSetting.InputType input_type = 10
   */
  inputType: StringSetting_InputType;
  /**
   * Placeholder text shown when the input is empty.
   * Provides a hint about expected format or content.
   *
   * @generated from protobuf field: string placeholder = 6
   */
  placeholder: string;
  /**
   * Minimum required string length (0 means no minimum).
   *
   * @generated from protobuf field: int32 min_length = 7
   */
  minLength: number;
  /**
   * Maximum allowed string length (0 means no maximum).
   *
   * @generated from protobuf field: int32 max_length = 8
   */
  maxLength: number;
  /**
   * Regular expression pattern for value validation.
   * Empty string means no pattern validation.
   *
   * @generated from protobuf field: string pattern = 9
   */
  pattern: string;
  /**
   * Whether this setting is disabled (read-only) in the UI.
   * Disabled settings display their value but cannot be modified.
   *
   * @generated from protobuf field: bool disabled = 11
   */
  disabled: boolean;
}
/**
 * The type of text input to render in the UI.
 * Maps to HTML input types for appropriate keyboard and validation behavior.
 *
 * @generated from protobuf enum soulfire.v1.StringSetting.InputType
 */
export enum StringSetting_InputType {
  /**
   * Standard single-line text input.
   *
   * @generated from protobuf enum value: TEXT = 0;
   */
  TEXT = 0,
  /**
   * Password input with masked characters.
   * Value is hidden in the UI for security.
   *
   * @generated from protobuf enum value: PASSWORD = 1;
   */
  PASSWORD = 1,
  /**
   * Email address input with email validation.
   *
   * @generated from protobuf enum value: EMAIL = 2;
   */
  EMAIL = 2,
  /**
   * Search input, typically with a search icon and clear button.
   *
   * @generated from protobuf enum value: SEARCH = 3;
   */
  SEARCH = 3,
  /**
   * Telephone number input with numeric keyboard on mobile.
   *
   * @generated from protobuf enum value: TEL = 4;
   */
  TEL = 4,
  /**
   * URL input with URL validation.
   *
   * @generated from protobuf enum value: URL = 5;
   */
  URL = 5,
  /**
   * Multi-line text area for longer text content.
   *
   * @generated from protobuf enum value: TEXTAREA = 6;
   */
  TEXTAREA = 6,
}
/**
 * UI definition for an integer number setting.
 * Used to render numeric input fields with validation constraints.
 * Supports range limits, step increments, and locale-aware formatting.
 *
 * @generated from protobuf message soulfire.v1.IntSetting
 */
export interface IntSetting {
  /**
   * The display name shown in the UI label for this setting.
   *
   * @generated from protobuf field: string ui_name = 1
   */
  uiName: string;
  /**
   * A longer description explaining what this setting does.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * The default value used when no value is configured.
   *
   * @generated from protobuf field: int32 def = 3
   */
  def: number;
  /**
   * The minimum allowed value (inclusive).
   *
   * @generated from protobuf field: int32 min = 4
   */
  min: number;
  /**
   * The maximum allowed value (inclusive).
   *
   * @generated from protobuf field: int32 max = 5
   */
  max: number;
  /**
   * The step increment for value adjustments (e.g., for spinbox controls).
   * A value of 0 means any integer is valid within the min/max range.
   *
   * @generated from protobuf field: int32 step = 6
   */
  step: number;
  /**
   * Placeholder text shown when the input is empty.
   *
   * @generated from protobuf field: string placeholder = 7
   */
  placeholder: string;
  /**
   * Whether to display the number with thousand separators (e.g., 1,000,000).
   * Improves readability for large numbers.
   *
   * @generated from protobuf field: bool thousand_separator = 8
   */
  thousandSeparator: boolean;
  /**
   * Whether this setting is disabled (read-only) in the UI.
   *
   * @generated from protobuf field: bool disabled = 9
   */
  disabled: boolean;
}
/**
 * UI definition for a floating-point number setting.
 * Used to render decimal number input fields with precision control.
 * Supports range limits, step increments, and decimal formatting options.
 *
 * @generated from protobuf message soulfire.v1.DoubleSetting
 */
export interface DoubleSetting {
  /**
   * The display name shown in the UI label for this setting.
   *
   * @generated from protobuf field: string ui_name = 1
   */
  uiName: string;
  /**
   * A longer description explaining what this setting does.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * The default value used when no value is configured.
   *
   * @generated from protobuf field: double def = 3
   */
  def: number;
  /**
   * The minimum allowed value (inclusive).
   *
   * @generated from protobuf field: double min = 4
   */
  min: number;
  /**
   * The maximum allowed value (inclusive).
   *
   * @generated from protobuf field: double max = 5
   */
  max: number;
  /**
   * The step increment for value adjustments.
   * A value of 0 means any decimal is valid within the min/max range.
   *
   * @generated from protobuf field: double step = 6
   */
  step: number;
  /**
   * Placeholder text shown when the input is empty.
   *
   * @generated from protobuf field: string placeholder = 7
   */
  placeholder: string;
  /**
   * Whether to display the integer part with thousand separators.
   *
   * @generated from protobuf field: bool thousand_separator = 8
   */
  thousandSeparator: boolean;
  /**
   * The number of decimal places to display/allow.
   * Used for formatting and input validation.
   *
   * @generated from protobuf field: int32 decimal_scale = 9
   */
  decimalScale: number;
  /**
   * Whether to always show the exact number of decimal places specified by decimal_scale.
   * If true, trailing zeros are preserved (e.g., 1.50 instead of 1.5).
   *
   * @generated from protobuf field: bool fixed_decimal_scale = 10
   */
  fixedDecimalScale: boolean;
  /**
   * Whether this setting is disabled (read-only) in the UI.
   *
   * @generated from protobuf field: bool disabled = 11
   */
  disabled: boolean;
}
/**
 * UI definition for a boolean toggle setting.
 * Used to render checkbox or toggle switch controls in the UI.
 * Commonly used for enabling/disabling features.
 *
 * @generated from protobuf message soulfire.v1.BoolSetting
 */
export interface BoolSetting {
  /**
   * The display name shown in the UI label for this setting.
   *
   * @generated from protobuf field: string ui_name = 1
   */
  uiName: string;
  /**
   * A longer description explaining what this setting does.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * The default value used when no value is configured.
   *
   * @generated from protobuf field: bool def = 3
   */
  def: boolean;
  /**
   * Whether this setting is disabled (read-only) in the UI.
   *
   * @generated from protobuf field: bool disabled = 4
   */
  disabled: boolean;
}
/**
 * UI definition for a dropdown/select setting with predefined options.
 * Used to render combo boxes or dropdown menus where users select from a fixed list.
 * Each option has an ID (stored value) and a display name (shown to user).
 *
 * @generated from protobuf message soulfire.v1.ComboSetting
 */
export interface ComboSetting {
  /**
   * The display name shown in the UI label for this setting.
   *
   * @generated from protobuf field: string ui_name = 1
   */
  uiName: string;
  /**
   * A longer description explaining what this setting does.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * The list of available options to choose from.
   * The order determines display order in the dropdown.
   *
   * @generated from protobuf field: repeated soulfire.v1.ComboSetting.Option options = 3
   */
  options: ComboSetting_Option[];
  /**
   * The default option ID used when no value is configured.
   * Must match one of the option IDs in the options list.
   *
   * @generated from protobuf field: string def = 4
   */
  def: string;
  /**
   * Whether this setting is disabled (read-only) in the UI.
   *
   * @generated from protobuf field: bool disabled = 5
   */
  disabled: boolean;
}
/**
 * A single selectable option in the combo box.
 *
 * @generated from protobuf message soulfire.v1.ComboSetting.Option
 */
export interface ComboSetting_Option {
  /**
   * The internal identifier for this option.
   * This value is stored in the configuration when selected.
   * Typically a machine-readable string (e.g., enum name, UUID).
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * The human-readable name displayed to the user.
   * Can include spaces and special characters for readability.
   *
   * @generated from protobuf field: string display_name = 2
   */
  displayName: string;
  /**
   * Optional icon identifier to display next to the option.
   * Uses lucide.dev icon IDs (e.g., "user", "settings", "shield").
   *
   * @generated from protobuf field: optional string icon_id = 3
   */
  iconId?: string;
  /**
   * Additional keywords for filtering/searching options.
   * Allows finding this option by typing related terms.
   *
   * @generated from protobuf field: repeated string keywords = 4
   */
  keywords: string[];
}
/**
 * UI definition for a list of strings setting.
 * Used to render a multi-value input where users can add/remove string items.
 * Commonly used for lists of allowed values, server addresses, or tags.
 *
 * @generated from protobuf message soulfire.v1.StringListSetting
 */
export interface StringListSetting {
  /**
   * The display name shown in the UI label for this setting.
   *
   * @generated from protobuf field: string ui_name = 1
   */
  uiName: string;
  /**
   * A longer description explaining what this setting does.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * The default list of values used when no value is configured.
   * Can be empty for an initially empty list.
   *
   * @generated from protobuf field: repeated string def = 3
   */
  def: string[];
  /**
   * Whether this setting is disabled (read-only) in the UI.
   *
   * @generated from protobuf field: bool disabled = 4
   */
  disabled: boolean;
}
/**
 * UI definition for a min/max range setting with two integer values.
 * Used to render paired input fields for specifying a numeric range.
 * Commonly used for delay ranges, count ranges, or any min/max pair.
 * Values are stored as a JSON object with "min" and "max" properties.
 *
 * @generated from protobuf message soulfire.v1.MinMaxSetting
 */
export interface MinMaxSetting {
  /**
   * The minimum allowed value for both entries (inclusive).
   * Both min and max entries must be >= this value.
   *
   * @generated from protobuf field: int32 min = 1
   */
  min: number;
  /**
   * The maximum allowed value for both entries (inclusive).
   * Both min and max entries must be <= this value.
   *
   * @generated from protobuf field: int32 max = 2
   */
  max: number;
  /**
   * The step increment for value adjustments.
   *
   * @generated from protobuf field: int32 step = 3
   */
  step: number;
  /**
   * Whether to display numbers with thousand separators.
   *
   * @generated from protobuf field: bool thousand_separator = 4
   */
  thousandSeparator: boolean;
  /**
   * Configuration for the minimum value input field.
   * The actual value must be <= maxEntry value.
   *
   * @generated from protobuf field: soulfire.v1.MinMaxSetting.Entry minEntry = 5
   */
  minEntry?: MinMaxSetting_Entry;
  /**
   * Configuration for the maximum value input field.
   * The actual value must be >= minEntry value.
   *
   * @generated from protobuf field: soulfire.v1.MinMaxSetting.Entry maxEntry = 6
   */
  maxEntry?: MinMaxSetting_Entry;
  /**
   * Whether this setting is disabled (read-only) in the UI.
   *
   * @generated from protobuf field: bool disabled = 7
   */
  disabled: boolean;
}
/**
 * Configuration for a single entry in the min/max pair.
 *
 * @generated from protobuf message soulfire.v1.MinMaxSetting.Entry
 */
export interface MinMaxSetting_Entry {
  /**
   * The display name for this entry (e.g., "Minimum Delay").
   *
   * @generated from protobuf field: string ui_name = 1
   */
  uiName: string;
  /**
   * A description explaining what this entry represents.
   *
   * @generated from protobuf field: string description = 2
   */
  description: string;
  /**
   * The default value for this entry.
   *
   * @generated from protobuf field: int32 def = 3
   */
  def: number;
  /**
   * Placeholder text shown when the input is empty.
   *
   * @generated from protobuf field: string placeholder = 4
   */
  placeholder: string;
}
/**
 * A complete setting definition that describes a single configurable value.
 * Contains all information needed for a client to render the setting UI,
 * validate input, and store/retrieve values by identifier.
 * Definitions are exported from the server and referenced by SettingsPage.
 *
 * @generated from protobuf message soulfire.v1.SettingsDefinition
 */
export interface SettingsDefinition {
  /**
   * Unique identifier for this setting (namespace + key).
   * Used to reference this setting from pages and to store/retrieve values.
   *
   * @generated from protobuf field: soulfire.v1.SettingsEntryIdentifier id = 1
   */
  id?: SettingsEntryIdentifier;
  /**
   * The configuration scope where this setting applies (SERVER, INSTANCE, BOT).
   * Determines where values are stored and how they cascade.
   *
   * @generated from protobuf field: soulfire.v1.SettingsPageEntryScopeType scope = 2
   */
  scope: SettingsPageEntryScopeType;
  /**
   * The setting type and its UI configuration.
   * Exactly one of these fields will be set based on the setting's data type.
   *
   * @generated from protobuf oneof: type
   */
  type:
    | {
        oneofKind: "string";
        /**
         * String/text setting with optional validation.
         *
         * @generated from protobuf field: soulfire.v1.StringSetting string = 3
         */
        string: StringSetting;
      }
    | {
        oneofKind: "int";
        /**
         * Integer number setting with range constraints.
         *
         * @generated from protobuf field: soulfire.v1.IntSetting int = 4
         */
        int: IntSetting;
      }
    | {
        oneofKind: "double";
        /**
         * Floating-point number setting with precision control.
         *
         * @generated from protobuf field: soulfire.v1.DoubleSetting double = 5
         */
        double: DoubleSetting;
      }
    | {
        oneofKind: "bool";
        /**
         * Boolean toggle setting.
         *
         * @generated from protobuf field: soulfire.v1.BoolSetting bool = 6
         */
        bool: BoolSetting;
      }
    | {
        oneofKind: "combo";
        /**
         * Dropdown/select setting with predefined options.
         *
         * @generated from protobuf field: soulfire.v1.ComboSetting combo = 7
         */
        combo: ComboSetting;
      }
    | {
        oneofKind: "stringList";
        /**
         * List of strings setting for multi-value input.
         *
         * @generated from protobuf field: soulfire.v1.StringListSetting string_list = 8
         */
        stringList: StringListSetting;
      }
    | {
        oneofKind: "minMax";
        /**
         * Min/max range setting with two paired integer values.
         *
         * @generated from protobuf field: soulfire.v1.MinMaxSetting min_max = 9
         */
        minMax: MinMaxSetting;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * A settings page that groups related settings together for UI navigation.
 * Pages provide a logical organization of settings with visual elements like
 * icons and names. Each page references settings by their identifiers rather
 * than embedding the definitions, allowing settings to be shared across pages.
 *
 * @generated from protobuf message soulfire.v1.SettingsPage
 */
export interface SettingsPage {
  /**
   * Unique page identifier, URL-safe for navigation.
   * Examples: "bot", "account", "auto-reconnect", "anti-afk".
   * Should be lowercase with hyphens for word separation.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * The ID of the plugin that owns this page (optional).
   * Null/empty for internal SoulFire pages.
   * Used to group pages by plugin in the UI navigation.
   *
   * @generated from protobuf field: optional string owning_plugin_id = 2
   */
  owningPluginId?: string;
  /**
   * The human-readable display name shown in the UI navigation.
   * Examples: "Bot Settings", "Account", "Auto Reconnect".
   *
   * @generated from protobuf field: string page_name = 3
   */
  pageName: string;
  /**
   * Ordered list of setting identifiers to display on this page.
   * Settings are rendered in the order they appear in this list.
   * Each identifier must correspond to a valid SettingsDefinition.
   *
   * @generated from protobuf field: repeated soulfire.v1.SettingsEntryIdentifier entries = 5
   */
  entries: SettingsEntryIdentifier[];
  /**
   * Icon identifier for visual representation of this page.
   * Uses lucide.dev icon IDs (e.g., "bot", "user", "refresh-cw").
   * Rendered next to the page name in navigation menus.
   *
   * @generated from protobuf field: string icon_id = 6
   */
  iconId: string;
  /**
   * Optional identifier for a boolean setting that controls whether
   * this page/feature is enabled. Used primarily for plugin pages.
   * When set, the page may show an enable/disable toggle.
   *
   * @generated from protobuf field: optional soulfire.v1.SettingsEntryIdentifier enabled_identifier = 7
   */
  enabledIdentifier?: SettingsEntryIdentifier;
}
/**
 * Metadata about a registered server plugin.
 * Plugins extend SoulFire functionality by adding new settings, commands,
 * and bot behaviors. This information is displayed in the client UI.
 * Returned as part of InstanceInfo and ServerInfoResponse.
 *
 * @generated from protobuf message soulfire.v1.ServerPlugin
 */
export interface ServerPlugin {
  /**
   * The unique plugin identifier.
   * Should be a lowercase, hyphenated string (e.g., "auto-reconnect", "chat-control").
   * Used to reference the plugin in owning_plugin_id fields.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * The semantic version of the plugin (e.g., "1.0.0", "2.1.3-beta").
   * Follows semver conventions for compatibility tracking.
   *
   * @generated from protobuf field: string version = 2
   */
  version: string;
  /**
   * A brief description of what the plugin does.
   * Shown in plugin lists and information panels.
   *
   * @generated from protobuf field: string description = 3
   */
  description: string;
  /**
   * The author or organization that created the plugin.
   * Typically a name or organization identifier.
   *
   * @generated from protobuf field: string author = 4
   */
  author: string;
  /**
   * The software license under which the plugin is distributed.
   * Examples: "MIT", "Apache-2.0", "GPL-3.0".
   *
   * @generated from protobuf field: string license = 5
   */
  license: string;
  /**
   * URL to the plugin's website, documentation, or repository.
   * Allows users to find more information or report issues.
   *
   * @generated from protobuf field: string website = 6
   */
  website: string;
}
/**
 * Authentication service types that accept direct credentials (email/password or username).
 * Used in the MCAuthService.LoginCredentials RPC to specify which authentication
 * method should be used for batch account authentication.
 *
 * @generated from protobuf enum soulfire.v1.AccountTypeCredentials
 */
export enum AccountTypeCredentials {
  /**
   * Microsoft Java Edition authentication using email and password.
   * Authenticates against Microsoft's OAuth system to obtain a Minecraft Java profile.
   * Payload format: ["email", "password"] pairs, one pair per account.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_CREDENTIALS = 0;
   */
  MICROSOFT_JAVA_CREDENTIALS = 0,
  /**
   * Microsoft Bedrock Edition authentication using email and password.
   * Authenticates against Microsoft's OAuth system to obtain a Minecraft Bedrock profile.
   * Payload format: ["email", "password"] pairs, one pair per account.
   *
   * @generated from protobuf enum value: MICROSOFT_BEDROCK_CREDENTIALS = 1;
   */
  MICROSOFT_BEDROCK_CREDENTIALS = 1,
  /**
   * Offline mode authentication (no Microsoft account required).
   * Creates a local-only account with a generated UUID based on the username.
   * Payload format: ["username"] for each account.
   * Note: Offline accounts cannot join online-mode servers.
   *
   * @generated from protobuf enum value: OFFLINE = 4;
   */
  OFFLINE = 4,
  /**
   * Microsoft Java Edition authentication using an existing refresh token.
   * Useful for re-authenticating accounts without requiring credentials again.
   * Payload format: ["refresh_token"] for each account.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_REFRESH_TOKEN = 5;
   */
  MICROSOFT_JAVA_REFRESH_TOKEN = 5,
  /**
   * Microsoft Java Edition authentication using a raw Minecraft access token.
   * Useful for importing accounts from other launchers or tools.
   * Payload format: ["access_token"] for each account.
   * Note: Access token accounts cannot be refreshed.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_ACCESS_TOKEN = 6;
   */
  MICROSOFT_JAVA_ACCESS_TOKEN = 6,
  /**
   * Microsoft Java Edition authentication using browser cookies for login.live.com.
   * The server exchanges cookies for an OAuth refresh token, then authenticates normally.
   * Payload format: a cookie jar / Cookie header / cookie export for each account.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_COOKIES = 7;
   */
  MICROSOFT_JAVA_COOKIES = 7,
}
/**
 * Authentication service types that use the OAuth 2.0 Device Code flow.
 * Used in the MCAuthService.LoginDeviceCode RPC for interactive authentication
 * where the user must visit a URL and enter a code on another device.
 *
 * @generated from protobuf enum soulfire.v1.AccountTypeDeviceCode
 */
export enum AccountTypeDeviceCode {
  /**
   * Microsoft Java Edition authentication via device code flow.
   * Returns a device code that the user enters at microsoft.com/link.
   * Produces an OnlineChainJavaData authentication chain upon success.
   *
   * @generated from protobuf enum value: MICROSOFT_JAVA_DEVICE_CODE = 0;
   */
  MICROSOFT_JAVA_DEVICE_CODE = 0,
  /**
   * Microsoft Bedrock Edition authentication via device code flow.
   * Returns a device code that the user enters at microsoft.com/link.
   * Produces a BedrockData authentication chain upon success.
   *
   * @generated from protobuf enum value: MICROSOFT_BEDROCK_DEVICE_CODE = 1;
   */
  MICROSOFT_BEDROCK_DEVICE_CODE = 1,
}
/**
 * Server-wide permissions that apply globally across all instances.
 * These permissions control access to server administration, user management,
 * and self-service operations. Checked via the PermissionContext.global() method.
 * ADMIN role users have all global permissions by default.
 *
 * @generated from protobuf enum soulfire.v1.GlobalPermission
 */
export enum GlobalPermission {
  /**
   * Permission to create new SoulFire instances.
   * Required by InstanceService.CreateInstance RPC.
   *
   * @generated from protobuf enum value: CREATE_INSTANCE = 0;
   */
  CREATE_INSTANCE = 0,
  /**
   * Permission to subscribe to server-wide log streams.
   * Allows receiving logs from all instances and system components.
   *
   * @generated from protobuf enum value: GLOBAL_SUBSCRIBE_LOGS = 1;
   */
  GLOBAL_SUBSCRIBE_LOGS = 1,
  /**
   * Permission to read the authenticated user's own client data.
   * Required by ClientService.GetClientData RPC.
   * Returns user profile, permissions, and server information.
   *
   * @generated from protobuf enum value: READ_CLIENT_DATA = 2;
   */
  READ_CLIENT_DATA = 2,
  /**
   * Permission to read the server configuration.
   * Required by ServerService.GetServerInfo RPC.
   *
   * @generated from protobuf enum value: READ_SERVER_CONFIG = 3;
   */
  READ_SERVER_CONFIG = 3,
  /**
   * Permission to modify the server configuration.
   * Required by ServerService.UpdateServerConfig and UpdateServerConfigEntry RPCs.
   *
   * @generated from protobuf enum value: UPDATE_SERVER_CONFIG = 4;
   */
  UPDATE_SERVER_CONFIG = 4,
  /**
   * Permission to create new user accounts.
   * Required by UserService.CreateUser RPC.
   *
   * @generated from protobuf enum value: CREATE_USER = 5;
   */
  CREATE_USER = 5,
  /**
   * Permission to read information about other users.
   * Required by UserService.ListUsers and GetUserInfo RPCs.
   *
   * @generated from protobuf enum value: READ_USER = 6;
   */
  READ_USER = 6,
  /**
   * Permission to modify other users' accounts.
   * Required by UserService.UpdateUser RPC.
   *
   * @generated from protobuf enum value: UPDATE_USER = 7;
   */
  UPDATE_USER = 7,
  /**
   * Permission to delete user accounts.
   * Required by UserService.DeleteUser RPC.
   *
   * @generated from protobuf enum value: DELETE_USER = 8;
   */
  DELETE_USER = 8,
  /**
   * Permission to execute commands at the global/server level.
   * Required by CommandService for server-wide command execution.
   *
   * @generated from protobuf enum value: GLOBAL_COMMAND_EXECUTION = 9;
   */
  GLOBAL_COMMAND_EXECUTION = 9,
  /**
   * Permission to invalidate sessions for other users.
   * Required by UserService.InvalidateSessions RPC.
   * Forces other users to re-authenticate.
   *
   * @generated from protobuf enum value: INVALIDATE_SESSIONS = 11;
   */
  INVALIDATE_SESSIONS = 11,
  /**
   * Permission to generate a WebDAV authentication token for oneself.
   * Required by ClientService.GenerateWebDAVToken RPC.
   * WebDAV tokens provide file system access to instance data.
   *
   * @generated from protobuf enum value: GENERATE_SELF_WEBDAV_TOKEN = 12;
   */
  GENERATE_SELF_WEBDAV_TOKEN = 12,
  /**
   * Permission to generate an API token for oneself.
   * Required by ClientService.GenerateAPIToken RPC.
   * API tokens can be used for programmatic access.
   *
   * @generated from protobuf enum value: GENERATE_SELF_API_TOKEN = 15;
   */
  GENERATE_SELF_API_TOKEN = 15,
  /**
   * Permission to update one's own username.
   * Required by ClientService.UpdateSelfUsername RPC.
   *
   * @generated from protobuf enum value: UPDATE_SELF_USERNAME = 13;
   */
  UPDATE_SELF_USERNAME = 13,
  /**
   * Permission to update one's own email address.
   * Required by ClientService.UpdateSelfEmail RPC.
   *
   * @generated from protobuf enum value: UPDATE_SELF_EMAIL = 14;
   */
  UPDATE_SELF_EMAIL = 14,
  /**
   * Permission to generate API tokens for other users.
   * Required by UserService.GenerateUserAPIToken RPC.
   *
   * @generated from protobuf enum value: GENERATE_API_TOKEN = 16;
   */
  GENERATE_API_TOKEN = 16,
  /**
   * Permission to invalidate one's own sessions.
   * Required by ClientService.InvalidateSelfSessions RPC.
   * Logs the user out of all devices.
   *
   * @generated from protobuf enum value: INVALIDATE_SELF_SESSIONS = 17;
   */
  INVALIDATE_SELF_SESSIONS = 17,
}
/**
 * Permissions that apply to a specific instance.
 * These permissions are scoped to individual instances and control what operations
 * a user can perform on that instance. Checked via PermissionContext.instance() method.
 * Permission grants are stored per-user per-instance in the database.
 *
 * @generated from protobuf enum soulfire.v1.InstancePermission
 */
export enum InstancePermission {
  /**
   * Permission to execute commands within this instance.
   * Required by CommandService for instance-level command execution.
   *
   * @generated from protobuf enum value: INSTANCE_COMMAND_EXECUTION = 0;
   */
  INSTANCE_COMMAND_EXECUTION = 0,
  /**
   * Permission to read instance information and configuration.
   * Required by InstanceService.GetInstanceInfo RPC.
   * Also required to see the instance in InstanceService.ListInstances.
   *
   * @generated from protobuf enum value: READ_INSTANCE = 2;
   */
  READ_INSTANCE = 2,
  /**
   * Permission to update instance metadata (friendly name, icon).
   * Required by InstanceService.UpdateInstanceMeta RPC.
   *
   * @generated from protobuf enum value: UPDATE_INSTANCE_META = 3;
   */
  UPDATE_INSTANCE_META = 3,
  /**
   * Permission to update instance configuration (settings, accounts, proxies).
   * Required by InstanceService.UpdateInstanceConfig, UpdateInstanceConfigEntry,
   * and all account/proxy add/remove/update RPCs.
   *
   * @generated from protobuf enum value: UPDATE_INSTANCE_CONFIG = 14;
   */
  UPDATE_INSTANCE_CONFIG = 14,
  /**
   * Permission to delete this instance entirely.
   * Required by InstanceService.DeleteInstance RPC.
   * This is a destructive operation that cannot be undone.
   *
   * @generated from protobuf enum value: DELETE_INSTANCE = 4;
   */
  DELETE_INSTANCE = 4,
  /**
   * Permission to change the instance state (start, stop, pause, resume).
   * Required by InstanceService.ChangeInstanceState RPC.
   * Controls the bot session lifecycle.
   *
   * @generated from protobuf enum value: CHANGE_INSTANCE_STATE = 5;
   */
  CHANGE_INSTANCE_STATE = 5,
  /**
   * Permission to authenticate Minecraft accounts for this instance.
   * Required by MCAuthService RPCs (LoginCredentials, LoginDeviceCode, Refresh).
   * Allows adding new accounts or refreshing existing account tokens.
   *
   * @generated from protobuf enum value: AUTHENTICATE_MC_ACCOUNT = 6;
   */
  AUTHENTICATE_MC_ACCOUNT = 6,
  /**
   * Permission to check proxy connectivity and latency for this instance.
   * Required by ProxyCheckService.Check RPC.
   *
   * @generated from protobuf enum value: CHECK_PROXY = 7;
   */
  CHECK_PROXY = 7,
  /**
   * Permission to download files from URLs through the server.
   * Required by DownloadService.Download RPC.
   * Used for fetching remote resources through instance proxies.
   *
   * @generated from protobuf enum value: DOWNLOAD_URL = 8;
   */
  DOWNLOAD_URL = 8,
  /**
   * Permission to access WebDAV object storage for this instance.
   * Required to read/write files in the instance's storage area via WebDAV.
   *
   * @generated from protobuf enum value: ACCESS_OBJECT_STORAGE = 9;
   */
  ACCESS_OBJECT_STORAGE = 9,
  /**
   * Permission to subscribe to log streams for this instance.
   * Required by LogService for instance-specific log streaming.
   *
   * @generated from protobuf enum value: INSTANCE_SUBSCRIBE_LOGS = 13;
   */
  INSTANCE_SUBSCRIBE_LOGS = 13,
  /**
   * Permission to read the audit log for this instance.
   * Required by InstanceService.GetAuditLog RPC.
   * Shows command executions and state changes with user attribution.
   *
   * @generated from protobuf enum value: READ_INSTANCE_AUDIT_LOGS = 15;
   */
  READ_INSTANCE_AUDIT_LOGS = 15,
  /**
   * Permission to read information about individual bots in this instance.
   * Required by BotService RPCs for reading bot state and live data.
   * Also required by InstanceService.GetAccountMetadata RPC.
   *
   * @generated from protobuf enum value: READ_BOT_INFO = 10;
   */
  READ_BOT_INFO = 10,
  /**
   * Permission to update configuration for individual bots.
   * Required by BotService RPCs for modifying bot settings.
   * Also required for SetAccountMetadataEntry and DeleteAccountMetadataEntry.
   *
   * @generated from protobuf enum value: UPDATE_BOT_CONFIG = 11;
   */
  UPDATE_BOT_CONFIG = 11,
}
/**
 * The role assigned to a user account, determining their base permission level.
 * Roles provide a coarse-grained permission model that is supplemented by
 * specific permission grants at the global and instance levels.
 *
 * @generated from protobuf enum soulfire.v1.UserRole
 */
export enum UserRole {
  /**
   * Administrator role with full access to all features.
   * ADMIN users implicitly have all GlobalPermission and InstancePermission values granted.
   * Only ADMIN users can manage other users and server configuration by default.
   *
   * @generated from protobuf enum value: ADMIN = 0;
   */
  ADMIN = 0,
  /**
   * Standard user role with limited default permissions.
   * USER role accounts require explicit permission grants for most operations.
   * Default permissions for USER role are controlled by server configuration.
   *
   * @generated from protobuf enum value: USER = 1;
   */
  USER = 1,
}
/**
 * The scope/level at which a setting applies.
 * Determines where the setting value is stored and when it takes effect.
 * Used in SettingsDefinition to indicate the setting's configuration scope.
 *
 * @generated from protobuf enum soulfire.v1.SettingsPageEntryScopeType
 */
export enum SettingsPageEntryScopeType {
  /**
   * Server-level setting that applies globally to the entire SoulFire server.
   * Stored in the server configuration (ServerConfig).
   * Affects all instances and users on the server.
   *
   * @generated from protobuf enum value: SERVER = 0;
   */
  SERVER = 0,
  /**
   * Instance-level setting that applies to a specific instance.
   * Stored in the instance configuration (InstanceConfig.settings).
   * Affects all bots within that instance.
   *
   * @generated from protobuf enum value: INSTANCE = 1;
   */
  INSTANCE = 1,
  /**
   * Bot-level setting that applies to individual bot accounts.
   * Stored per-account in MinecraftAccountProto.config.
   * Overrides instance settings for that specific bot.
   *
   * @generated from protobuf enum value: BOT = 2;
   */
  BOT = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class ProxyProto$Type extends MessageType<ProxyProto> {
  constructor() {
    super("soulfire.v1.ProxyProto", [
      {
        no: 1,
        name: "type",
        kind: "enum",
        T: () => ["soulfire.v1.ProxyProto.Type", ProxyProto_Type],
      },
      { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "username",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "password",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<ProxyProto>): ProxyProto {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type = 0;
    message.address = "";
    if (value !== undefined)
      reflectionMergePartial<ProxyProto>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ProxyProto,
  ): ProxyProto {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.ProxyProto.Type type */ 1:
          message.type = reader.int32();
          break;
        case /* string address */ 2:
          message.address = reader.string();
          break;
        case /* optional string username */ 3:
          message.username = reader.string();
          break;
        case /* optional string password */ 4:
          message.password = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ProxyProto,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.ProxyProto.Type type = 1; */
    if (message.type !== 0) writer.tag(1, WireType.Varint).int32(message.type);
    /* string address = 2; */
    if (message.address !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.address);
    /* optional string username = 3; */
    if (message.username !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.username);
    /* optional string password = 4; */
    if (message.password !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.password);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ProxyProto
 */
export const ProxyProto = new ProxyProto$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinecraftAccountProto$Type extends MessageType<MinecraftAccountProto> {
  constructor() {
    super("soulfire.v1.MinecraftAccountProto", [
      {
        no: 1,
        name: "type",
        kind: "enum",
        T: () => [
          "soulfire.v1.MinecraftAccountProto.AccountTypeProto",
          MinecraftAccountProto_AccountTypeProto,
        ],
      },
      { no: 2, name: "profile_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "last_known_name",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "online_chain_java_data",
        kind: "message",
        oneof: "accountData",
        T: () => MinecraftAccountProto_OnlineChainJavaData,
      },
      {
        no: 6,
        name: "offline_java_data",
        kind: "message",
        oneof: "accountData",
        T: () => MinecraftAccountProto_OfflineJavaData,
      },
      {
        no: 7,
        name: "bedrock_data",
        kind: "message",
        oneof: "accountData",
        T: () => MinecraftAccountProto_BedrockData,
      },
      {
        no: 8,
        name: "config",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SettingsNamespace,
      },
      {
        no: 9,
        name: "persistent_metadata",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SettingsNamespace,
      },
    ]);
  }
  create(value?: PartialMessage<MinecraftAccountProto>): MinecraftAccountProto {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type = 0;
    message.profileId = "";
    message.lastKnownName = "";
    message.accountData = { oneofKind: undefined };
    message.config = [];
    message.persistentMetadata = [];
    if (value !== undefined)
      reflectionMergePartial<MinecraftAccountProto>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MinecraftAccountProto,
  ): MinecraftAccountProto {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.MinecraftAccountProto.AccountTypeProto type */ 1:
          message.type = reader.int32();
          break;
        case /* string profile_id */ 2:
          message.profileId = reader.string();
          break;
        case /* string last_known_name */ 3:
          message.lastKnownName = reader.string();
          break;
        case /* soulfire.v1.MinecraftAccountProto.OnlineChainJavaData online_chain_java_data */ 5:
          message.accountData = {
            oneofKind: "onlineChainJavaData",
            onlineChainJavaData:
              MinecraftAccountProto_OnlineChainJavaData.internalBinaryRead(
                reader,
                reader.uint32(),
                options,
                (message.accountData as any).onlineChainJavaData,
              ),
          };
          break;
        case /* soulfire.v1.MinecraftAccountProto.OfflineJavaData offline_java_data */ 6:
          message.accountData = {
            oneofKind: "offlineJavaData",
            offlineJavaData:
              MinecraftAccountProto_OfflineJavaData.internalBinaryRead(
                reader,
                reader.uint32(),
                options,
                (message.accountData as any).offlineJavaData,
              ),
          };
          break;
        case /* soulfire.v1.MinecraftAccountProto.BedrockData bedrock_data */ 7:
          message.accountData = {
            oneofKind: "bedrockData",
            bedrockData: MinecraftAccountProto_BedrockData.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.accountData as any).bedrockData,
            ),
          };
          break;
        case /* repeated soulfire.v1.SettingsNamespace config */ 8:
          message.config.push(
            SettingsNamespace.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated soulfire.v1.SettingsNamespace persistent_metadata */ 9:
          message.persistentMetadata.push(
            SettingsNamespace.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MinecraftAccountProto,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.MinecraftAccountProto.AccountTypeProto type = 1; */
    if (message.type !== 0) writer.tag(1, WireType.Varint).int32(message.type);
    /* string profile_id = 2; */
    if (message.profileId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.profileId);
    /* string last_known_name = 3; */
    if (message.lastKnownName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.lastKnownName);
    /* soulfire.v1.MinecraftAccountProto.OnlineChainJavaData online_chain_java_data = 5; */
    if (message.accountData.oneofKind === "onlineChainJavaData")
      MinecraftAccountProto_OnlineChainJavaData.internalBinaryWrite(
        message.accountData.onlineChainJavaData,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.MinecraftAccountProto.OfflineJavaData offline_java_data = 6; */
    if (message.accountData.oneofKind === "offlineJavaData")
      MinecraftAccountProto_OfflineJavaData.internalBinaryWrite(
        message.accountData.offlineJavaData,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.MinecraftAccountProto.BedrockData bedrock_data = 7; */
    if (message.accountData.oneofKind === "bedrockData")
      MinecraftAccountProto_BedrockData.internalBinaryWrite(
        message.accountData.bedrockData,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.SettingsNamespace config = 8; */
    for (let i = 0; i < message.config.length; i++)
      SettingsNamespace.internalBinaryWrite(
        message.config[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.SettingsNamespace persistent_metadata = 9; */
    for (let i = 0; i < message.persistentMetadata.length; i++)
      SettingsNamespace.internalBinaryWrite(
        message.persistentMetadata[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MinecraftAccountProto
 */
export const MinecraftAccountProto = new MinecraftAccountProto$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinecraftAccountProto_OnlineChainJavaData$Type extends MessageType<MinecraftAccountProto_OnlineChainJavaData> {
  constructor() {
    super("soulfire.v1.MinecraftAccountProto.OnlineChainJavaData", [
      { no: 3, name: "auth_chain", kind: "message", T: () => Struct },
    ]);
  }
  create(
    value?: PartialMessage<MinecraftAccountProto_OnlineChainJavaData>,
  ): MinecraftAccountProto_OnlineChainJavaData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<MinecraftAccountProto_OnlineChainJavaData>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MinecraftAccountProto_OnlineChainJavaData,
  ): MinecraftAccountProto_OnlineChainJavaData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Struct auth_chain */ 3:
          message.authChain = Struct.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.authChain,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MinecraftAccountProto_OnlineChainJavaData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.protobuf.Struct auth_chain = 3; */
    if (message.authChain)
      Struct.internalBinaryWrite(
        message.authChain,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MinecraftAccountProto.OnlineChainJavaData
 */
export const MinecraftAccountProto_OnlineChainJavaData =
  new MinecraftAccountProto_OnlineChainJavaData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinecraftAccountProto_OfflineJavaData$Type extends MessageType<MinecraftAccountProto_OfflineJavaData> {
  constructor() {
    super("soulfire.v1.MinecraftAccountProto.OfflineJavaData", []);
  }
  create(
    value?: PartialMessage<MinecraftAccountProto_OfflineJavaData>,
  ): MinecraftAccountProto_OfflineJavaData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<MinecraftAccountProto_OfflineJavaData>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MinecraftAccountProto_OfflineJavaData,
  ): MinecraftAccountProto_OfflineJavaData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MinecraftAccountProto_OfflineJavaData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MinecraftAccountProto.OfflineJavaData
 */
export const MinecraftAccountProto_OfflineJavaData =
  new MinecraftAccountProto_OfflineJavaData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinecraftAccountProto_BedrockData$Type extends MessageType<MinecraftAccountProto_BedrockData> {
  constructor() {
    super("soulfire.v1.MinecraftAccountProto.BedrockData", [
      { no: 7, name: "auth_chain", kind: "message", T: () => Struct },
    ]);
  }
  create(
    value?: PartialMessage<MinecraftAccountProto_BedrockData>,
  ): MinecraftAccountProto_BedrockData {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<MinecraftAccountProto_BedrockData>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MinecraftAccountProto_BedrockData,
  ): MinecraftAccountProto_BedrockData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Struct auth_chain */ 7:
          message.authChain = Struct.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.authChain,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MinecraftAccountProto_BedrockData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.protobuf.Struct auth_chain = 7; */
    if (message.authChain)
      Struct.internalBinaryWrite(
        message.authChain,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MinecraftAccountProto.BedrockData
 */
export const MinecraftAccountProto_BedrockData =
  new MinecraftAccountProto_BedrockData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettingsNamespace$Type extends MessageType<SettingsNamespace> {
  constructor() {
    super("soulfire.v1.SettingsNamespace", [
      { no: 1, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "entries",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SettingsNamespace_SettingsEntry,
      },
    ]);
  }
  create(value?: PartialMessage<SettingsNamespace>): SettingsNamespace {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.namespace = "";
    message.entries = [];
    if (value !== undefined)
      reflectionMergePartial<SettingsNamespace>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SettingsNamespace,
  ): SettingsNamespace {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string namespace */ 1:
          message.namespace = reader.string();
          break;
        case /* repeated soulfire.v1.SettingsNamespace.SettingsEntry entries */ 2:
          message.entries.push(
            SettingsNamespace_SettingsEntry.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SettingsNamespace,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string namespace = 1; */
    if (message.namespace !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.namespace);
    /* repeated soulfire.v1.SettingsNamespace.SettingsEntry entries = 2; */
    for (let i = 0; i < message.entries.length; i++)
      SettingsNamespace_SettingsEntry.internalBinaryWrite(
        message.entries[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.SettingsNamespace
 */
export const SettingsNamespace = new SettingsNamespace$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettingsNamespace_SettingsEntry$Type extends MessageType<SettingsNamespace_SettingsEntry> {
  constructor() {
    super("soulfire.v1.SettingsNamespace.SettingsEntry", [
      { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "value", kind: "message", T: () => Value },
    ]);
  }
  create(
    value?: PartialMessage<SettingsNamespace_SettingsEntry>,
  ): SettingsNamespace_SettingsEntry {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.key = "";
    if (value !== undefined)
      reflectionMergePartial<SettingsNamespace_SettingsEntry>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SettingsNamespace_SettingsEntry,
  ): SettingsNamespace_SettingsEntry {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string key */ 1:
          message.key = reader.string();
          break;
        case /* google.protobuf.Value value */ 2:
          message.value = Value.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.value,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SettingsNamespace_SettingsEntry,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string key = 1; */
    if (message.key !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.key);
    /* google.protobuf.Value value = 2; */
    if (message.value)
      Value.internalBinaryWrite(
        message.value,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.SettingsNamespace.SettingsEntry
 */
export const SettingsNamespace_SettingsEntry =
  new SettingsNamespace_SettingsEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettingsEntryIdentifier$Type extends MessageType<SettingsEntryIdentifier> {
  constructor() {
    super("soulfire.v1.SettingsEntryIdentifier", [
      { no: 1, name: "namespace", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<SettingsEntryIdentifier>,
  ): SettingsEntryIdentifier {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.namespace = "";
    message.key = "";
    if (value !== undefined)
      reflectionMergePartial<SettingsEntryIdentifier>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SettingsEntryIdentifier,
  ): SettingsEntryIdentifier {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string namespace */ 1:
          message.namespace = reader.string();
          break;
        case /* string key */ 2:
          message.key = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SettingsEntryIdentifier,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string namespace = 1; */
    if (message.namespace !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.namespace);
    /* string key = 2; */
    if (message.key !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.key);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.SettingsEntryIdentifier
 */
export const SettingsEntryIdentifier = new SettingsEntryIdentifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringSetting$Type extends MessageType<StringSetting> {
  constructor() {
    super("soulfire.v1.StringSetting", [
      { no: 1, name: "ui_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "def", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 10,
        name: "input_type",
        kind: "enum",
        T: () => [
          "soulfire.v1.StringSetting.InputType",
          StringSetting_InputType,
        ],
      },
      {
        no: 6,
        name: "placeholder",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 7, name: "min_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: "max_length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 9, name: "pattern", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 11, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<StringSetting>): StringSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uiName = "";
    message.description = "";
    message.def = "";
    message.inputType = 0;
    message.placeholder = "";
    message.minLength = 0;
    message.maxLength = 0;
    message.pattern = "";
    message.disabled = false;
    if (value !== undefined)
      reflectionMergePartial<StringSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: StringSetting,
  ): StringSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ui_name */ 1:
          message.uiName = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* string def */ 3:
          message.def = reader.string();
          break;
        case /* soulfire.v1.StringSetting.InputType input_type */ 10:
          message.inputType = reader.int32();
          break;
        case /* string placeholder */ 6:
          message.placeholder = reader.string();
          break;
        case /* int32 min_length */ 7:
          message.minLength = reader.int32();
          break;
        case /* int32 max_length */ 8:
          message.maxLength = reader.int32();
          break;
        case /* string pattern */ 9:
          message.pattern = reader.string();
          break;
        case /* bool disabled */ 11:
          message.disabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: StringSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ui_name = 1; */
    if (message.uiName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.uiName);
    /* string description = 2; */
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* string def = 3; */
    if (message.def !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.def);
    /* string placeholder = 6; */
    if (message.placeholder !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.placeholder);
    /* int32 min_length = 7; */
    if (message.minLength !== 0)
      writer.tag(7, WireType.Varint).int32(message.minLength);
    /* int32 max_length = 8; */
    if (message.maxLength !== 0)
      writer.tag(8, WireType.Varint).int32(message.maxLength);
    /* string pattern = 9; */
    if (message.pattern !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.pattern);
    /* soulfire.v1.StringSetting.InputType input_type = 10; */
    if (message.inputType !== 0)
      writer.tag(10, WireType.Varint).int32(message.inputType);
    /* bool disabled = 11; */
    if (message.disabled !== false)
      writer.tag(11, WireType.Varint).bool(message.disabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.StringSetting
 */
export const StringSetting = new StringSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntSetting$Type extends MessageType<IntSetting> {
  constructor() {
    super("soulfire.v1.IntSetting", [
      { no: 1, name: "ui_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "def", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: "min", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 5, name: "max", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: "step", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 7,
        name: "placeholder",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: "thousand_separator",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      { no: 9, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<IntSetting>): IntSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uiName = "";
    message.description = "";
    message.def = 0;
    message.min = 0;
    message.max = 0;
    message.step = 0;
    message.placeholder = "";
    message.thousandSeparator = false;
    message.disabled = false;
    if (value !== undefined)
      reflectionMergePartial<IntSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IntSetting,
  ): IntSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ui_name */ 1:
          message.uiName = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* int32 def */ 3:
          message.def = reader.int32();
          break;
        case /* int32 min */ 4:
          message.min = reader.int32();
          break;
        case /* int32 max */ 5:
          message.max = reader.int32();
          break;
        case /* int32 step */ 6:
          message.step = reader.int32();
          break;
        case /* string placeholder */ 7:
          message.placeholder = reader.string();
          break;
        case /* bool thousand_separator */ 8:
          message.thousandSeparator = reader.bool();
          break;
        case /* bool disabled */ 9:
          message.disabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: IntSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ui_name = 1; */
    if (message.uiName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.uiName);
    /* string description = 2; */
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* int32 def = 3; */
    if (message.def !== 0) writer.tag(3, WireType.Varint).int32(message.def);
    /* int32 min = 4; */
    if (message.min !== 0) writer.tag(4, WireType.Varint).int32(message.min);
    /* int32 max = 5; */
    if (message.max !== 0) writer.tag(5, WireType.Varint).int32(message.max);
    /* int32 step = 6; */
    if (message.step !== 0) writer.tag(6, WireType.Varint).int32(message.step);
    /* string placeholder = 7; */
    if (message.placeholder !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.placeholder);
    /* bool thousand_separator = 8; */
    if (message.thousandSeparator !== false)
      writer.tag(8, WireType.Varint).bool(message.thousandSeparator);
    /* bool disabled = 9; */
    if (message.disabled !== false)
      writer.tag(9, WireType.Varint).bool(message.disabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.IntSetting
 */
export const IntSetting = new IntSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleSetting$Type extends MessageType<DoubleSetting> {
  constructor() {
    super("soulfire.v1.DoubleSetting", [
      { no: 1, name: "ui_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "def", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 4, name: "min", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 5, name: "max", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 6, name: "step", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      {
        no: 7,
        name: "placeholder",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: "thousand_separator",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 9,
        name: "decimal_scale",
        kind: "scalar",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 10,
        name: "fixed_decimal_scale",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      { no: 11, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<DoubleSetting>): DoubleSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uiName = "";
    message.description = "";
    message.def = 0;
    message.min = 0;
    message.max = 0;
    message.step = 0;
    message.placeholder = "";
    message.thousandSeparator = false;
    message.decimalScale = 0;
    message.fixedDecimalScale = false;
    message.disabled = false;
    if (value !== undefined)
      reflectionMergePartial<DoubleSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DoubleSetting,
  ): DoubleSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ui_name */ 1:
          message.uiName = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* double def */ 3:
          message.def = reader.double();
          break;
        case /* double min */ 4:
          message.min = reader.double();
          break;
        case /* double max */ 5:
          message.max = reader.double();
          break;
        case /* double step */ 6:
          message.step = reader.double();
          break;
        case /* string placeholder */ 7:
          message.placeholder = reader.string();
          break;
        case /* bool thousand_separator */ 8:
          message.thousandSeparator = reader.bool();
          break;
        case /* int32 decimal_scale */ 9:
          message.decimalScale = reader.int32();
          break;
        case /* bool fixed_decimal_scale */ 10:
          message.fixedDecimalScale = reader.bool();
          break;
        case /* bool disabled */ 11:
          message.disabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DoubleSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ui_name = 1; */
    if (message.uiName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.uiName);
    /* string description = 2; */
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* double def = 3; */
    if (message.def !== 0) writer.tag(3, WireType.Bit64).double(message.def);
    /* double min = 4; */
    if (message.min !== 0) writer.tag(4, WireType.Bit64).double(message.min);
    /* double max = 5; */
    if (message.max !== 0) writer.tag(5, WireType.Bit64).double(message.max);
    /* double step = 6; */
    if (message.step !== 0) writer.tag(6, WireType.Bit64).double(message.step);
    /* string placeholder = 7; */
    if (message.placeholder !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.placeholder);
    /* bool thousand_separator = 8; */
    if (message.thousandSeparator !== false)
      writer.tag(8, WireType.Varint).bool(message.thousandSeparator);
    /* int32 decimal_scale = 9; */
    if (message.decimalScale !== 0)
      writer.tag(9, WireType.Varint).int32(message.decimalScale);
    /* bool fixed_decimal_scale = 10; */
    if (message.fixedDecimalScale !== false)
      writer.tag(10, WireType.Varint).bool(message.fixedDecimalScale);
    /* bool disabled = 11; */
    if (message.disabled !== false)
      writer.tag(11, WireType.Varint).bool(message.disabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DoubleSetting
 */
export const DoubleSetting = new DoubleSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BoolSetting$Type extends MessageType<BoolSetting> {
  constructor() {
    super("soulfire.v1.BoolSetting", [
      { no: 1, name: "ui_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "def", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<BoolSetting>): BoolSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uiName = "";
    message.description = "";
    message.def = false;
    message.disabled = false;
    if (value !== undefined)
      reflectionMergePartial<BoolSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BoolSetting,
  ): BoolSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ui_name */ 1:
          message.uiName = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* bool def */ 3:
          message.def = reader.bool();
          break;
        case /* bool disabled */ 4:
          message.disabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BoolSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ui_name = 1; */
    if (message.uiName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.uiName);
    /* string description = 2; */
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* bool def = 3; */
    if (message.def !== false) writer.tag(3, WireType.Varint).bool(message.def);
    /* bool disabled = 4; */
    if (message.disabled !== false)
      writer.tag(4, WireType.Varint).bool(message.disabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BoolSetting
 */
export const BoolSetting = new BoolSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComboSetting$Type extends MessageType<ComboSetting> {
  constructor() {
    super("soulfire.v1.ComboSetting", [
      { no: 1, name: "ui_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "options",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ComboSetting_Option,
      },
      { no: 4, name: "def", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<ComboSetting>): ComboSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uiName = "";
    message.description = "";
    message.options = [];
    message.def = "";
    message.disabled = false;
    if (value !== undefined)
      reflectionMergePartial<ComboSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ComboSetting,
  ): ComboSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ui_name */ 1:
          message.uiName = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* repeated soulfire.v1.ComboSetting.Option options */ 3:
          message.options.push(
            ComboSetting_Option.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string def */ 4:
          message.def = reader.string();
          break;
        case /* bool disabled */ 5:
          message.disabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ComboSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ui_name = 1; */
    if (message.uiName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.uiName);
    /* string description = 2; */
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* repeated soulfire.v1.ComboSetting.Option options = 3; */
    for (let i = 0; i < message.options.length; i++)
      ComboSetting_Option.internalBinaryWrite(
        message.options[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string def = 4; */
    if (message.def !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.def);
    /* bool disabled = 5; */
    if (message.disabled !== false)
      writer.tag(5, WireType.Varint).bool(message.disabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ComboSetting
 */
export const ComboSetting = new ComboSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComboSetting_Option$Type extends MessageType<ComboSetting_Option> {
  constructor() {
    super("soulfire.v1.ComboSetting.Option", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "icon_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "keywords",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<ComboSetting_Option>): ComboSetting_Option {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.displayName = "";
    message.keywords = [];
    if (value !== undefined)
      reflectionMergePartial<ComboSetting_Option>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ComboSetting_Option,
  ): ComboSetting_Option {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string display_name */ 2:
          message.displayName = reader.string();
          break;
        case /* optional string icon_id */ 3:
          message.iconId = reader.string();
          break;
        case /* repeated string keywords */ 4:
          message.keywords.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ComboSetting_Option,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string display_name = 2; */
    if (message.displayName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.displayName);
    /* optional string icon_id = 3; */
    if (message.iconId !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.iconId);
    /* repeated string keywords = 4; */
    for (let i = 0; i < message.keywords.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.keywords[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ComboSetting.Option
 */
export const ComboSetting_Option = new ComboSetting_Option$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringListSetting$Type extends MessageType<StringListSetting> {
  constructor() {
    super("soulfire.v1.StringListSetting", [
      { no: 1, name: "ui_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "def",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<StringListSetting>): StringListSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uiName = "";
    message.description = "";
    message.def = [];
    message.disabled = false;
    if (value !== undefined)
      reflectionMergePartial<StringListSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: StringListSetting,
  ): StringListSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ui_name */ 1:
          message.uiName = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* repeated string def */ 3:
          message.def.push(reader.string());
          break;
        case /* bool disabled */ 4:
          message.disabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: StringListSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ui_name = 1; */
    if (message.uiName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.uiName);
    /* string description = 2; */
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* repeated string def = 3; */
    for (let i = 0; i < message.def.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.def[i]);
    /* bool disabled = 4; */
    if (message.disabled !== false)
      writer.tag(4, WireType.Varint).bool(message.disabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.StringListSetting
 */
export const StringListSetting = new StringListSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinMaxSetting$Type extends MessageType<MinMaxSetting> {
  constructor() {
    super("soulfire.v1.MinMaxSetting", [
      { no: 1, name: "min", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: "max", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: "step", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 4,
        name: "thousand_separator",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 5,
        name: "minEntry",
        kind: "message",
        T: () => MinMaxSetting_Entry,
      },
      {
        no: 6,
        name: "maxEntry",
        kind: "message",
        T: () => MinMaxSetting_Entry,
      },
      { no: 7, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<MinMaxSetting>): MinMaxSetting {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.min = 0;
    message.max = 0;
    message.step = 0;
    message.thousandSeparator = false;
    message.disabled = false;
    if (value !== undefined)
      reflectionMergePartial<MinMaxSetting>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MinMaxSetting,
  ): MinMaxSetting {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int32 min */ 1:
          message.min = reader.int32();
          break;
        case /* int32 max */ 2:
          message.max = reader.int32();
          break;
        case /* int32 step */ 3:
          message.step = reader.int32();
          break;
        case /* bool thousand_separator */ 4:
          message.thousandSeparator = reader.bool();
          break;
        case /* soulfire.v1.MinMaxSetting.Entry minEntry */ 5:
          message.minEntry = MinMaxSetting_Entry.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.minEntry,
          );
          break;
        case /* soulfire.v1.MinMaxSetting.Entry maxEntry */ 6:
          message.maxEntry = MinMaxSetting_Entry.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.maxEntry,
          );
          break;
        case /* bool disabled */ 7:
          message.disabled = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MinMaxSetting,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 min = 1; */
    if (message.min !== 0) writer.tag(1, WireType.Varint).int32(message.min);
    /* int32 max = 2; */
    if (message.max !== 0) writer.tag(2, WireType.Varint).int32(message.max);
    /* int32 step = 3; */
    if (message.step !== 0) writer.tag(3, WireType.Varint).int32(message.step);
    /* bool thousand_separator = 4; */
    if (message.thousandSeparator !== false)
      writer.tag(4, WireType.Varint).bool(message.thousandSeparator);
    /* soulfire.v1.MinMaxSetting.Entry minEntry = 5; */
    if (message.minEntry)
      MinMaxSetting_Entry.internalBinaryWrite(
        message.minEntry,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.MinMaxSetting.Entry maxEntry = 6; */
    if (message.maxEntry)
      MinMaxSetting_Entry.internalBinaryWrite(
        message.maxEntry,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bool disabled = 7; */
    if (message.disabled !== false)
      writer.tag(7, WireType.Varint).bool(message.disabled);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MinMaxSetting
 */
export const MinMaxSetting = new MinMaxSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinMaxSetting_Entry$Type extends MessageType<MinMaxSetting_Entry> {
  constructor() {
    super("soulfire.v1.MinMaxSetting.Entry", [
      { no: 1, name: "ui_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "def", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
      {
        no: 4,
        name: "placeholder",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<MinMaxSetting_Entry>): MinMaxSetting_Entry {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.uiName = "";
    message.description = "";
    message.def = 0;
    message.placeholder = "";
    if (value !== undefined)
      reflectionMergePartial<MinMaxSetting_Entry>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MinMaxSetting_Entry,
  ): MinMaxSetting_Entry {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string ui_name */ 1:
          message.uiName = reader.string();
          break;
        case /* string description */ 2:
          message.description = reader.string();
          break;
        case /* int32 def */ 3:
          message.def = reader.int32();
          break;
        case /* string placeholder */ 4:
          message.placeholder = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MinMaxSetting_Entry,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string ui_name = 1; */
    if (message.uiName !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.uiName);
    /* string description = 2; */
    if (message.description !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.description);
    /* int32 def = 3; */
    if (message.def !== 0) writer.tag(3, WireType.Varint).int32(message.def);
    /* string placeholder = 4; */
    if (message.placeholder !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.placeholder);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MinMaxSetting.Entry
 */
export const MinMaxSetting_Entry = new MinMaxSetting_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettingsDefinition$Type extends MessageType<SettingsDefinition> {
  constructor() {
    super("soulfire.v1.SettingsDefinition", [
      { no: 1, name: "id", kind: "message", T: () => SettingsEntryIdentifier },
      {
        no: 2,
        name: "scope",
        kind: "enum",
        T: () => [
          "soulfire.v1.SettingsPageEntryScopeType",
          SettingsPageEntryScopeType,
        ],
      },
      {
        no: 3,
        name: "string",
        kind: "message",
        oneof: "type",
        T: () => StringSetting,
      },
      {
        no: 4,
        name: "int",
        kind: "message",
        oneof: "type",
        T: () => IntSetting,
      },
      {
        no: 5,
        name: "double",
        kind: "message",
        oneof: "type",
        T: () => DoubleSetting,
      },
      {
        no: 6,
        name: "bool",
        kind: "message",
        oneof: "type",
        T: () => BoolSetting,
      },
      {
        no: 7,
        name: "combo",
        kind: "message",
        oneof: "type",
        T: () => ComboSetting,
      },
      {
        no: 8,
        name: "string_list",
        kind: "message",
        oneof: "type",
        T: () => StringListSetting,
      },
      {
        no: 9,
        name: "min_max",
        kind: "message",
        oneof: "type",
        T: () => MinMaxSetting,
      },
    ]);
  }
  create(value?: PartialMessage<SettingsDefinition>): SettingsDefinition {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scope = 0;
    message.type = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<SettingsDefinition>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SettingsDefinition,
  ): SettingsDefinition {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.SettingsEntryIdentifier id */ 1:
          message.id = SettingsEntryIdentifier.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.id,
          );
          break;
        case /* soulfire.v1.SettingsPageEntryScopeType scope */ 2:
          message.scope = reader.int32();
          break;
        case /* soulfire.v1.StringSetting string */ 3:
          message.type = {
            oneofKind: "string",
            string: StringSetting.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.type as any).string,
            ),
          };
          break;
        case /* soulfire.v1.IntSetting int */ 4:
          message.type = {
            oneofKind: "int",
            int: IntSetting.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.type as any).int,
            ),
          };
          break;
        case /* soulfire.v1.DoubleSetting double */ 5:
          message.type = {
            oneofKind: "double",
            double: DoubleSetting.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.type as any).double,
            ),
          };
          break;
        case /* soulfire.v1.BoolSetting bool */ 6:
          message.type = {
            oneofKind: "bool",
            bool: BoolSetting.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.type as any).bool,
            ),
          };
          break;
        case /* soulfire.v1.ComboSetting combo */ 7:
          message.type = {
            oneofKind: "combo",
            combo: ComboSetting.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.type as any).combo,
            ),
          };
          break;
        case /* soulfire.v1.StringListSetting string_list */ 8:
          message.type = {
            oneofKind: "stringList",
            stringList: StringListSetting.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.type as any).stringList,
            ),
          };
          break;
        case /* soulfire.v1.MinMaxSetting min_max */ 9:
          message.type = {
            oneofKind: "minMax",
            minMax: MinMaxSetting.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.type as any).minMax,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SettingsDefinition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.SettingsEntryIdentifier id = 1; */
    if (message.id)
      SettingsEntryIdentifier.internalBinaryWrite(
        message.id,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.SettingsPageEntryScopeType scope = 2; */
    if (message.scope !== 0)
      writer.tag(2, WireType.Varint).int32(message.scope);
    /* soulfire.v1.StringSetting string = 3; */
    if (message.type.oneofKind === "string")
      StringSetting.internalBinaryWrite(
        message.type.string,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.IntSetting int = 4; */
    if (message.type.oneofKind === "int")
      IntSetting.internalBinaryWrite(
        message.type.int,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.DoubleSetting double = 5; */
    if (message.type.oneofKind === "double")
      DoubleSetting.internalBinaryWrite(
        message.type.double,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.BoolSetting bool = 6; */
    if (message.type.oneofKind === "bool")
      BoolSetting.internalBinaryWrite(
        message.type.bool,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.ComboSetting combo = 7; */
    if (message.type.oneofKind === "combo")
      ComboSetting.internalBinaryWrite(
        message.type.combo,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.StringListSetting string_list = 8; */
    if (message.type.oneofKind === "stringList")
      StringListSetting.internalBinaryWrite(
        message.type.stringList,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.MinMaxSetting min_max = 9; */
    if (message.type.oneofKind === "minMax")
      MinMaxSetting.internalBinaryWrite(
        message.type.minMax,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.SettingsDefinition
 */
export const SettingsDefinition = new SettingsDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SettingsPage$Type extends MessageType<SettingsPage> {
  constructor() {
    super("soulfire.v1.SettingsPage", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "owning_plugin_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "page_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "entries",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => SettingsEntryIdentifier,
      },
      { no: 6, name: "icon_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 7,
        name: "enabled_identifier",
        kind: "message",
        T: () => SettingsEntryIdentifier,
      },
    ]);
  }
  create(value?: PartialMessage<SettingsPage>): SettingsPage {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.pageName = "";
    message.entries = [];
    message.iconId = "";
    if (value !== undefined)
      reflectionMergePartial<SettingsPage>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SettingsPage,
  ): SettingsPage {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* optional string owning_plugin_id */ 2:
          message.owningPluginId = reader.string();
          break;
        case /* string page_name */ 3:
          message.pageName = reader.string();
          break;
        case /* repeated soulfire.v1.SettingsEntryIdentifier entries */ 5:
          message.entries.push(
            SettingsEntryIdentifier.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* string icon_id */ 6:
          message.iconId = reader.string();
          break;
        case /* optional soulfire.v1.SettingsEntryIdentifier enabled_identifier */ 7:
          message.enabledIdentifier =
            SettingsEntryIdentifier.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.enabledIdentifier,
            );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SettingsPage,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* optional string owning_plugin_id = 2; */
    if (message.owningPluginId !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.owningPluginId);
    /* string page_name = 3; */
    if (message.pageName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.pageName);
    /* repeated soulfire.v1.SettingsEntryIdentifier entries = 5; */
    for (let i = 0; i < message.entries.length; i++)
      SettingsEntryIdentifier.internalBinaryWrite(
        message.entries[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string icon_id = 6; */
    if (message.iconId !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.iconId);
    /* optional soulfire.v1.SettingsEntryIdentifier enabled_identifier = 7; */
    if (message.enabledIdentifier)
      SettingsEntryIdentifier.internalBinaryWrite(
        message.enabledIdentifier,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.SettingsPage
 */
export const SettingsPage = new SettingsPage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerPlugin$Type extends MessageType<ServerPlugin> {
  constructor() {
    super("soulfire.v1.ServerPlugin", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "author", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "license", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: "website", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ServerPlugin>): ServerPlugin {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.version = "";
    message.description = "";
    message.author = "";
    message.license = "";
    message.website = "";
    if (value !== undefined)
      reflectionMergePartial<ServerPlugin>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServerPlugin,
  ): ServerPlugin {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string version */ 2:
          message.version = reader.string();
          break;
        case /* string description */ 3:
          message.description = reader.string();
          break;
        case /* string author */ 4:
          message.author = reader.string();
          break;
        case /* string license */ 5:
          message.license = reader.string();
          break;
        case /* string website */ 6:
          message.website = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ServerPlugin,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string version = 2; */
    if (message.version !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.version);
    /* string description = 3; */
    if (message.description !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    /* string author = 4; */
    if (message.author !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.author);
    /* string license = 5; */
    if (message.license !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.license);
    /* string website = 6; */
    if (message.website !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.website);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ServerPlugin
 */
export const ServerPlugin = new ServerPlugin$Type();
