/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,optimize_code_size,eslint_disable,ts_nocheck
// @generated from protobuf file "soulfire/logs.proto" (package "soulfire.v1", syntax proto3)
// tslint:disable
// @ts-nocheck

import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from "@protobuf-ts/runtime";
import {
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from "@protobuf-ts/runtime";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { Timestamp } from "../google/protobuf/timestamp";
/**
 * Represents a single log entry from the SoulFire logging system.
 * Log entries can be associated with specific instances, bots, or scripts,
 * or they can be personal messages directed to a specific user.
 *
 * @generated from protobuf message soulfire.v1.LogString
 */
export interface LogString {
  /**
   * Unique identifier for this log entry. Format is "{timestamp_millis}-{counter}"
   * where counter is an incrementing integer to ensure uniqueness within the same millisecond.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * The formatted log message content. This is the fully formatted output including
   * any Minecraft formatting codes and exception stack traces if present.
   *
   * @generated from protobuf field: string message = 2
   */
  message: string;
  /**
   * The UUID of the instance this log is associated with, if any.
   * Present when the log was generated in the context of a specific attack instance.
   *
   * @generated from protobuf field: optional string instance_id = 3
   */
  instanceId?: string;
  /**
   * The UUID of the bot account this log is associated with, if any.
   * Present when the log was generated by or about a specific bot.
   *
   * @generated from protobuf field: optional string bot_account_id = 4
   */
  botAccountId?: string;
  /**
   * The UUID of the script this log is associated with, if any.
   * Present when the log was generated during script execution.
   *
   * @generated from protobuf field: optional string script_id = 5
   */
  scriptId?: string;
  /**
   * Indicates whether this is a personal message directed to a specific user.
   * Personal messages are only visible to the target user and are not stored in the log history.
   *
   * @generated from protobuf field: bool personal = 6
   */
  personal: boolean;
  /**
   * Human-readable name of the instance, if available.
   * Provided as a convenience to avoid requiring additional lookups.
   *
   * @generated from protobuf field: optional string instance_name = 7
   */
  instanceName?: string;
  /**
   * Human-readable name of the bot account, if available.
   * Provided as a convenience to avoid requiring additional lookups.
   *
   * @generated from protobuf field: optional string bot_account_name = 8
   */
  botAccountName?: string;
  /**
   * The timestamp when this log entry was created.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 9
   */
  timestamp?: Timestamp;
  /**
   * The name of the logger that produced this log entry (e.g., "com.soulfiremc.server.SomeClass").
   * Useful for filtering and debugging purposes.
   *
   * @generated from protobuf field: optional string logger_name = 10
   */
  loggerName?: string;
  /**
   * The log level (e.g., "INFO", "WARN", "ERROR", "DEBUG", "TRACE", "FATAL").
   * Corresponds to Log4j2 log levels.
   *
   * @generated from protobuf field: optional string level = 11
   */
  level?: string;
}
/**
 * Scope for receiving all non-personal logs from the entire server.
 * Requires the GLOBAL_SUBSCRIBE_LOGS permission.
 *
 * @generated from protobuf message soulfire.v1.GlobalLogScope
 */
export interface GlobalLogScope {}
/**
 * Scope for receiving logs from a specific attack instance.
 * Only includes logs where the instance_id matches. Personal logs are excluded.
 * Requires the INSTANCE_SUBSCRIBE_LOGS permission for the specified instance.
 *
 * @generated from protobuf message soulfire.v1.InstanceLogScope
 */
export interface InstanceLogScope {
  /**
   * The UUID of the instance to filter logs for. Must be a valid UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
}
/**
 * Scope for receiving logs from a specific bot within an instance.
 * Only includes logs where both instance_id and bot_account_id match. Personal logs are excluded.
 * Requires the INSTANCE_SUBSCRIBE_LOGS permission for the specified instance.
 *
 * @generated from protobuf message soulfire.v1.BotLogScope
 */
export interface BotLogScope {
  /**
   * The UUID of the instance the bot belongs to. Must be a valid UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The UUID of the bot account to filter logs for. Must be a valid UUID string.
   *
   * @generated from protobuf field: string bot_id = 2
   */
  botId: string;
}
/**
 * Scope for receiving logs from a specific script running within an instance.
 * Only includes logs where both instance_id and script_id match. Personal logs are excluded.
 * Requires the INSTANCE_SUBSCRIBE_LOGS permission for the specified instance.
 *
 * @generated from protobuf message soulfire.v1.InstanceScriptLogScope
 */
export interface InstanceScriptLogScope {
  /**
   * The UUID of the instance the script is running in. Must be a valid UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The UUID of the script to filter logs for. Must be a valid UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
}
/**
 * Scope for receiving personal messages directed to the authenticated user.
 * Personal messages are private notifications that are not stored in log history.
 * No special permissions required beyond being authenticated.
 *
 * @generated from protobuf message soulfire.v1.PersonalLogScope
 */
export interface PersonalLogScope {}
/**
 * Defines the scope of logs to retrieve or subscribe to.
 * The scope determines which logs are included based on their source and the user's permissions.
 *
 * @generated from protobuf message soulfire.v1.LogScope
 */
export interface LogScope {
  /**
   * Reserved for removed GlobalScriptLogScope (field 4)
   *
   * @generated from protobuf oneof: scope
   */
  scope:
    | {
        oneofKind: "global";
        /**
         * Receive all non-personal logs from the server. Requires GLOBAL_SUBSCRIBE_LOGS permission.
         *
         * @generated from protobuf field: soulfire.v1.GlobalLogScope global = 1
         */
        global: GlobalLogScope;
      }
    | {
        oneofKind: "instance";
        /**
         * Receive logs from a specific instance. Requires INSTANCE_SUBSCRIBE_LOGS permission.
         *
         * @generated from protobuf field: soulfire.v1.InstanceLogScope instance = 2
         */
        instance: InstanceLogScope;
      }
    | {
        oneofKind: "bot";
        /**
         * Receive logs from a specific bot within an instance. Requires INSTANCE_SUBSCRIBE_LOGS permission.
         *
         * @generated from protobuf field: soulfire.v1.BotLogScope bot = 3
         */
        bot: BotLogScope;
      }
    | {
        oneofKind: "instanceScript";
        /**
         * Receive logs from a specific script within an instance. Requires INSTANCE_SUBSCRIBE_LOGS permission.
         *
         * @generated from protobuf field: soulfire.v1.InstanceScriptLogScope instance_script = 5
         */
        instanceScript: InstanceScriptLogScope;
      }
    | {
        oneofKind: "personal";
        /**
         * Receive personal messages for the authenticated user. No special permissions required.
         *
         * @generated from protobuf field: soulfire.v1.PersonalLogScope personal = 6
         */
        personal: PersonalLogScope;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * Request to retrieve historical log entries from the server's log buffer.
 *
 * @generated from protobuf message soulfire.v1.PreviousLogRequest
 */
export interface PreviousLogRequest {
  /**
   * The scope defining which logs to retrieve. Personal logs are not included
   * in historical retrieval as they are not stored.
   *
   * @generated from protobuf field: soulfire.v1.LogScope scope = 4
   */
  scope?: LogScope;
  /**
   * The maximum number of recent log entries to retrieve.
   * Must not exceed 300 (the server's maximum log buffer size).
   * Returns the newest entries that match the scope, up to this count.
   *
   * @generated from protobuf field: int32 count = 3
   */
  count: number;
}
/**
 * Response containing historical log entries.
 *
 * @generated from protobuf message soulfire.v1.PreviousLogResponse
 */
export interface PreviousLogResponse {
  /**
   * The list of log entries matching the requested scope, ordered from oldest to newest.
   * May contain fewer entries than requested if not enough matching logs exist in the buffer.
   *
   * @generated from protobuf field: repeated soulfire.v1.LogString messages = 1
   */
  messages: LogString[];
}
/**
 * Request to subscribe to a real-time stream of log entries.
 *
 * @generated from protobuf message soulfire.v1.LogRequest
 */
export interface LogRequest {
  /**
   * The scope defining which logs to receive. The subscription will only
   * deliver logs that match this scope and that the user has permission to access.
   *
   * @generated from protobuf field: soulfire.v1.LogScope scope = 3
   */
  scope?: LogScope;
}
/**
 * Response containing a single log entry from a subscription stream.
 *
 * @generated from protobuf message soulfire.v1.LogResponse
 */
export interface LogResponse {
  /**
   * A single log entry that matches the subscription scope.
   *
   * @generated from protobuf field: soulfire.v1.LogString message = 1
   */
  message?: LogString;
}
// @generated message type with reflection information, may provide speed optimized methods
class LogString$Type extends MessageType<LogString> {
  constructor() {
    super("soulfire.v1.LogString", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "instance_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "bot_account_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "script_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 6, name: "personal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 7,
        name: "instance_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 8,
        name: "bot_account_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 9, name: "timestamp", kind: "message", T: () => Timestamp },
      {
        no: 10,
        name: "logger_name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 11,
        name: "level",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<LogString>): LogString {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.message = "";
    message.personal = false;
    if (value !== undefined)
      reflectionMergePartial<LogString>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogString,
  ): LogString {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string message */ 2:
          message.message = reader.string();
          break;
        case /* optional string instance_id */ 3:
          message.instanceId = reader.string();
          break;
        case /* optional string bot_account_id */ 4:
          message.botAccountId = reader.string();
          break;
        case /* optional string script_id */ 5:
          message.scriptId = reader.string();
          break;
        case /* bool personal */ 6:
          message.personal = reader.bool();
          break;
        case /* optional string instance_name */ 7:
          message.instanceName = reader.string();
          break;
        case /* optional string bot_account_name */ 8:
          message.botAccountName = reader.string();
          break;
        case /* google.protobuf.Timestamp timestamp */ 9:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        case /* optional string logger_name */ 10:
          message.loggerName = reader.string();
          break;
        case /* optional string level */ 11:
          message.level = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LogString,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string message = 2; */
    if (message.message !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.message);
    /* optional string instance_id = 3; */
    if (message.instanceId !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.instanceId);
    /* optional string bot_account_id = 4; */
    if (message.botAccountId !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.botAccountId);
    /* optional string script_id = 5; */
    if (message.scriptId !== undefined)
      writer.tag(5, WireType.LengthDelimited).string(message.scriptId);
    /* bool personal = 6; */
    if (message.personal !== false)
      writer.tag(6, WireType.Varint).bool(message.personal);
    /* optional string instance_name = 7; */
    if (message.instanceName !== undefined)
      writer.tag(7, WireType.LengthDelimited).string(message.instanceName);
    /* optional string bot_account_name = 8; */
    if (message.botAccountName !== undefined)
      writer.tag(8, WireType.LengthDelimited).string(message.botAccountName);
    /* google.protobuf.Timestamp timestamp = 9; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* optional string logger_name = 10; */
    if (message.loggerName !== undefined)
      writer.tag(10, WireType.LengthDelimited).string(message.loggerName);
    /* optional string level = 11; */
    if (message.level !== undefined)
      writer.tag(11, WireType.LengthDelimited).string(message.level);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.LogString
 */
export const LogString = new LogString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalLogScope$Type extends MessageType<GlobalLogScope> {
  constructor() {
    super("soulfire.v1.GlobalLogScope", []);
  }
  create(value?: PartialMessage<GlobalLogScope>): GlobalLogScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<GlobalLogScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GlobalLogScope,
  ): GlobalLogScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GlobalLogScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GlobalLogScope
 */
export const GlobalLogScope = new GlobalLogScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceLogScope$Type extends MessageType<InstanceLogScope> {
  constructor() {
    super("soulfire.v1.InstanceLogScope", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<InstanceLogScope>): InstanceLogScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    if (value !== undefined)
      reflectionMergePartial<InstanceLogScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: InstanceLogScope,
  ): InstanceLogScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: InstanceLogScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.InstanceLogScope
 */
export const InstanceLogScope = new InstanceLogScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotLogScope$Type extends MessageType<BotLogScope> {
  constructor() {
    super("soulfire.v1.BotLogScope", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "bot_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BotLogScope>): BotLogScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.botId = "";
    if (value !== undefined)
      reflectionMergePartial<BotLogScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotLogScope,
  ): BotLogScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string bot_id */ 2:
          message.botId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotLogScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string bot_id = 2; */
    if (message.botId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.botId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotLogScope
 */
export const BotLogScope = new BotLogScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstanceScriptLogScope$Type extends MessageType<InstanceScriptLogScope> {
  constructor() {
    super("soulfire.v1.InstanceScriptLogScope", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<InstanceScriptLogScope>,
  ): InstanceScriptLogScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    if (value !== undefined)
      reflectionMergePartial<InstanceScriptLogScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: InstanceScriptLogScope,
  ): InstanceScriptLogScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: InstanceScriptLogScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.InstanceScriptLogScope
 */
export const InstanceScriptLogScope = new InstanceScriptLogScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PersonalLogScope$Type extends MessageType<PersonalLogScope> {
  constructor() {
    super("soulfire.v1.PersonalLogScope", []);
  }
  create(value?: PartialMessage<PersonalLogScope>): PersonalLogScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<PersonalLogScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PersonalLogScope,
  ): PersonalLogScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PersonalLogScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.PersonalLogScope
 */
export const PersonalLogScope = new PersonalLogScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogScope$Type extends MessageType<LogScope> {
  constructor() {
    super("soulfire.v1.LogScope", [
      {
        no: 1,
        name: "global",
        kind: "message",
        oneof: "scope",
        T: () => GlobalLogScope,
      },
      {
        no: 2,
        name: "instance",
        kind: "message",
        oneof: "scope",
        T: () => InstanceLogScope,
      },
      {
        no: 3,
        name: "bot",
        kind: "message",
        oneof: "scope",
        T: () => BotLogScope,
      },
      {
        no: 5,
        name: "instance_script",
        kind: "message",
        oneof: "scope",
        T: () => InstanceScriptLogScope,
      },
      {
        no: 6,
        name: "personal",
        kind: "message",
        oneof: "scope",
        T: () => PersonalLogScope,
      },
    ]);
  }
  create(value?: PartialMessage<LogScope>): LogScope {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scope = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<LogScope>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogScope,
  ): LogScope {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.GlobalLogScope global */ 1:
          message.scope = {
            oneofKind: "global",
            global: GlobalLogScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).global,
            ),
          };
          break;
        case /* soulfire.v1.InstanceLogScope instance */ 2:
          message.scope = {
            oneofKind: "instance",
            instance: InstanceLogScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).instance,
            ),
          };
          break;
        case /* soulfire.v1.BotLogScope bot */ 3:
          message.scope = {
            oneofKind: "bot",
            bot: BotLogScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).bot,
            ),
          };
          break;
        case /* soulfire.v1.InstanceScriptLogScope instance_script */ 5:
          message.scope = {
            oneofKind: "instanceScript",
            instanceScript: InstanceScriptLogScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).instanceScript,
            ),
          };
          break;
        case /* soulfire.v1.PersonalLogScope personal */ 6:
          message.scope = {
            oneofKind: "personal",
            personal: PersonalLogScope.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.scope as any).personal,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LogScope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.GlobalLogScope global = 1; */
    if (message.scope.oneofKind === "global")
      GlobalLogScope.internalBinaryWrite(
        message.scope.global,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.InstanceLogScope instance = 2; */
    if (message.scope.oneofKind === "instance")
      InstanceLogScope.internalBinaryWrite(
        message.scope.instance,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.BotLogScope bot = 3; */
    if (message.scope.oneofKind === "bot")
      BotLogScope.internalBinaryWrite(
        message.scope.bot,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.InstanceScriptLogScope instance_script = 5; */
    if (message.scope.oneofKind === "instanceScript")
      InstanceScriptLogScope.internalBinaryWrite(
        message.scope.instanceScript,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.PersonalLogScope personal = 6; */
    if (message.scope.oneofKind === "personal")
      PersonalLogScope.internalBinaryWrite(
        message.scope.personal,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.LogScope
 */
export const LogScope = new LogScope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreviousLogRequest$Type extends MessageType<PreviousLogRequest> {
  constructor() {
    super("soulfire.v1.PreviousLogRequest", [
      { no: 4, name: "scope", kind: "message", T: () => LogScope },
      { no: 3, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<PreviousLogRequest>): PreviousLogRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.count = 0;
    if (value !== undefined)
      reflectionMergePartial<PreviousLogRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PreviousLogRequest,
  ): PreviousLogRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.LogScope scope */ 4:
          message.scope = LogScope.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.scope,
          );
          break;
        case /* int32 count */ 3:
          message.count = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PreviousLogRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int32 count = 3; */
    if (message.count !== 0)
      writer.tag(3, WireType.Varint).int32(message.count);
    /* soulfire.v1.LogScope scope = 4; */
    if (message.scope)
      LogScope.internalBinaryWrite(
        message.scope,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.PreviousLogRequest
 */
export const PreviousLogRequest = new PreviousLogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreviousLogResponse$Type extends MessageType<PreviousLogResponse> {
  constructor() {
    super("soulfire.v1.PreviousLogResponse", [
      {
        no: 1,
        name: "messages",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => LogString,
      },
    ]);
  }
  create(value?: PartialMessage<PreviousLogResponse>): PreviousLogResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.messages = [];
    if (value !== undefined)
      reflectionMergePartial<PreviousLogResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PreviousLogResponse,
  ): PreviousLogResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.LogString messages */ 1:
          message.messages.push(
            LogString.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PreviousLogResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.LogString messages = 1; */
    for (let i = 0; i < message.messages.length; i++)
      LogString.internalBinaryWrite(
        message.messages[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.PreviousLogResponse
 */
export const PreviousLogResponse = new PreviousLogResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogRequest$Type extends MessageType<LogRequest> {
  constructor() {
    super("soulfire.v1.LogRequest", [
      { no: 3, name: "scope", kind: "message", T: () => LogScope },
    ]);
  }
  create(value?: PartialMessage<LogRequest>): LogRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<LogRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogRequest,
  ): LogRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.LogScope scope */ 3:
          message.scope = LogScope.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.scope,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LogRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.LogScope scope = 3; */
    if (message.scope)
      LogScope.internalBinaryWrite(
        message.scope,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.LogRequest
 */
export const LogRequest = new LogRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogResponse$Type extends MessageType<LogResponse> {
  constructor() {
    super("soulfire.v1.LogResponse", [
      { no: 1, name: "message", kind: "message", T: () => LogString },
    ]);
  }
  create(value?: PartialMessage<LogResponse>): LogResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<LogResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LogResponse,
  ): LogResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.LogString message */ 1:
          message.message = LogString.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.message,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: LogResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.LogString message = 1; */
    if (message.message)
      LogString.internalBinaryWrite(
        message.message,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.LogResponse
 */
export const LogResponse = new LogResponse$Type();
/**
 * @generated ServiceType for protobuf service soulfire.v1.LogsService
 */
export const LogsService = new ServiceType("soulfire.v1.LogsService", [
  {
    name: "GetPrevious",
    options: {},
    I: PreviousLogRequest,
    O: PreviousLogResponse,
  },
  {
    name: "Subscribe",
    serverStreaming: true,
    options: {},
    I: LogRequest,
    O: LogResponse,
  },
]);
