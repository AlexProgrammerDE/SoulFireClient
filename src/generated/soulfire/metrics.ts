/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,optimize_code_size,eslint_disable,ts_nocheck
// @generated from protobuf file "soulfire/metrics.proto" (package "soulfire.v1", syntax proto3)
// tslint:disable
// @ts-nocheck

import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from "@protobuf-ts/runtime";
import {
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from "@protobuf-ts/runtime";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { Timestamp } from "../google/protobuf/timestamp";
// ============================================================================
// MetricsService - Instance Metrics and Monitoring Service
// ============================================================================
//
// The MetricsService provides real-time metrics and monitoring data for
// SoulFire instances. It enables clients to:
//
// - View time-series metrics (bot counts, network traffic, tick duration, etc.)
// - View current-state distributions (health histograms, dimension counts, etc.)
// - Track bot positions on an XZ scatter plot
//
// Metrics are collected server-side and stored in a ring buffer, ensuring
// consistent data across multiple clients. Snapshots are sampled every 3 seconds.
// ============================================================================

/**
 * A single time-series data point sampled at a fixed interval.
 *
 * @generated from protobuf message soulfire.v1.MetricsSnapshot
 */
export interface MetricsSnapshot {
  /**
   * When this snapshot was taken.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 1
   */
  timestamp?: Timestamp;
  /**
   * Number of bots currently connected to the Minecraft server.
   *
   * @generated from protobuf field: uint32 bots_online = 2
   */
  botsOnline: number;
  /**
   * Total number of bots configured in the instance (online + offline).
   *
   * @generated from protobuf field: uint32 bots_total = 3
   */
  botsTotal: number;
  /**
   * Cumulative packets sent across all bots since session start.
   *
   * @generated from protobuf field: uint64 packets_sent_total = 4
   */
  packetsSentTotal: string;
  /**
   * Cumulative packets received across all bots since session start.
   *
   * @generated from protobuf field: uint64 packets_received_total = 5
   */
  packetsReceivedTotal: string;
  /**
   * Cumulative bytes sent across all bots since session start.
   *
   * @generated from protobuf field: uint64 bytes_sent_total = 6
   */
  bytesSentTotal: string;
  /**
   * Cumulative bytes received across all bots since session start.
   *
   * @generated from protobuf field: uint64 bytes_received_total = 7
   */
  bytesReceivedTotal: string;
  /**
   * Current rate of packets sent per second (computed from counter deltas).
   *
   * @generated from protobuf field: double packets_sent_per_second = 8
   */
  packetsSentPerSecond: number;
  /**
   * Current rate of packets received per second (computed from counter deltas).
   *
   * @generated from protobuf field: double packets_received_per_second = 9
   */
  packetsReceivedPerSecond: number;
  /**
   * Current rate of bytes sent per second (computed from counter deltas).
   *
   * @generated from protobuf field: double bytes_sent_per_second = 10
   */
  bytesSentPerSecond: number;
  /**
   * Current rate of bytes received per second (computed from counter deltas).
   *
   * @generated from protobuf field: double bytes_received_per_second = 11
   */
  bytesReceivedPerSecond: number;
  /**
   * Average tick duration across all bots in milliseconds.
   *
   * @generated from protobuf field: double avg_tick_duration_ms = 12
   */
  avgTickDurationMs: number;
  /**
   * Maximum tick duration observed across all bots in milliseconds.
   * Reset each sampling interval.
   *
   * @generated from protobuf field: double max_tick_duration_ms = 13
   */
  maxTickDurationMs: number;
  /**
   * Average health across all online bots with player data.
   * Range: 0 to 20 (Minecraft health points).
   *
   * @generated from protobuf field: double avg_health = 14
   */
  avgHealth: number;
  /**
   * Average food level across all online bots with player data.
   * Range: 0 to 20 (Minecraft food points).
   *
   * @generated from protobuf field: double avg_food_level = 15
   */
  avgFoodLevel: number;
  /**
   * Total number of loaded chunks across all online bots.
   *
   * @generated from protobuf field: uint32 total_loaded_chunks = 16
   */
  totalLoadedChunks: number;
  /**
   * Total number of tracked entities across all online bots.
   *
   * @generated from protobuf field: uint32 total_tracked_entities = 17
   */
  totalTrackedEntities: number;
  /**
   * Connection events since the previous snapshot.
   *
   * @generated from protobuf field: uint32 connections = 18
   */
  connections: number;
  /**
   * Disconnection events since the previous snapshot.
   *
   * @generated from protobuf field: uint32 disconnections = 19
   */
  disconnections: number;
}
/**
 * Current-state distributions computed from the latest bot data.
 * These are not time-series; they reflect the current instant.
 *
 * @generated from protobuf message soulfire.v1.MetricsDistributions
 */
export interface MetricsDistributions {
  /**
   * Health histogram with 10 buckets of width 2: [0,2), [2,4), ..., [18,20].
   * Each entry is the count of bots whose health falls in that bucket.
   *
   * @generated from protobuf field: repeated uint32 health_histogram = 1
   */
  healthHistogram: number[];
  /**
   * Food level histogram with 10 buckets of width 2: [0,2), [2,4), ..., [18,20].
   *
   * @generated from protobuf field: repeated uint32 food_histogram = 2
   */
  foodHistogram: number[];
  /**
   * Number of bots in each dimension (e.g., "minecraft:overworld" -> 5).
   *
   * @generated from protobuf field: map<string, uint32> dimension_counts = 3
   */
  dimensionCounts: {
    [key: string]: number;
  };
  /**
   * Number of bots in each game mode (e.g., "SURVIVAL" -> 10).
   *
   * @generated from protobuf field: map<string, uint32> game_mode_counts = 4
   */
  gameModeCounts: {
    [key: string]: number;
  };
  /**
   * XZ positions of online bots for scatter plot rendering.
   *
   * @generated from protobuf field: repeated soulfire.v1.BotPosition bot_positions = 5
   */
  botPositions: BotPosition[];
}
/**
 * Position of a single bot on the XZ plane.
 *
 * @generated from protobuf message soulfire.v1.BotPosition
 */
export interface BotPosition {
  /**
   * X coordinate in the Minecraft world.
   *
   * @generated from protobuf field: double x = 1
   */
  x: number;
  /**
   * Z coordinate in the Minecraft world.
   *
   * @generated from protobuf field: double z = 2
   */
  z: number;
  /**
   * Dimension the bot is in (e.g., "minecraft:overworld").
   *
   * @generated from protobuf field: string dimension = 3
   */
  dimension: string;
}
/**
 * Request to retrieve metrics for a specific instance.
 *
 * @generated from protobuf message soulfire.v1.GetInstanceMetricsRequest
 */
export interface GetInstanceMetricsRequest {
  /**
   * The UUID of the SoulFire instance to get metrics for.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * If set, only return snapshots taken after this timestamp.
   * Used for incremental fetching to reduce payload size.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp since = 2
   */
  since?: Timestamp;
}
/**
 * Response containing time-series metrics and current distributions.
 *
 * @generated from protobuf message soulfire.v1.GetInstanceMetricsResponse
 */
export interface GetInstanceMetricsResponse {
  /**
   * Time-series snapshots ordered oldest to newest.
   * Contains up to 600 snapshots (30 minutes at 3-second intervals).
   * If the request included a "since" timestamp, only newer snapshots are returned.
   *
   * @generated from protobuf field: repeated soulfire.v1.MetricsSnapshot snapshots = 1
   */
  snapshots: MetricsSnapshot[];
  /**
   * Current-state distributions computed from the latest bot data.
   *
   * @generated from protobuf field: soulfire.v1.MetricsDistributions distributions = 2
   */
  distributions?: MetricsDistributions;
}
/**
 * A single server-level system metrics data point sampled at a fixed interval.
 *
 * @generated from protobuf message soulfire.v1.ServerMetricsSnapshot
 */
export interface ServerMetricsSnapshot {
  /**
   * When this snapshot was taken.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 1
   */
  timestamp?: Timestamp;
  /**
   * JVM process CPU load (0.0 to 1.0, or -1.0 if unavailable).
   *
   * @generated from protobuf field: double process_cpu_load = 2
   */
  processCpuLoad: number;
  /**
   * System-wide CPU load (0.0 to 1.0, or -1.0 if unavailable).
   *
   * @generated from protobuf field: double system_cpu_load = 3
   */
  systemCpuLoad: number;
  /**
   * Heap memory currently used in bytes.
   *
   * @generated from protobuf field: uint64 heap_used_bytes = 4
   */
  heapUsedBytes: string;
  /**
   * Heap memory committed (reserved by JVM) in bytes.
   *
   * @generated from protobuf field: uint64 heap_committed_bytes = 5
   */
  heapCommittedBytes: string;
  /**
   * Maximum heap memory in bytes (-1 if undefined).
   *
   * @generated from protobuf field: int64 heap_max_bytes = 6
   */
  heapMaxBytes: string;
  /**
   * Non-heap memory currently used in bytes.
   *
   * @generated from protobuf field: uint64 non_heap_used_bytes = 7
   */
  nonHeapUsedBytes: string;
  /**
   * Current live thread count.
   *
   * @generated from protobuf field: uint32 thread_count = 8
   */
  threadCount: number;
  /**
   * Current daemon thread count.
   *
   * @generated from protobuf field: uint32 daemon_thread_count = 9
   */
  daemonThreadCount: number;
  /**
   * Cumulative GC collection count across all collectors.
   *
   * @generated from protobuf field: uint64 gc_collection_count = 10
   */
  gcCollectionCount: string;
  /**
   * Cumulative GC collection time in milliseconds across all collectors.
   *
   * @generated from protobuf field: uint64 gc_collection_time_ms = 11
   */
  gcCollectionTimeMs: string;
  /**
   * JVM uptime in milliseconds.
   *
   * @generated from protobuf field: uint64 uptime_ms = 12
   */
  uptimeMs: string;
  /**
   * Number of available processors.
   *
   * @generated from protobuf field: uint32 available_processors = 13
   */
  availableProcessors: number;
  /**
   * Total bots online across all instances.
   *
   * @generated from protobuf field: uint32 total_bots_online = 14
   */
  totalBotsOnline: number;
  /**
   * Total bots configured across all instances.
   *
   * @generated from protobuf field: uint32 total_bots_total = 15
   */
  totalBotsTotal: number;
  /**
   * Number of active (non-stopped) instances.
   *
   * @generated from protobuf field: uint32 active_instances = 16
   */
  activeInstances: number;
}
/**
 * Request to retrieve server-level system metrics.
 *
 * @generated from protobuf message soulfire.v1.GetServerMetricsRequest
 */
export interface GetServerMetricsRequest {
  /**
   * If set, only return snapshots taken after this timestamp.
   * Used for incremental fetching to reduce payload size.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp since = 1
   */
  since?: Timestamp;
}
/**
 * Response containing server-level system metrics time-series.
 *
 * @generated from protobuf message soulfire.v1.GetServerMetricsResponse
 */
export interface GetServerMetricsResponse {
  /**
   * Time-series snapshots ordered oldest to newest.
   * Contains up to 600 snapshots (30 minutes at 3-second intervals).
   *
   * @generated from protobuf field: repeated soulfire.v1.ServerMetricsSnapshot snapshots = 1
   */
  snapshots: ServerMetricsSnapshot[];
}
// @generated message type with reflection information, may provide speed optimized methods
class MetricsSnapshot$Type extends MessageType<MetricsSnapshot> {
  constructor() {
    super("soulfire.v1.MetricsSnapshot", [
      { no: 1, name: "timestamp", kind: "message", T: () => Timestamp },
      {
        no: 2,
        name: "bots_online",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "bots_total",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 4,
        name: "packets_sent_total",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 5,
        name: "packets_received_total",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 6,
        name: "bytes_sent_total",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 7,
        name: "bytes_received_total",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 8,
        name: "packets_sent_per_second",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 9,
        name: "packets_received_per_second",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 10,
        name: "bytes_sent_per_second",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 11,
        name: "bytes_received_per_second",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 12,
        name: "avg_tick_duration_ms",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 13,
        name: "max_tick_duration_ms",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 14,
        name: "avg_health",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 15,
        name: "avg_food_level",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 16,
        name: "total_loaded_chunks",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 17,
        name: "total_tracked_entities",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 18,
        name: "connections",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 19,
        name: "disconnections",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<MetricsSnapshot>): MetricsSnapshot {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.botsOnline = 0;
    message.botsTotal = 0;
    message.packetsSentTotal = "0";
    message.packetsReceivedTotal = "0";
    message.bytesSentTotal = "0";
    message.bytesReceivedTotal = "0";
    message.packetsSentPerSecond = 0;
    message.packetsReceivedPerSecond = 0;
    message.bytesSentPerSecond = 0;
    message.bytesReceivedPerSecond = 0;
    message.avgTickDurationMs = 0;
    message.maxTickDurationMs = 0;
    message.avgHealth = 0;
    message.avgFoodLevel = 0;
    message.totalLoadedChunks = 0;
    message.totalTrackedEntities = 0;
    message.connections = 0;
    message.disconnections = 0;
    if (value !== undefined)
      reflectionMergePartial<MetricsSnapshot>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MetricsSnapshot,
  ): MetricsSnapshot {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Timestamp timestamp */ 1:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        case /* uint32 bots_online */ 2:
          message.botsOnline = reader.uint32();
          break;
        case /* uint32 bots_total */ 3:
          message.botsTotal = reader.uint32();
          break;
        case /* uint64 packets_sent_total */ 4:
          message.packetsSentTotal = reader.uint64().toString();
          break;
        case /* uint64 packets_received_total */ 5:
          message.packetsReceivedTotal = reader.uint64().toString();
          break;
        case /* uint64 bytes_sent_total */ 6:
          message.bytesSentTotal = reader.uint64().toString();
          break;
        case /* uint64 bytes_received_total */ 7:
          message.bytesReceivedTotal = reader.uint64().toString();
          break;
        case /* double packets_sent_per_second */ 8:
          message.packetsSentPerSecond = reader.double();
          break;
        case /* double packets_received_per_second */ 9:
          message.packetsReceivedPerSecond = reader.double();
          break;
        case /* double bytes_sent_per_second */ 10:
          message.bytesSentPerSecond = reader.double();
          break;
        case /* double bytes_received_per_second */ 11:
          message.bytesReceivedPerSecond = reader.double();
          break;
        case /* double avg_tick_duration_ms */ 12:
          message.avgTickDurationMs = reader.double();
          break;
        case /* double max_tick_duration_ms */ 13:
          message.maxTickDurationMs = reader.double();
          break;
        case /* double avg_health */ 14:
          message.avgHealth = reader.double();
          break;
        case /* double avg_food_level */ 15:
          message.avgFoodLevel = reader.double();
          break;
        case /* uint32 total_loaded_chunks */ 16:
          message.totalLoadedChunks = reader.uint32();
          break;
        case /* uint32 total_tracked_entities */ 17:
          message.totalTrackedEntities = reader.uint32();
          break;
        case /* uint32 connections */ 18:
          message.connections = reader.uint32();
          break;
        case /* uint32 disconnections */ 19:
          message.disconnections = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: MetricsSnapshot,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.protobuf.Timestamp timestamp = 1; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* uint32 bots_online = 2; */
    if (message.botsOnline !== 0)
      writer.tag(2, WireType.Varint).uint32(message.botsOnline);
    /* uint32 bots_total = 3; */
    if (message.botsTotal !== 0)
      writer.tag(3, WireType.Varint).uint32(message.botsTotal);
    /* uint64 packets_sent_total = 4; */
    if (message.packetsSentTotal !== "0")
      writer.tag(4, WireType.Varint).uint64(message.packetsSentTotal);
    /* uint64 packets_received_total = 5; */
    if (message.packetsReceivedTotal !== "0")
      writer.tag(5, WireType.Varint).uint64(message.packetsReceivedTotal);
    /* uint64 bytes_sent_total = 6; */
    if (message.bytesSentTotal !== "0")
      writer.tag(6, WireType.Varint).uint64(message.bytesSentTotal);
    /* uint64 bytes_received_total = 7; */
    if (message.bytesReceivedTotal !== "0")
      writer.tag(7, WireType.Varint).uint64(message.bytesReceivedTotal);
    /* double packets_sent_per_second = 8; */
    if (message.packetsSentPerSecond !== 0)
      writer.tag(8, WireType.Bit64).double(message.packetsSentPerSecond);
    /* double packets_received_per_second = 9; */
    if (message.packetsReceivedPerSecond !== 0)
      writer.tag(9, WireType.Bit64).double(message.packetsReceivedPerSecond);
    /* double bytes_sent_per_second = 10; */
    if (message.bytesSentPerSecond !== 0)
      writer.tag(10, WireType.Bit64).double(message.bytesSentPerSecond);
    /* double bytes_received_per_second = 11; */
    if (message.bytesReceivedPerSecond !== 0)
      writer.tag(11, WireType.Bit64).double(message.bytesReceivedPerSecond);
    /* double avg_tick_duration_ms = 12; */
    if (message.avgTickDurationMs !== 0)
      writer.tag(12, WireType.Bit64).double(message.avgTickDurationMs);
    /* double max_tick_duration_ms = 13; */
    if (message.maxTickDurationMs !== 0)
      writer.tag(13, WireType.Bit64).double(message.maxTickDurationMs);
    /* double avg_health = 14; */
    if (message.avgHealth !== 0)
      writer.tag(14, WireType.Bit64).double(message.avgHealth);
    /* double avg_food_level = 15; */
    if (message.avgFoodLevel !== 0)
      writer.tag(15, WireType.Bit64).double(message.avgFoodLevel);
    /* uint32 total_loaded_chunks = 16; */
    if (message.totalLoadedChunks !== 0)
      writer.tag(16, WireType.Varint).uint32(message.totalLoadedChunks);
    /* uint32 total_tracked_entities = 17; */
    if (message.totalTrackedEntities !== 0)
      writer.tag(17, WireType.Varint).uint32(message.totalTrackedEntities);
    /* uint32 connections = 18; */
    if (message.connections !== 0)
      writer.tag(18, WireType.Varint).uint32(message.connections);
    /* uint32 disconnections = 19; */
    if (message.disconnections !== 0)
      writer.tag(19, WireType.Varint).uint32(message.disconnections);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MetricsSnapshot
 */
export const MetricsSnapshot = new MetricsSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MetricsDistributions$Type extends MessageType<MetricsDistributions> {
  constructor() {
    super("soulfire.v1.MetricsDistributions", [
      {
        no: 1,
        name: "health_histogram",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 2,
        name: "food_histogram",
        kind: "scalar",
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 3,
        name: "dimension_counts",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      },
      {
        no: 4,
        name: "game_mode_counts",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      },
      {
        no: 5,
        name: "bot_positions",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => BotPosition,
      },
    ]);
  }
  create(value?: PartialMessage<MetricsDistributions>): MetricsDistributions {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.healthHistogram = [];
    message.foodHistogram = [];
    message.dimensionCounts = {};
    message.gameModeCounts = {};
    message.botPositions = [];
    if (value !== undefined)
      reflectionMergePartial<MetricsDistributions>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: MetricsDistributions,
  ): MetricsDistributions {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated uint32 health_histogram */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.healthHistogram.push(reader.uint32());
          else message.healthHistogram.push(reader.uint32());
          break;
        case /* repeated uint32 food_histogram */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.foodHistogram.push(reader.uint32());
          else message.foodHistogram.push(reader.uint32());
          break;
        case /* map<string, uint32> dimension_counts */ 3:
          this.binaryReadMap3(message.dimensionCounts, reader, options);
          break;
        case /* map<string, uint32> game_mode_counts */ 4:
          this.binaryReadMap4(message.gameModeCounts, reader, options);
          break;
        case /* repeated soulfire.v1.BotPosition bot_positions */ 5:
          message.botPositions.push(
            BotPosition.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap3(
    map: MetricsDistributions["dimensionCounts"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof MetricsDistributions["dimensionCounts"] | undefined,
      val: MetricsDistributions["dimensionCounts"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.uint32();
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for soulfire.v1.MetricsDistributions.dimension_counts",
          );
      }
    }
    map[key ?? ""] = val ?? 0;
  }
  private binaryReadMap4(
    map: MetricsDistributions["gameModeCounts"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof MetricsDistributions["gameModeCounts"] | undefined,
      val: MetricsDistributions["gameModeCounts"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = reader.uint32();
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for soulfire.v1.MetricsDistributions.game_mode_counts",
          );
      }
    }
    map[key ?? ""] = val ?? 0;
  }
  internalBinaryWrite(
    message: MetricsDistributions,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated uint32 health_histogram = 1; */
    if (message.healthHistogram.length) {
      writer.tag(1, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.healthHistogram.length; i++)
        writer.uint32(message.healthHistogram[i]);
      writer.join();
    }
    /* repeated uint32 food_histogram = 2; */
    if (message.foodHistogram.length) {
      writer.tag(2, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.foodHistogram.length; i++)
        writer.uint32(message.foodHistogram[i]);
      writer.join();
    }
    /* map<string, uint32> dimension_counts = 3; */
    for (let k of globalThis.Object.keys(message.dimensionCounts))
      writer
        .tag(3, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.Varint)
        .uint32(message.dimensionCounts[k])
        .join();
    /* map<string, uint32> game_mode_counts = 4; */
    for (let k of globalThis.Object.keys(message.gameModeCounts))
      writer
        .tag(4, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k)
        .tag(2, WireType.Varint)
        .uint32(message.gameModeCounts[k])
        .join();
    /* repeated soulfire.v1.BotPosition bot_positions = 5; */
    for (let i = 0; i < message.botPositions.length; i++)
      BotPosition.internalBinaryWrite(
        message.botPositions[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.MetricsDistributions
 */
export const MetricsDistributions = new MetricsDistributions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BotPosition$Type extends MessageType<BotPosition> {
  constructor() {
    super("soulfire.v1.BotPosition", [
      { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 2, name: "z", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 3, name: "dimension", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<BotPosition>): BotPosition {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.x = 0;
    message.z = 0;
    message.dimension = "";
    if (value !== undefined)
      reflectionMergePartial<BotPosition>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BotPosition,
  ): BotPosition {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double x */ 1:
          message.x = reader.double();
          break;
        case /* double z */ 2:
          message.z = reader.double();
          break;
        case /* string dimension */ 3:
          message.dimension = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BotPosition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double x = 1; */
    if (message.x !== 0) writer.tag(1, WireType.Bit64).double(message.x);
    /* double z = 2; */
    if (message.z !== 0) writer.tag(2, WireType.Bit64).double(message.z);
    /* string dimension = 3; */
    if (message.dimension !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.dimension);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.BotPosition
 */
export const BotPosition = new BotPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInstanceMetricsRequest$Type extends MessageType<GetInstanceMetricsRequest> {
  constructor() {
    super("soulfire.v1.GetInstanceMetricsRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "since", kind: "message", T: () => Timestamp },
    ]);
  }
  create(
    value?: PartialMessage<GetInstanceMetricsRequest>,
  ): GetInstanceMetricsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    if (value !== undefined)
      reflectionMergePartial<GetInstanceMetricsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetInstanceMetricsRequest,
  ): GetInstanceMetricsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* optional google.protobuf.Timestamp since */ 2:
          message.since = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.since,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetInstanceMetricsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* optional google.protobuf.Timestamp since = 2; */
    if (message.since)
      Timestamp.internalBinaryWrite(
        message.since,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetInstanceMetricsRequest
 */
export const GetInstanceMetricsRequest = new GetInstanceMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInstanceMetricsResponse$Type extends MessageType<GetInstanceMetricsResponse> {
  constructor() {
    super("soulfire.v1.GetInstanceMetricsResponse", [
      {
        no: 1,
        name: "snapshots",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => MetricsSnapshot,
      },
      {
        no: 2,
        name: "distributions",
        kind: "message",
        T: () => MetricsDistributions,
      },
    ]);
  }
  create(
    value?: PartialMessage<GetInstanceMetricsResponse>,
  ): GetInstanceMetricsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.snapshots = [];
    if (value !== undefined)
      reflectionMergePartial<GetInstanceMetricsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetInstanceMetricsResponse,
  ): GetInstanceMetricsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.MetricsSnapshot snapshots */ 1:
          message.snapshots.push(
            MetricsSnapshot.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* soulfire.v1.MetricsDistributions distributions */ 2:
          message.distributions = MetricsDistributions.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.distributions,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetInstanceMetricsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.MetricsSnapshot snapshots = 1; */
    for (let i = 0; i < message.snapshots.length; i++)
      MetricsSnapshot.internalBinaryWrite(
        message.snapshots[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.MetricsDistributions distributions = 2; */
    if (message.distributions)
      MetricsDistributions.internalBinaryWrite(
        message.distributions,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetInstanceMetricsResponse
 */
export const GetInstanceMetricsResponse = new GetInstanceMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerMetricsSnapshot$Type extends MessageType<ServerMetricsSnapshot> {
  constructor() {
    super("soulfire.v1.ServerMetricsSnapshot", [
      { no: 1, name: "timestamp", kind: "message", T: () => Timestamp },
      {
        no: 2,
        name: "process_cpu_load",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 3,
        name: "system_cpu_load",
        kind: "scalar",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 4,
        name: "heap_used_bytes",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 5,
        name: "heap_committed_bytes",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 6,
        name: "heap_max_bytes",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
      },
      {
        no: 7,
        name: "non_heap_used_bytes",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 8,
        name: "thread_count",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 9,
        name: "daemon_thread_count",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 10,
        name: "gc_collection_count",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      {
        no: 11,
        name: "gc_collection_time_ms",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
      },
      { no: 12, name: "uptime_ms", kind: "scalar", T: 4 /*ScalarType.UINT64*/ },
      {
        no: 13,
        name: "available_processors",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 14,
        name: "total_bots_online",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 15,
        name: "total_bots_total",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
      {
        no: 16,
        name: "active_instances",
        kind: "scalar",
        T: 13 /*ScalarType.UINT32*/,
      },
    ]);
  }
  create(value?: PartialMessage<ServerMetricsSnapshot>): ServerMetricsSnapshot {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.processCpuLoad = 0;
    message.systemCpuLoad = 0;
    message.heapUsedBytes = "0";
    message.heapCommittedBytes = "0";
    message.heapMaxBytes = "0";
    message.nonHeapUsedBytes = "0";
    message.threadCount = 0;
    message.daemonThreadCount = 0;
    message.gcCollectionCount = "0";
    message.gcCollectionTimeMs = "0";
    message.uptimeMs = "0";
    message.availableProcessors = 0;
    message.totalBotsOnline = 0;
    message.totalBotsTotal = 0;
    message.activeInstances = 0;
    if (value !== undefined)
      reflectionMergePartial<ServerMetricsSnapshot>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServerMetricsSnapshot,
  ): ServerMetricsSnapshot {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* google.protobuf.Timestamp timestamp */ 1:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        case /* double process_cpu_load */ 2:
          message.processCpuLoad = reader.double();
          break;
        case /* double system_cpu_load */ 3:
          message.systemCpuLoad = reader.double();
          break;
        case /* uint64 heap_used_bytes */ 4:
          message.heapUsedBytes = reader.uint64().toString();
          break;
        case /* uint64 heap_committed_bytes */ 5:
          message.heapCommittedBytes = reader.uint64().toString();
          break;
        case /* int64 heap_max_bytes */ 6:
          message.heapMaxBytes = reader.int64().toString();
          break;
        case /* uint64 non_heap_used_bytes */ 7:
          message.nonHeapUsedBytes = reader.uint64().toString();
          break;
        case /* uint32 thread_count */ 8:
          message.threadCount = reader.uint32();
          break;
        case /* uint32 daemon_thread_count */ 9:
          message.daemonThreadCount = reader.uint32();
          break;
        case /* uint64 gc_collection_count */ 10:
          message.gcCollectionCount = reader.uint64().toString();
          break;
        case /* uint64 gc_collection_time_ms */ 11:
          message.gcCollectionTimeMs = reader.uint64().toString();
          break;
        case /* uint64 uptime_ms */ 12:
          message.uptimeMs = reader.uint64().toString();
          break;
        case /* uint32 available_processors */ 13:
          message.availableProcessors = reader.uint32();
          break;
        case /* uint32 total_bots_online */ 14:
          message.totalBotsOnline = reader.uint32();
          break;
        case /* uint32 total_bots_total */ 15:
          message.totalBotsTotal = reader.uint32();
          break;
        case /* uint32 active_instances */ 16:
          message.activeInstances = reader.uint32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ServerMetricsSnapshot,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* google.protobuf.Timestamp timestamp = 1; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* double process_cpu_load = 2; */
    if (message.processCpuLoad !== 0)
      writer.tag(2, WireType.Bit64).double(message.processCpuLoad);
    /* double system_cpu_load = 3; */
    if (message.systemCpuLoad !== 0)
      writer.tag(3, WireType.Bit64).double(message.systemCpuLoad);
    /* uint64 heap_used_bytes = 4; */
    if (message.heapUsedBytes !== "0")
      writer.tag(4, WireType.Varint).uint64(message.heapUsedBytes);
    /* uint64 heap_committed_bytes = 5; */
    if (message.heapCommittedBytes !== "0")
      writer.tag(5, WireType.Varint).uint64(message.heapCommittedBytes);
    /* int64 heap_max_bytes = 6; */
    if (message.heapMaxBytes !== "0")
      writer.tag(6, WireType.Varint).int64(message.heapMaxBytes);
    /* uint64 non_heap_used_bytes = 7; */
    if (message.nonHeapUsedBytes !== "0")
      writer.tag(7, WireType.Varint).uint64(message.nonHeapUsedBytes);
    /* uint32 thread_count = 8; */
    if (message.threadCount !== 0)
      writer.tag(8, WireType.Varint).uint32(message.threadCount);
    /* uint32 daemon_thread_count = 9; */
    if (message.daemonThreadCount !== 0)
      writer.tag(9, WireType.Varint).uint32(message.daemonThreadCount);
    /* uint64 gc_collection_count = 10; */
    if (message.gcCollectionCount !== "0")
      writer.tag(10, WireType.Varint).uint64(message.gcCollectionCount);
    /* uint64 gc_collection_time_ms = 11; */
    if (message.gcCollectionTimeMs !== "0")
      writer.tag(11, WireType.Varint).uint64(message.gcCollectionTimeMs);
    /* uint64 uptime_ms = 12; */
    if (message.uptimeMs !== "0")
      writer.tag(12, WireType.Varint).uint64(message.uptimeMs);
    /* uint32 available_processors = 13; */
    if (message.availableProcessors !== 0)
      writer.tag(13, WireType.Varint).uint32(message.availableProcessors);
    /* uint32 total_bots_online = 14; */
    if (message.totalBotsOnline !== 0)
      writer.tag(14, WireType.Varint).uint32(message.totalBotsOnline);
    /* uint32 total_bots_total = 15; */
    if (message.totalBotsTotal !== 0)
      writer.tag(15, WireType.Varint).uint32(message.totalBotsTotal);
    /* uint32 active_instances = 16; */
    if (message.activeInstances !== 0)
      writer.tag(16, WireType.Varint).uint32(message.activeInstances);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ServerMetricsSnapshot
 */
export const ServerMetricsSnapshot = new ServerMetricsSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServerMetricsRequest$Type extends MessageType<GetServerMetricsRequest> {
  constructor() {
    super("soulfire.v1.GetServerMetricsRequest", [
      { no: 1, name: "since", kind: "message", T: () => Timestamp },
    ]);
  }
  create(
    value?: PartialMessage<GetServerMetricsRequest>,
  ): GetServerMetricsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<GetServerMetricsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetServerMetricsRequest,
  ): GetServerMetricsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional google.protobuf.Timestamp since */ 1:
          message.since = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.since,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetServerMetricsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional google.protobuf.Timestamp since = 1; */
    if (message.since)
      Timestamp.internalBinaryWrite(
        message.since,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetServerMetricsRequest
 */
export const GetServerMetricsRequest = new GetServerMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServerMetricsResponse$Type extends MessageType<GetServerMetricsResponse> {
  constructor() {
    super("soulfire.v1.GetServerMetricsResponse", [
      {
        no: 1,
        name: "snapshots",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ServerMetricsSnapshot,
      },
    ]);
  }
  create(
    value?: PartialMessage<GetServerMetricsResponse>,
  ): GetServerMetricsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.snapshots = [];
    if (value !== undefined)
      reflectionMergePartial<GetServerMetricsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetServerMetricsResponse,
  ): GetServerMetricsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.ServerMetricsSnapshot snapshots */ 1:
          message.snapshots.push(
            ServerMetricsSnapshot.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetServerMetricsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.ServerMetricsSnapshot snapshots = 1; */
    for (let i = 0; i < message.snapshots.length; i++)
      ServerMetricsSnapshot.internalBinaryWrite(
        message.snapshots[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetServerMetricsResponse
 */
export const GetServerMetricsResponse = new GetServerMetricsResponse$Type();
/**
 * @generated ServiceType for protobuf service soulfire.v1.MetricsService
 */
export const MetricsService = new ServiceType("soulfire.v1.MetricsService", [
  {
    name: "GetInstanceMetrics",
    options: {},
    I: GetInstanceMetricsRequest,
    O: GetInstanceMetricsResponse,
  },
  {
    name: "GetServerMetrics",
    options: {},
    I: GetServerMetricsRequest,
    O: GetServerMetricsResponse,
  },
]);
