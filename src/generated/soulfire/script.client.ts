/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,optimize_code_size,eslint_disable,ts_nocheck
// @generated from protobuf file "soulfire/script.proto" (package "soulfire.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import type {
  RpcOptions,
  RpcTransport,
  ServerStreamingCall,
  ServiceInfo,
  UnaryCall,
} from "@protobuf-ts/runtime-rpc";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type {
  ActivateScriptRequest,
  CreateScriptRequest,
  CreateScriptResponse,
  DeactivateScriptRequest,
  DeactivateScriptResponse,
  DeleteScriptRequest,
  DeleteScriptResponse,
  GetNodeTypesRequest,
  GetNodeTypesResponse,
  GetRegistryDataRequest,
  GetRegistryDataResponse,
  GetScriptRequest,
  GetScriptResponse,
  GetScriptStatusRequest,
  GetScriptStatusResponse,
  ListScriptsRequest,
  ListScriptsResponse,
  ScriptEvent,
  ScriptLogEntry,
  SubscribeScriptLogsRequest,
  UpdateScriptRequest,
  UpdateScriptResponse,
} from "./script";
import { ScriptService } from "./script";
/**
 * ScriptService provides management and execution capabilities for visual node-based
 * automation scripts within SoulFire.
 *
 * The visual scripting system allows users to create automation workflows by connecting
 * nodes in a graph. Each node represents an action, condition, or event trigger.
 * Nodes are connected by edges that define execution flow and data transfer.
 *
 * SCRIPT LIFECYCLE (Pause-based model):
 * - Scripts run by default when created and on server startup
 * - Scripts can be paused to stop execution
 * - Paused scripts don't start on server startup
 * - Saving a non-paused script restarts it with the new configuration
 * - Scripts run even when the instance is stopped
 *
 * 1. Create a script using CreateScript - runs immediately unless paused=true
 * 2. Edit using UpdateScript - restarts automatically if not paused
 * 3. Pause using PauseScript to stop execution
 * 4. Resume using ResumeScript to restart execution
 * 5. Monitor via SubscribeScriptEvents or GetScriptStatus
 * 6. Delete with DeleteScript (stops script first if running)
 *
 * Scripts are reactive state machines - they listen for trigger events and
 * execute node chains in response. They remain active until explicitly paused.
 *
 * PERMISSIONS: Script operations require appropriate instance permissions.
 * The specific permissions are TBD but will likely include:
 * - READ_SCRIPT: View script definitions and status
 * - UPDATE_SCRIPT: Create, modify, and delete scripts
 * - EXECUTE_SCRIPT: Pause and resume scripts
 *
 * LOGGING: Script execution logs can be streamed via SubscribeScriptLogs or
 * filtered using InstanceScriptLogScope in the LogsService (see logs.proto).
 *
 * @generated from protobuf service soulfire.v1.ScriptService
 */
export interface IScriptServiceClient {
  /**
   * Creates a new script in the specified instance.
   * The script can be created with initial nodes and edges, or as a blank script
   * to be edited later.
   * Returns: The complete script data including the generated ID
   * Errors: NOT_FOUND if instance does not exist
   * Errors: PERMISSION_DENIED if user lacks script creation permission
   * Errors: INVALID_ARGUMENT if required fields are missing or invalid
   *
   * @generated from protobuf rpc: CreateScript
   */
  createScript(
    input: CreateScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<CreateScriptRequest, CreateScriptResponse>;
  /**
   * Retrieves a specific script by its ID.
   * Returns the complete script data including all nodes and edges.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script read permission
   *
   * @generated from protobuf rpc: GetScript
   */
  getScript(
    input: GetScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<GetScriptRequest, GetScriptResponse>;
  /**
   * Updates an existing script's metadata and/or node graph.
   * Only specified fields are updated; others remain unchanged.
   * Use update_nodes/update_edges flags to explicitly set empty lists.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script update permission
   * Errors: INVALID_ARGUMENT if update data is invalid
   *
   * @generated from protobuf rpc: UpdateScript
   */
  updateScript(
    input: UpdateScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<UpdateScriptRequest, UpdateScriptResponse>;
  /**
   * Permanently deletes a script.
   * If the script is currently active, it will be deactivated first.
   * This operation cannot be undone.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script delete permission
   *
   * @generated from protobuf rpc: DeleteScript
   */
  deleteScript(
    input: DeleteScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<DeleteScriptRequest, DeleteScriptResponse>;
  /**
   * Lists all scripts in the specified instance.
   * Returns summary information (ScriptInfo) without full node/edge data
   * to reduce response size.
   * Errors: NOT_FOUND if instance does not exist
   * Errors: PERMISSION_DENIED if user lacks script read permission
   *
   * @generated from protobuf rpc: ListScripts
   */
  listScripts(
    input: ListScriptsRequest,
    options?: RpcOptions,
  ): UnaryCall<ListScriptsRequest, ListScriptsResponse>;
  /**
   * Resumes a paused script (or subscribes to events of a running script).
   * Clears the paused flag and starts the script if it was paused.
   * Returns a stream of execution events as triggers fire and nodes execute.
   * The stream remains open until the script is paused or client disconnects.
   * Note: Client disconnect does NOT pause the script - it keeps running.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script execution permission
   * Errors: INVALID_ARGUMENT if script graph is invalid (e.g., no trigger nodes)
   *
   * @generated from protobuf rpc: ActivateScript
   */
  activateScript(
    input: ActivateScriptRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<ActivateScriptRequest, ScriptEvent>;
  /**
   * Pauses a running script.
   * Sets the paused flag and stops all event listeners.
   * Paused scripts don't start on server startup or when updated.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script execution permission
   *
   * @generated from protobuf rpc: DeactivateScript
   */
  deactivateScript(
    input: DeactivateScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<DeactivateScriptRequest, DeactivateScriptResponse>;
  /**
   * Gets the current status of a script.
   * Returns whether the script is active, which node is executing, and activation count.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script read permission
   *
   * @generated from protobuf rpc: GetScriptStatus
   */
  getScriptStatus(
    input: GetScriptStatusRequest,
    options?: RpcOptions,
  ): UnaryCall<GetScriptStatusRequest, GetScriptStatusResponse>;
  /**
   * Subscribes to log entries generated during script execution.
   * Returns a stream of log entries at or above the specified minimum level.
   * The stream remains open until cancelled by the client.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script log subscription permission
   *
   * @generated from protobuf rpc: SubscribeScriptLogs
   */
  subscribeScriptLogs(
    input: SubscribeScriptLogsRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SubscribeScriptLogsRequest, ScriptLogEntry>;
  /**
   * Gets all available node types with their metadata.
   * This enables clients to render the node editor without hardcoded knowledge
   * of specific node types. The response includes port definitions, categories,
   * display names, and all other information needed to render and validate nodes.
   * This endpoint is cacheable - node types only change between server versions.
   *
   * @generated from protobuf rpc: GetNodeTypes
   */
  getNodeTypes(
    input: GetNodeTypesRequest,
    options?: RpcOptions,
  ): UnaryCall<GetNodeTypesRequest, GetNodeTypesResponse>;
  /**
   * Gets Minecraft registry data for autocomplete and validation.
   * Returns blocks, entities, items, and biomes that can be used in scripts.
   * This endpoint is cacheable - registry data only changes between server versions.
   *
   * @generated from protobuf rpc: GetRegistryData
   */
  getRegistryData(
    input: GetRegistryDataRequest,
    options?: RpcOptions,
  ): UnaryCall<GetRegistryDataRequest, GetRegistryDataResponse>;
}
/**
 * ScriptService provides management and execution capabilities for visual node-based
 * automation scripts within SoulFire.
 *
 * The visual scripting system allows users to create automation workflows by connecting
 * nodes in a graph. Each node represents an action, condition, or event trigger.
 * Nodes are connected by edges that define execution flow and data transfer.
 *
 * SCRIPT LIFECYCLE (Pause-based model):
 * - Scripts run by default when created and on server startup
 * - Scripts can be paused to stop execution
 * - Paused scripts don't start on server startup
 * - Saving a non-paused script restarts it with the new configuration
 * - Scripts run even when the instance is stopped
 *
 * 1. Create a script using CreateScript - runs immediately unless paused=true
 * 2. Edit using UpdateScript - restarts automatically if not paused
 * 3. Pause using PauseScript to stop execution
 * 4. Resume using ResumeScript to restart execution
 * 5. Monitor via SubscribeScriptEvents or GetScriptStatus
 * 6. Delete with DeleteScript (stops script first if running)
 *
 * Scripts are reactive state machines - they listen for trigger events and
 * execute node chains in response. They remain active until explicitly paused.
 *
 * PERMISSIONS: Script operations require appropriate instance permissions.
 * The specific permissions are TBD but will likely include:
 * - READ_SCRIPT: View script definitions and status
 * - UPDATE_SCRIPT: Create, modify, and delete scripts
 * - EXECUTE_SCRIPT: Pause and resume scripts
 *
 * LOGGING: Script execution logs can be streamed via SubscribeScriptLogs or
 * filtered using InstanceScriptLogScope in the LogsService (see logs.proto).
 *
 * @generated from protobuf service soulfire.v1.ScriptService
 */
export class ScriptServiceClient implements IScriptServiceClient, ServiceInfo {
  typeName = ScriptService.typeName;
  methods = ScriptService.methods;
  options = ScriptService.options;
  constructor(private readonly _transport: RpcTransport) {}
  /**
   * Creates a new script in the specified instance.
   * The script can be created with initial nodes and edges, or as a blank script
   * to be edited later.
   * Returns: The complete script data including the generated ID
   * Errors: NOT_FOUND if instance does not exist
   * Errors: PERMISSION_DENIED if user lacks script creation permission
   * Errors: INVALID_ARGUMENT if required fields are missing or invalid
   *
   * @generated from protobuf rpc: CreateScript
   */
  createScript(
    input: CreateScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<CreateScriptRequest, CreateScriptResponse> {
    const method = this.methods[0],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<CreateScriptRequest, CreateScriptResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Retrieves a specific script by its ID.
   * Returns the complete script data including all nodes and edges.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script read permission
   *
   * @generated from protobuf rpc: GetScript
   */
  getScript(
    input: GetScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<GetScriptRequest, GetScriptResponse> {
    const method = this.methods[1],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<GetScriptRequest, GetScriptResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Updates an existing script's metadata and/or node graph.
   * Only specified fields are updated; others remain unchanged.
   * Use update_nodes/update_edges flags to explicitly set empty lists.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script update permission
   * Errors: INVALID_ARGUMENT if update data is invalid
   *
   * @generated from protobuf rpc: UpdateScript
   */
  updateScript(
    input: UpdateScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<UpdateScriptRequest, UpdateScriptResponse> {
    const method = this.methods[2],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<UpdateScriptRequest, UpdateScriptResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Permanently deletes a script.
   * If the script is currently active, it will be deactivated first.
   * This operation cannot be undone.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script delete permission
   *
   * @generated from protobuf rpc: DeleteScript
   */
  deleteScript(
    input: DeleteScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<DeleteScriptRequest, DeleteScriptResponse> {
    const method = this.methods[3],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<DeleteScriptRequest, DeleteScriptResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Lists all scripts in the specified instance.
   * Returns summary information (ScriptInfo) without full node/edge data
   * to reduce response size.
   * Errors: NOT_FOUND if instance does not exist
   * Errors: PERMISSION_DENIED if user lacks script read permission
   *
   * @generated from protobuf rpc: ListScripts
   */
  listScripts(
    input: ListScriptsRequest,
    options?: RpcOptions,
  ): UnaryCall<ListScriptsRequest, ListScriptsResponse> {
    const method = this.methods[4],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<ListScriptsRequest, ListScriptsResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Resumes a paused script (or subscribes to events of a running script).
   * Clears the paused flag and starts the script if it was paused.
   * Returns a stream of execution events as triggers fire and nodes execute.
   * The stream remains open until the script is paused or client disconnects.
   * Note: Client disconnect does NOT pause the script - it keeps running.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script execution permission
   * Errors: INVALID_ARGUMENT if script graph is invalid (e.g., no trigger nodes)
   *
   * @generated from protobuf rpc: ActivateScript
   */
  activateScript(
    input: ActivateScriptRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<ActivateScriptRequest, ScriptEvent> {
    const method = this.methods[5],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<ActivateScriptRequest, ScriptEvent>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Pauses a running script.
   * Sets the paused flag and stops all event listeners.
   * Paused scripts don't start on server startup or when updated.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script execution permission
   *
   * @generated from protobuf rpc: DeactivateScript
   */
  deactivateScript(
    input: DeactivateScriptRequest,
    options?: RpcOptions,
  ): UnaryCall<DeactivateScriptRequest, DeactivateScriptResponse> {
    const method = this.methods[6],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<DeactivateScriptRequest, DeactivateScriptResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Gets the current status of a script.
   * Returns whether the script is active, which node is executing, and activation count.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script read permission
   *
   * @generated from protobuf rpc: GetScriptStatus
   */
  getScriptStatus(
    input: GetScriptStatusRequest,
    options?: RpcOptions,
  ): UnaryCall<GetScriptStatusRequest, GetScriptStatusResponse> {
    const method = this.methods[7],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<GetScriptStatusRequest, GetScriptStatusResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Subscribes to log entries generated during script execution.
   * Returns a stream of log entries at or above the specified minimum level.
   * The stream remains open until cancelled by the client.
   * Errors: NOT_FOUND if instance or script does not exist
   * Errors: PERMISSION_DENIED if user lacks script log subscription permission
   *
   * @generated from protobuf rpc: SubscribeScriptLogs
   */
  subscribeScriptLogs(
    input: SubscribeScriptLogsRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SubscribeScriptLogsRequest, ScriptLogEntry> {
    const method = this.methods[8],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<SubscribeScriptLogsRequest, ScriptLogEntry>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Gets all available node types with their metadata.
   * This enables clients to render the node editor without hardcoded knowledge
   * of specific node types. The response includes port definitions, categories,
   * display names, and all other information needed to render and validate nodes.
   * This endpoint is cacheable - node types only change between server versions.
   *
   * @generated from protobuf rpc: GetNodeTypes
   */
  getNodeTypes(
    input: GetNodeTypesRequest,
    options?: RpcOptions,
  ): UnaryCall<GetNodeTypesRequest, GetNodeTypesResponse> {
    const method = this.methods[9],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<GetNodeTypesRequest, GetNodeTypesResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
  /**
   * Gets Minecraft registry data for autocomplete and validation.
   * Returns blocks, entities, items, and biomes that can be used in scripts.
   * This endpoint is cacheable - registry data only changes between server versions.
   *
   * @generated from protobuf rpc: GetRegistryData
   */
  getRegistryData(
    input: GetRegistryDataRequest,
    options?: RpcOptions,
  ): UnaryCall<GetRegistryDataRequest, GetRegistryDataResponse> {
    const method = this.methods[10],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<GetRegistryDataRequest, GetRegistryDataResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    );
  }
}
