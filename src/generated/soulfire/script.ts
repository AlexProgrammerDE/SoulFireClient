/* eslint-disable */
// @generated by protobuf-ts 2.11.1 with parameter long_type_string,optimize_code_size,eslint_disable,ts_nocheck
// @generated from protobuf file "soulfire/script.proto" (package "soulfire.v1", syntax proto3)
// tslint:disable
// @ts-nocheck

import type {
  BinaryReadOptions,
  BinaryWriteOptions,
  IBinaryReader,
  IBinaryWriter,
  PartialMessage,
} from "@protobuf-ts/runtime";
import {
  MessageType,
  reflectionMergePartial,
  UnknownFieldHandler,
  WireType,
} from "@protobuf-ts/runtime";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { Value } from "../google/protobuf/struct";
import { Timestamp } from "../google/protobuf/timestamp";
/**
 * Represents the 2D position of a node in the visual script editor canvas.
 * Used for rendering the node graph and preserving user layout preferences.
 *
 * @generated from protobuf message soulfire.v1.Position
 */
export interface Position {
  /**
   * The horizontal position in canvas coordinates.
   * Positive values extend to the right.
   *
   * @generated from protobuf field: double x = 1
   */
  x: number;
  /**
   * The vertical position in canvas coordinates.
   * Positive values extend downward.
   *
   * @generated from protobuf field: double y = 2
   */
  y: number;
}
/**
 * Definition of a port (input or output) on a node type.
 * Describes the port's type, constraints, and display properties.
 *
 * @generated from protobuf message soulfire.v1.PortDefinition
 */
export interface PortDefinition {
  /**
   * The identifier for this port.
   * Used in edge connections (source_handle/target_handle).
   * Examples: "value", "target", "bot", "exec_in", "exec_out".
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Human-readable name displayed in the UI.
   * Examples: "Target Position", "Bot", "Message".
   *
   * @generated from protobuf field: string display_name = 2
   */
  displayName: string;
  /**
   * The data type this port accepts or produces.
   *
   * @generated from protobuf field: soulfire.v1.PortType port_type = 3
   */
  portType: PortType;
  /**
   * Whether this input is required for the node to execute.
   * Only applicable for input ports.
   *
   * @generated from protobuf field: bool required = 4
   */
  required: boolean;
  /**
   * Default value for this port when not connected (JSON-encoded).
   * Only applicable for input ports.
   *
   * @generated from protobuf field: optional string default_value = 5
   */
  defaultValue?: string;
  /**
   * Optional description explaining what this port is for.
   *
   * @generated from protobuf field: string description = 6
   */
  description: string;
  /**
   * For list ports, the type of elements in the list.
   * Only applicable when port_type is PORT_TYPE_LIST.
   *
   * @generated from protobuf field: optional soulfire.v1.PortType element_type = 7
   */
  elementType?: PortType;
  /**
   * Whether this input accepts multiple connections (Blender-style multi-input).
   * When true, all connected values are collected into a list.
   * Visually rendered as a pill/ellipsis shaped socket.
   *
   * @generated from protobuf field: bool multi_input = 8
   */
  multiInput: boolean;
  /**
   * For polymorphic ports, the list of accepted types.
   * If non-empty, this port can accept any of these types and will
   * adapt its behavior based on the connected type.
   *
   * @generated from protobuf field: repeated soulfire.v1.PortType accepted_types = 9
   */
  acceptedTypes: PortType[];
  /**
   * For dynamic output ports, the ID of the input port to inherit type from.
   * Used for polymorphic nodes where output type depends on input type.
   *
   * @generated from protobuf field: string infer_type_from = 10
   */
  inferTypeFrom: string;
}
/**
 * Complete definition of a node type.
 * Contains all metadata needed to render the node in an editor
 * and validate its connections without hardcoded client knowledge.
 *
 * @generated from protobuf message soulfire.v1.NodeTypeDefinition
 */
export interface NodeTypeDefinition {
  /**
   * The unique type identifier for this node.
   * Examples: "trigger.on_tick", "action.pathfind", "math.add".
   *
   * @generated from protobuf field: string type = 1
   */
  type: string;
  /**
   * Human-readable name displayed in the UI.
   * Examples: "On Tick", "Pathfind To", "Add".
   *
   * @generated from protobuf field: string display_name = 2
   */
  displayName: string;
  /**
   * Description of what this node does.
   * Displayed in tooltips and node palettes.
   *
   * @generated from protobuf field: string description = 3
   */
  description: string;
  /**
   * Category ID for organizing nodes in the palette.
   * References CategoryDefinition.id from GetNodeTypesResponse.
   * Examples: "triggers", "actions", "math", "logic", "flow".
   *
   * @generated from protobuf field: string category = 4
   */
  category: string;
  /**
   * Whether this is a trigger node (entry point for execution).
   * Trigger nodes have no execution input and start script flows.
   *
   * @generated from protobuf field: bool is_trigger = 5
   */
  isTrigger: boolean;
  /**
   * The input ports for this node type.
   * Includes both data inputs and execution inputs.
   *
   * @generated from protobuf field: repeated soulfire.v1.PortDefinition inputs = 6
   */
  inputs: PortDefinition[];
  /**
   * The output ports for this node type.
   * Includes both data outputs and execution outputs.
   *
   * @generated from protobuf field: repeated soulfire.v1.PortDefinition outputs = 7
   */
  outputs: PortDefinition[];
  /**
   * Optional icon identifier for rendering.
   * Can be an icon name or emoji.
   *
   * @generated from protobuf field: string icon = 8
   */
  icon: string;
  /**
   * Optional color hint for the node (hex color code).
   * Used for visual distinction between node categories.
   *
   * @generated from protobuf field: string color = 9
   */
  color: string;
  /**
   * Keywords for searching/filtering nodes in the palette.
   *
   * @generated from protobuf field: repeated string keywords = 10
   */
  keywords: string[];
  /**
   * Whether this node is deprecated and should be avoided.
   *
   * @generated from protobuf field: bool deprecated = 11
   */
  deprecated: boolean;
  /**
   * If deprecated, message explaining what to use instead.
   *
   * @generated from protobuf field: string deprecation_message = 12
   */
  deprecationMessage: string;
  /**
   * Whether this is a layout node (reroute, frame, etc.).
   * Layout nodes have special minimal rendering and don't execute logic.
   *
   * @generated from protobuf field: bool is_layout_node = 13
   */
  isLayoutNode: boolean;
  /**
   * Whether this node can be muted (bypassed during execution).
   * When muted, inputs pass through to outputs unchanged.
   *
   * @generated from protobuf field: bool supports_muting = 14
   */
  supportsMuting: boolean;
  /**
   * Whether this node supports inline preview of its output.
   *
   * @generated from protobuf field: bool supports_preview = 15
   */
  supportsPreview: boolean;
  /**
   * Whether this node is expensive (slow, may block).
   * Used for visual warnings in tick-path analysis.
   *
   * @generated from protobuf field: bool is_expensive = 16
   */
  isExpensive: boolean;
}
/**
 * Represents a single node in the visual script graph.
 * Nodes are the building blocks of scripts, each performing a specific action
 * or computation when executed.
 *
 * @generated from protobuf message soulfire.v1.ScriptNode
 */
export interface ScriptNode {
  /**
   * Unique identifier for this node within the script.
   * Used to reference this node in edges and during execution tracking.
   * Format: UUID string.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * The type identifier for this node, determining its behavior and available ports.
   * Examples: "trigger.on_chat", "action.send_message", "control.delay", "logic.condition".
   *
   * @generated from protobuf field: string type = 2
   */
  type: string;
  /**
   * The visual position of this node on the editor canvas.
   * Persisted to maintain the user's layout when reopening the script.
   *
   * @generated from protobuf field: soulfire.v1.Position position = 3
   */
  position?: Position;
  /**
   * Configuration data for this node instance.
   * Contains node-specific settings and parameter values.
   * The structure depends on the node type.
   *
   * @generated from protobuf field: map<string, google.protobuf.Value> data = 4
   */
  data: {
    [key: string]: Value;
  };
  /**
   * Whether this node is muted (bypassed during execution).
   * When muted, the node passes inputs directly to outputs without processing.
   * Visually shown as grayed out with pass-through indicator.
   *
   * @generated from protobuf field: bool muted = 5
   */
  muted: boolean;
  /**
   * Whether this node is collapsed (showing only header).
   * Collapsed nodes still function normally but take less visual space.
   *
   * @generated from protobuf field: bool collapsed = 6
   */
  collapsed: boolean;
  /**
   * For frame nodes: the width of the frame.
   *
   * @generated from protobuf field: optional double width = 7
   */
  width?: number;
  /**
   * For frame nodes: the height of the frame.
   *
   * @generated from protobuf field: optional double height = 8
   */
  height?: number;
  /**
   * For frame nodes: IDs of nodes contained within this frame.
   * Updated automatically based on node positions.
   *
   * @generated from protobuf field: repeated string contained_nodes = 9
   */
  containedNodes: string[];
  /**
   * Optional label override for this node instance.
   * If set, displayed instead of the node type's default label.
   *
   * @generated from protobuf field: string label = 10
   */
  label: string;
  /**
   * For reroute nodes: the resolved port type based on connections.
   * Dynamically updated when connections change.
   *
   * @generated from protobuf field: optional soulfire.v1.PortType resolved_type = 11
   */
  resolvedType?: PortType;
  /**
   * Parent frame node ID, if this node is inside a frame.
   *
   * @generated from protobuf field: string parent_frame_id = 12
   */
  parentFrameId: string;
}
/**
 * Represents a connection between two nodes in the visual script graph.
 * Edges define how execution flows and how data passes between nodes.
 *
 * @generated from protobuf message soulfire.v1.ScriptEdge
 */
export interface ScriptEdge {
  /**
   * Unique identifier for this edge within the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * The ID of the source node where this edge originates.
   * Must reference a valid node ID in the script's nodes list.
   *
   * @generated from protobuf field: string source = 2
   */
  source: string;
  /**
   * The handle/port identifier on the source node.
   * Identifies which output port of the source node this edge connects from.
   * Examples: "exec_out", "value", "true", "false".
   *
   * @generated from protobuf field: string source_handle = 3
   */
  sourceHandle: string;
  /**
   * The ID of the target node where this edge terminates.
   * Must reference a valid node ID in the script's nodes list.
   *
   * @generated from protobuf field: string target = 4
   */
  target: string;
  /**
   * The handle/port identifier on the target node.
   * Identifies which input port of the target node this edge connects to.
   * Examples: "exec_in", "message", "condition".
   *
   * @generated from protobuf field: string target_handle = 5
   */
  targetHandle: string;
  /**
   * The type of this edge, determining whether it carries execution flow or data.
   *
   * @generated from protobuf field: soulfire.v1.EdgeType edge_type = 6
   */
  edgeType: EdgeType;
}
/**
 * Complete data structure representing a visual script.
 * Contains all nodes, edges, and metadata needed to render and execute the script.
 *
 * @generated from protobuf message soulfire.v1.ScriptData
 */
export interface ScriptData {
  /**
   * Unique identifier for this script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Human-readable name for the script.
   * Displayed in the UI and used for identification.
   *
   * @generated from protobuf field: string name = 2
   */
  name: string;
  /**
   * Optional description explaining what the script does.
   * Displayed in script listings and detail views.
   *
   * @generated from protobuf field: string description = 3
   */
  description: string;
  /**
   * The list of nodes that make up this script's graph.
   * Nodes are executed based on execution edge connections.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptNode nodes = 4
   */
  nodes: ScriptNode[];
  /**
   * The list of edges connecting nodes in this script.
   * Defines both execution flow and data transfer between nodes.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptEdge edges = 5
   */
  edges: ScriptEdge[];
  /**
   * The instance this script belongs to.
   * Scripts are always associated with a specific instance.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 7
   */
  instanceId: string;
  /**
   * Whether this script is paused (not running).
   * Scripts run by default. When paused, they won't be started on server startup
   * or when created/updated.
   *
   * @generated from protobuf field: bool paused = 8
   */
  paused: boolean;
  /**
   * Optional resource quotas for this script.
   *
   * @generated from protobuf field: soulfire.v1.ScriptQuotas quotas = 9
   */
  quotas?: ScriptQuotas;
}
/**
 * Resource quotas for limiting script execution.
 * All fields are optional; unset fields use server defaults.
 *
 * @generated from protobuf message soulfire.v1.ScriptQuotas
 */
export interface ScriptQuotas {
  /**
   * Maximum number of node executions per trigger invocation.
   *
   * @generated from protobuf field: optional int64 max_execution_count = 1
   */
  maxExecutionCount?: string;
  /**
   * Maximum wall-clock time for a single trigger execution in milliseconds.
   *
   * @generated from protobuf field: optional int64 max_execution_time_ms = 2
   */
  maxExecutionTimeMs?: string;
  /**
   * Maximum number of concurrent trigger invocations.
   *
   * @generated from protobuf field: optional int32 max_concurrent_triggers = 3
   */
  maxConcurrentTriggers?: number;
  /**
   * Maximum number of entries in the script's state store.
   *
   * @generated from protobuf field: optional int64 max_state_store_entries = 4
   */
  maxStateStoreEntries?: string;
}
/**
 * Summary information about a script for listing purposes.
 * Contains metadata without the full node graph to reduce payload size.
 *
 * @generated from protobuf message soulfire.v1.ScriptInfo
 */
export interface ScriptInfo {
  /**
   * Unique identifier for this script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Human-readable name for the script.
   *
   * @generated from protobuf field: string name = 2
   */
  name: string;
  /**
   * Optional description of what the script does.
   *
   * @generated from protobuf field: string description = 3
   */
  description: string;
  /**
   * The instance this script belongs to.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 5
   */
  instanceId: string;
  /**
   * Timestamp when the script was first created.
   *
   * @generated from protobuf field: google.protobuf.Timestamp created_at = 6
   */
  createdAt?: Timestamp;
  /**
   * Timestamp when the script was last modified.
   *
   * @generated from protobuf field: google.protobuf.Timestamp updated_at = 7
   */
  updatedAt?: Timestamp;
  /**
   * Whether this script is paused (not running).
   *
   * @generated from protobuf field: bool paused = 8
   */
  paused: boolean;
}
/**
 * Runtime status information for a script.
 * Provides information about current activation state and statistics.
 *
 * @generated from protobuf message soulfire.v1.ScriptStatus
 */
export interface ScriptStatus {
  /**
   * The script this status applies to.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 1
   */
  scriptId: string;
  /**
   * Whether the script is currently active (listening for triggers).
   *
   * @generated from protobuf field: bool is_active = 2
   */
  isActive: boolean;
  /**
   * The ID of the currently executing node, if any.
   * Only present when a node is actively executing.
   *
   * @generated from protobuf field: optional string active_node_id = 3
   */
  activeNodeId?: string;
  /**
   * The total number of times this script has been activated.
   * Incremented each time ActivateScript is called.
   *
   * @generated from protobuf field: int64 activation_count = 4
   */
  activationCount: string;
}
/**
 * A single log entry generated during script execution.
 * Provides detailed information about script operations for debugging and monitoring.
 *
 * @generated from protobuf message soulfire.v1.ScriptLogEntry
 */
export interface ScriptLogEntry {
  /**
   * The script that generated this log entry.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 1
   */
  scriptId: string;
  /**
   * The node that generated this log entry, if applicable.
   * May be empty for script-level log entries.
   *
   * @generated from protobuf field: string node_id = 2
   */
  nodeId: string;
  /**
   * The severity level of this log entry.
   *
   * @generated from protobuf field: soulfire.v1.LogLevel level = 3
   */
  level: LogLevel;
  /**
   * The log message content.
   *
   * @generated from protobuf field: string message = 4
   */
  message: string;
  /**
   * When this log entry was created.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 5
   */
  timestamp?: Timestamp;
}
/**
 * Event emitted when a node begins execution.
 *
 * @generated from protobuf message soulfire.v1.NodeStarted
 */
export interface NodeStarted {
  /**
   * The ID of the node that started executing.
   *
   * @generated from protobuf field: string node_id = 1
   */
  nodeId: string;
  /**
   * When the node started execution.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2
   */
  timestamp?: Timestamp;
}
/**
 * Event emitted when a node completes execution successfully.
 *
 * @generated from protobuf message soulfire.v1.NodeCompleted
 */
export interface NodeCompleted {
  /**
   * The ID of the node that completed execution.
   *
   * @generated from protobuf field: string node_id = 1
   */
  nodeId: string;
  /**
   * The output values produced by the node.
   * Keys are output port names, values are the data produced.
   *
   * @generated from protobuf field: map<string, google.protobuf.Value> outputs = 2
   */
  outputs: {
    [key: string]: Value;
  };
  /**
   * When the node completed execution.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 3
   */
  timestamp?: Timestamp;
  /**
   * Execution time in nanoseconds for profiling.
   *
   * @generated from protobuf field: int64 execution_time_nanos = 4
   */
  executionTimeNanos: string;
}
/**
 * Execution statistics emitted when a trigger chain completes.
 *
 * @generated from protobuf message soulfire.v1.ExecutionStats
 */
export interface ExecutionStats {
  /**
   * Total number of node executions in this chain.
   *
   * @generated from protobuf field: int64 node_count = 1
   */
  nodeCount: string;
  /**
   * Maximum allowed node executions.
   *
   * @generated from protobuf field: int64 max_count = 2
   */
  maxCount: string;
}
/**
 * Event emitted when a node encounters an error during execution.
 *
 * @generated from protobuf message soulfire.v1.NodeError
 */
export interface NodeError {
  /**
   * The ID of the node that encountered the error.
   *
   * @generated from protobuf field: string node_id = 1
   */
  nodeId: string;
  /**
   * A description of what went wrong.
   *
   * @generated from protobuf field: string error_message = 2
   */
  errorMessage: string;
  /**
   * When the error occurred.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 3
   */
  timestamp?: Timestamp;
}
/**
 * Event emitted when a script logs a message (e.g., from Print node).
 *
 * @generated from protobuf message soulfire.v1.ScriptLog
 */
export interface ScriptLog {
  /**
   * The ID of the node that produced the log (if applicable).
   *
   * @generated from protobuf field: optional string node_id = 1
   */
  nodeId?: string;
  /**
   * The log level (debug, info, warn, error).
   *
   * @generated from protobuf field: string level = 2
   */
  level: string;
  /**
   * The log message content.
   *
   * @generated from protobuf field: string message = 3
   */
  message: string;
  /**
   * When the log was produced.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 4
   */
  timestamp?: Timestamp;
}
/**
 * Event emitted when a trigger fires and begins executing a node chain.
 * Note: Scripts are reactive - this indicates a trigger event occurred,
 * not that the script "started running" in the traditional sense.
 *
 * @generated from protobuf message soulfire.v1.ScriptStarted
 */
export interface ScriptStarted {
  /**
   * The ID of the script containing the triggered chain.
   *
   * @generated from protobuf field: string script_id = 1
   */
  scriptId: string;
  /**
   * When the trigger fired and execution began.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 2
   */
  timestamp?: Timestamp;
}
/**
 * Event emitted when a triggered node chain finishes executing.
 * Note: This indicates one trigger chain completed, not that the script
 * is done - the script remains active and will respond to future triggers.
 *
 * @generated from protobuf message soulfire.v1.ScriptCompleted
 */
export interface ScriptCompleted {
  /**
   * The ID of the script that completed the chain.
   *
   * @generated from protobuf field: string script_id = 1
   */
  scriptId: string;
  /**
   * Whether the chain completed successfully without errors.
   *
   * @generated from protobuf field: bool success = 2
   */
  success: boolean;
  /**
   * When the chain completed execution.
   *
   * @generated from protobuf field: google.protobuf.Timestamp timestamp = 3
   */
  timestamp?: Timestamp;
}
/**
 * A structured validation diagnostic with node/edge context and severity.
 *
 * @generated from protobuf message soulfire.v1.ValidationDiagnostic
 */
export interface ValidationDiagnostic {
  /**
   * The node related to this diagnostic, or empty for graph-level issues.
   *
   * @generated from protobuf field: string node_id = 1
   */
  nodeId: string;
  /**
   * A composite edge key related to this diagnostic, or empty.
   *
   * @generated from protobuf field: string edge_id = 2
   */
  edgeId: string;
  /**
   * Human-readable description of the issue.
   *
   * @generated from protobuf field: string message = 3
   */
  message: string;
  /**
   * Severity level of this diagnostic.
   *
   * @generated from protobuf field: soulfire.v1.DiagnosticSeverity severity = 4
   */
  severity: DiagnosticSeverity;
}
/**
 * Union type for all script execution events.
 * Streamed to clients during script activation to provide real-time feedback.
 * Events represent individual trigger chain executions, not script lifecycle.
 *
 * @generated from protobuf message soulfire.v1.ScriptEvent
 */
export interface ScriptEvent {
  /**
   * The specific event that occurred.
   *
   * @generated from protobuf oneof: event
   */
  event:
    | {
        oneofKind: "nodeStarted";
        /**
         * A node started executing.
         *
         * @generated from protobuf field: soulfire.v1.NodeStarted node_started = 1
         */
        nodeStarted: NodeStarted;
      }
    | {
        oneofKind: "nodeCompleted";
        /**
         * A node completed execution successfully.
         *
         * @generated from protobuf field: soulfire.v1.NodeCompleted node_completed = 2
         */
        nodeCompleted: NodeCompleted;
      }
    | {
        oneofKind: "nodeError";
        /**
         * A node encountered an error.
         *
         * @generated from protobuf field: soulfire.v1.NodeError node_error = 3
         */
        nodeError: NodeError;
      }
    | {
        oneofKind: "scriptCompleted";
        /**
         * A trigger chain finished executing.
         *
         * @generated from protobuf field: soulfire.v1.ScriptCompleted script_completed = 4
         */
        scriptCompleted: ScriptCompleted;
      }
    | {
        oneofKind: "scriptStarted";
        /**
         * A trigger fired and began executing a chain.
         *
         * @generated from protobuf field: soulfire.v1.ScriptStarted script_started = 5
         */
        scriptStarted: ScriptStarted;
      }
    | {
        oneofKind: "scriptLog";
        /**
         * A script logged a message.
         *
         * @generated from protobuf field: soulfire.v1.ScriptLog script_log = 6
         */
        scriptLog: ScriptLog;
      }
    | {
        oneofKind: "executionStats";
        /**
         * Execution statistics for a completed trigger chain.
         *
         * @generated from protobuf field: soulfire.v1.ExecutionStats execution_stats = 7
         */
        executionStats: ExecutionStats;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * Request to create a new script.
 *
 * @generated from protobuf message soulfire.v1.CreateScriptRequest
 */
export interface CreateScriptRequest {
  /**
   * The instance to create the script in.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The human-readable name for the script.
   *
   * @generated from protobuf field: string name = 2
   */
  name: string;
  /**
   * Optional description of what the script does.
   *
   * @generated from protobuf field: string description = 3
   */
  description: string;
  /**
   * Initial nodes for the script graph.
   * Can be empty to create a blank script.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptNode nodes = 5
   */
  nodes: ScriptNode[];
  /**
   * Initial edges for the script graph.
   * Can be empty to create a blank script.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptEdge edges = 6
   */
  edges: ScriptEdge[];
  /**
   * Whether the script should be created in paused state.
   * If false (default), the script starts running immediately after creation.
   *
   * @generated from protobuf field: bool paused = 7
   */
  paused: boolean;
}
/**
 * Response after successfully creating a script.
 *
 * @generated from protobuf message soulfire.v1.CreateScriptResponse
 */
export interface CreateScriptResponse {
  /**
   * The complete script data including the generated ID.
   *
   * @generated from protobuf field: soulfire.v1.ScriptData script = 1
   */
  script?: ScriptData;
  /**
   * Validation diagnostics (warnings) from building the script graph.
   *
   * @generated from protobuf field: repeated soulfire.v1.ValidationDiagnostic diagnostics = 2
   */
  diagnostics: ValidationDiagnostic[];
}
/**
 * Request to retrieve a specific script by ID.
 *
 * @generated from protobuf message soulfire.v1.GetScriptRequest
 */
export interface GetScriptRequest {
  /**
   * The instance containing the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the script to retrieve.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
}
/**
 * Response containing the requested script.
 *
 * @generated from protobuf message soulfire.v1.GetScriptResponse
 */
export interface GetScriptResponse {
  /**
   * The complete script data including all nodes and edges.
   *
   * @generated from protobuf field: soulfire.v1.ScriptData script = 1
   */
  script?: ScriptData;
}
/**
 * Request to update an existing script.
 *
 * @generated from protobuf message soulfire.v1.UpdateScriptRequest
 */
export interface UpdateScriptRequest {
  /**
   * The instance containing the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the script to update.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
  /**
   * Updated name for the script.
   * If not set, the name remains unchanged.
   *
   * @generated from protobuf field: optional string name = 3
   */
  name?: string;
  /**
   * Updated description for the script.
   * If not set, the description remains unchanged.
   *
   * @generated from protobuf field: optional string description = 4
   */
  description?: string;
  /**
   * Updated list of nodes.
   * If provided, replaces the entire node list.
   * If not provided, nodes remain unchanged.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptNode nodes = 6
   */
  nodes: ScriptNode[];
  /**
   * Updated list of edges.
   * If provided, replaces the entire edge list.
   * If not provided, edges remain unchanged.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptEdge edges = 7
   */
  edges: ScriptEdge[];
  /**
   * Whether the nodes field should be updated (allows setting to empty list).
   *
   * @generated from protobuf field: bool update_nodes = 8
   */
  updateNodes: boolean;
  /**
   * Whether the edges field should be updated (allows setting to empty list).
   *
   * @generated from protobuf field: bool update_edges = 9
   */
  updateEdges: boolean;
  /**
   * Updated paused setting.
   * If not set, the paused setting remains unchanged.
   * If set to false and script was paused, the script will be restarted.
   *
   * @generated from protobuf field: optional bool paused = 10
   */
  paused?: boolean;
}
/**
 * Response after successfully updating a script.
 *
 * @generated from protobuf message soulfire.v1.UpdateScriptResponse
 */
export interface UpdateScriptResponse {
  /**
   * The updated script data.
   *
   * @generated from protobuf field: soulfire.v1.ScriptData script = 1
   */
  script?: ScriptData;
  /**
   * Validation diagnostics (warnings) from building the script graph.
   *
   * @generated from protobuf field: repeated soulfire.v1.ValidationDiagnostic diagnostics = 2
   */
  diagnostics: ValidationDiagnostic[];
}
/**
 * Request to delete a script.
 *
 * @generated from protobuf message soulfire.v1.DeleteScriptRequest
 */
export interface DeleteScriptRequest {
  /**
   * The instance containing the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the script to delete.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
}
/**
 * Response after successfully deleting a script.
 * Empty response indicates success.
 *
 * @generated from protobuf message soulfire.v1.DeleteScriptResponse
 */
export interface DeleteScriptResponse {}
/**
 * Request to list all scripts in an instance.
 *
 * @generated from protobuf message soulfire.v1.ListScriptsRequest
 */
export interface ListScriptsRequest {
  /**
   * The instance to list scripts from.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
}
/**
 * Response containing the list of scripts.
 *
 * @generated from protobuf message soulfire.v1.ListScriptsResponse
 */
export interface ListScriptsResponse {
  /**
   * Summary information for each script in the instance.
   * Does not include full node/edge data to reduce payload size.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptInfo scripts = 1
   */
  scripts: ScriptInfo[];
}
/**
 * Request to activate a script (register its event listeners).
 *
 * @generated from protobuf message soulfire.v1.ActivateScriptRequest
 */
export interface ActivateScriptRequest {
  /**
   * The instance containing the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the script to activate.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
}
/**
 * Request to deactivate an active script.
 *
 * @generated from protobuf message soulfire.v1.DeactivateScriptRequest
 */
export interface DeactivateScriptRequest {
  /**
   * The instance containing the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the script to deactivate.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
}
/**
 * Response after successfully deactivating a script.
 * Empty response indicates success.
 *
 * @generated from protobuf message soulfire.v1.DeactivateScriptResponse
 */
export interface DeactivateScriptResponse {}
/**
 * Request to get the execution status of a script.
 *
 * @generated from protobuf message soulfire.v1.GetScriptStatusRequest
 */
export interface GetScriptStatusRequest {
  /**
   * The instance containing the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the script to check.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
}
/**
 * Response containing the script's execution status.
 *
 * @generated from protobuf message soulfire.v1.GetScriptStatusResponse
 */
export interface GetScriptStatusResponse {
  /**
   * The current status of the script.
   *
   * @generated from protobuf field: soulfire.v1.ScriptStatus status = 1
   */
  status?: ScriptStatus;
}
/**
 * Request to subscribe to log entries from a script.
 *
 * @generated from protobuf message soulfire.v1.SubscribeScriptLogsRequest
 */
export interface SubscribeScriptLogsRequest {
  /**
   * The instance containing the script.
   * Format: UUID string.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the script to receive logs from.
   * Format: UUID string.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
  /**
   * Minimum log level to receive.
   * Only log entries at this level or higher severity will be streamed.
   *
   * @generated from protobuf field: soulfire.v1.LogLevel min_level = 3
   */
  minLevel: LogLevel;
}
/**
 * Request to get all available node types.
 * This enables clients to render nodes without hardcoded knowledge.
 *
 * @generated from protobuf message soulfire.v1.GetNodeTypesRequest
 */
export interface GetNodeTypesRequest {
  /**
   * Optional filter by category ID (references CategoryDefinition.id).
   * Examples: "triggers", "actions", "math".
   * If empty, returns all node types.
   *
   * @generated from protobuf field: optional string category = 1
   */
  category?: string;
  /**
   * Whether to include deprecated node types.
   * Default is false.
   *
   * @generated from protobuf field: bool include_deprecated = 2
   */
  includeDeprecated: boolean;
}
/**
 * Definition of a node category for organizing the node palette.
 *
 * @generated from protobuf message soulfire.v1.CategoryDefinition
 */
export interface CategoryDefinition {
  /**
   * The unique identifier for this category.
   * Examples: "triggers", "actions", "math", "logic".
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Human-readable name displayed in the UI.
   * Examples: "Triggers", "Actions", "Math", "Logic".
   *
   * @generated from protobuf field: string display_name = 2
   */
  displayName: string;
  /**
   * Icon identifier for the category.
   * Examples: "zap", "play", "calculator", "git-branch".
   *
   * @generated from protobuf field: string icon = 3
   */
  icon: string;
  /**
   * Optional description of this category.
   *
   * @generated from protobuf field: string description = 4
   */
  description: string;
  /**
   * Sort order for displaying categories (lower = earlier).
   *
   * @generated from protobuf field: int32 sort_order = 5
   */
  sortOrder: number;
}
/**
 * Response containing all available node types.
 *
 * @generated from protobuf message soulfire.v1.GetNodeTypesResponse
 */
export interface GetNodeTypesResponse {
  /**
   * List of all node type definitions.
   * Clients can use this to render any node and validate connections.
   *
   * @generated from protobuf field: repeated soulfire.v1.NodeTypeDefinition node_types = 1
   */
  nodeTypes: NodeTypeDefinition[];
  /**
   * List of all categories with their metadata.
   * Useful for building category filters and palette sections in the UI.
   *
   * @generated from protobuf field: repeated soulfire.v1.CategoryDefinition categories = 2
   */
  categories: CategoryDefinition[];
  /**
   * Metadata for each port type including colors and compatibility.
   * Clients should use this instead of hardcoded port type info.
   *
   * @generated from protobuf field: repeated soulfire.v1.PortTypeMetadata port_type_metadata = 3
   */
  portTypeMetadata: PortTypeMetadata[];
}
/**
 * Metadata for a port type, enabling data-driven port rendering.
 *
 * @generated from protobuf message soulfire.v1.PortTypeMetadata
 */
export interface PortTypeMetadata {
  /**
   * The port type this metadata applies to.
   *
   * @generated from protobuf field: soulfire.v1.PortType port_type = 1
   */
  portType: PortType;
  /**
   * Display color for this port type (hex color code, e.g., "#22c55e").
   *
   * @generated from protobuf field: string color = 2
   */
  color: string;
  /**
   * Human-readable name for this port type.
   *
   * @generated from protobuf field: string display_name = 3
   */
  displayName: string;
  /**
   * List of port types that can be implicitly converted to this type.
   * Used for connection validation. Empty means only exact matches allowed.
   *
   * @generated from protobuf field: repeated soulfire.v1.PortType compatible_from = 4
   */
  compatibleFrom: PortType[];
  /**
   * Shape of the handle for this port type in the visual editor.
   *
   * @generated from protobuf field: soulfire.v1.HandleShape handle_shape = 5
   */
  handleShape: HandleShape;
  /**
   * Visual style for edges of this port type.
   *
   * @generated from protobuf field: soulfire.v1.EdgeStyle edge_style = 6
   */
  edgeStyle: EdgeStyle;
}
/**
 * Request to get Minecraft registry data for autocomplete and validation.
 *
 * @generated from protobuf message soulfire.v1.GetRegistryDataRequest
 */
export interface GetRegistryDataRequest {
  /**
   * Optional: specific registry to fetch. If empty, returns all registries.
   * Valid values: "blocks", "entities", "items", "biomes"
   *
   * @generated from protobuf field: optional string registry = 1
   */
  registry?: string;
}
/**
 * A single registry entry (block, entity, item, or biome).
 *
 * @generated from protobuf message soulfire.v1.RegistryEntry
 */
export interface RegistryEntry {
  /**
   * The namespaced identifier (e.g., "minecraft:diamond_ore").
   *
   * @generated from protobuf field: string id = 1
   */
  id: string;
  /**
   * Human-readable display name.
   *
   * @generated from protobuf field: string display_name = 2
   */
  displayName: string;
  /**
   * Optional icon or texture identifier.
   *
   * @generated from protobuf field: string icon = 3
   */
  icon: string;
  /**
   * Optional category/group for organizing in UI.
   *
   * @generated from protobuf field: string category = 4
   */
  category: string;
}
/**
 * Request to validate a script graph without saving it.
 *
 * @generated from protobuf message soulfire.v1.ValidateScriptRequest
 */
export interface ValidateScriptRequest {
  /**
   * The instance context for validation.
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The nodes to validate.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptNode nodes = 2
   */
  nodes: ScriptNode[];
  /**
   * The edges to validate.
   *
   * @generated from protobuf field: repeated soulfire.v1.ScriptEdge edges = 3
   */
  edges: ScriptEdge[];
}
/**
 * Response containing validation diagnostics.
 *
 * @generated from protobuf message soulfire.v1.ValidateScriptResponse
 */
export interface ValidateScriptResponse {
  /**
   * All diagnostics (errors and warnings) for the script graph.
   *
   * @generated from protobuf field: repeated soulfire.v1.ValidationDiagnostic diagnostics = 1
   */
  diagnostics: ValidationDiagnostic[];
}
/**
 * Request to dry-run a script from a specific trigger node with mock inputs.
 *
 * @generated from protobuf message soulfire.v1.DryRunScriptRequest
 */
export interface DryRunScriptRequest {
  /**
   * The instance ID for context (may be used for registry data).
   *
   * @generated from protobuf field: string instance_id = 1
   */
  instanceId: string;
  /**
   * The ID of the saved script to dry-run.
   *
   * @generated from protobuf field: string script_id = 2
   */
  scriptId: string;
  /**
   * The trigger node ID to start execution from.
   *
   * @generated from protobuf field: string trigger_node_id = 3
   */
  triggerNodeId: string;
  /**
   * Mock input values for the trigger (port ID -> value).
   *
   * @generated from protobuf field: map<string, google.protobuf.Value> mock_inputs = 4
   */
  mockInputs: {
    [key: string]: Value;
  };
}
/**
 * Response containing Minecraft registry data.
 *
 * @generated from protobuf message soulfire.v1.GetRegistryDataResponse
 */
export interface GetRegistryDataResponse {
  /**
   * Block types (e.g., "minecraft:stone", "minecraft:diamond_ore").
   *
   * @generated from protobuf field: repeated soulfire.v1.RegistryEntry blocks = 1
   */
  blocks: RegistryEntry[];
  /**
   * Entity types (e.g., "minecraft:zombie", "minecraft:player").
   *
   * @generated from protobuf field: repeated soulfire.v1.RegistryEntry entities = 2
   */
  entities: RegistryEntry[];
  /**
   * Item types (e.g., "minecraft:diamond", "minecraft:stick").
   *
   * @generated from protobuf field: repeated soulfire.v1.RegistryEntry items = 3
   */
  items: RegistryEntry[];
  /**
   * Biome types (e.g., "minecraft:plains", "minecraft:forest").
   *
   * @generated from protobuf field: repeated soulfire.v1.RegistryEntry biomes = 4
   */
  biomes: RegistryEntry[];
}
/**
 * The type of connection between nodes in the visual script editor.
 * Determines how data and control flow between nodes.
 *
 * @generated from protobuf enum soulfire.v1.EdgeType
 */
export enum EdgeType {
  /**
   * Execution edge that controls the order of node execution.
   * When a node completes, execution flows through its outgoing execution edges.
   *
   * @generated from protobuf enum value: EDGE_TYPE_EXECUTION = 0;
   */
  EXECUTION = 0,
  /**
   * Data edge that passes values between nodes.
   * Data edges transfer output values from one node's output port to another node's input port.
   *
   * @generated from protobuf enum value: EDGE_TYPE_DATA = 1;
   */
  DATA = 1,
}
/**
 * The data type of a node port.
 * Used for validation and UI rendering of connections.
 *
 * @generated from protobuf enum soulfire.v1.PortType
 */
export enum PortType {
  /**
   * Any type - accepts all values. Used for generic nodes.
   *
   * @generated from protobuf enum value: PORT_TYPE_ANY = 0;
   */
  ANY = 0,
  /**
   * Numeric value (integer or floating point).
   *
   * @generated from protobuf enum value: PORT_TYPE_NUMBER = 1;
   */
  NUMBER = 1,
  /**
   * Text string value.
   *
   * @generated from protobuf enum value: PORT_TYPE_STRING = 2;
   */
  STRING = 2,
  /**
   * Boolean true/false value.
   *
   * @generated from protobuf enum value: PORT_TYPE_BOOLEAN = 3;
   */
  BOOLEAN = 3,
  /**
   * 3D vector with x, y, z components.
   *
   * @generated from protobuf enum value: PORT_TYPE_VECTOR3 = 4;
   */
  VECTOR3 = 4,
  /**
   * Reference to a bot connection.
   *
   * @generated from protobuf enum value: PORT_TYPE_BOT = 5;
   */
  BOT = 5,
  /**
   * List/array of values.
   *
   * @generated from protobuf enum value: PORT_TYPE_LIST = 6;
   */
  LIST = 6,
  /**
   * Execution flow port (not data).
   *
   * @generated from protobuf enum value: PORT_TYPE_EXEC = 7;
   */
  EXEC = 7,
  /**
   * Block type identifier.
   *
   * @generated from protobuf enum value: PORT_TYPE_BLOCK = 8;
   */
  BLOCK = 8,
  /**
   * Entity reference.
   *
   * @generated from protobuf enum value: PORT_TYPE_ENTITY = 9;
   */
  ENTITY = 9,
  /**
   * Item stack reference.
   *
   * @generated from protobuf enum value: PORT_TYPE_ITEM = 10;
   */
  ITEM = 10,
}
/**
 * Log levels for script execution logging.
 * Maps to standard logging severity levels for filtering and display.
 *
 * @generated from protobuf enum soulfire.v1.LogLevel
 */
export enum LogLevel {
  /**
   * Debug level for verbose diagnostic information.
   * Typically only shown when troubleshooting scripts.
   *
   * @generated from protobuf enum value: LOG_LEVEL_DEBUG = 0;
   */
  DEBUG = 0,
  /**
   * Informational messages about script execution progress.
   * Normal operational messages.
   *
   * @generated from protobuf enum value: LOG_LEVEL_INFO = 1;
   */
  INFO = 1,
  /**
   * Warning level for potentially problematic situations.
   * Script continues execution but something unexpected occurred.
   *
   * @generated from protobuf enum value: LOG_LEVEL_WARN = 2;
   */
  WARN = 2,
  /**
   * Error level for failures that may affect script execution.
   * Indicates a problem that needs attention.
   *
   * @generated from protobuf enum value: LOG_LEVEL_ERROR = 3;
   */
  ERROR = 3,
}
/**
 * Severity level for validation diagnostics.
 *
 * @generated from protobuf enum soulfire.v1.DiagnosticSeverity
 */
export enum DiagnosticSeverity {
  /**
   * Error that prevents script execution.
   *
   * @generated from protobuf enum value: DIAGNOSTIC_ERROR = 0;
   */
  DIAGNOSTIC_ERROR = 0,
  /**
   * Warning that does not prevent execution but may indicate issues.
   *
   * @generated from protobuf enum value: DIAGNOSTIC_WARNING = 1;
   */
  DIAGNOSTIC_WARNING = 1,
}
/**
 * Shape of the port handle in the visual editor.
 *
 * @generated from protobuf enum soulfire.v1.HandleShape
 */
export enum HandleShape {
  /**
   * Circular handle, default for data ports.
   *
   * @generated from protobuf enum value: HANDLE_SHAPE_CIRCLE = 0;
   */
  CIRCLE = 0,
  /**
   * Square handle, typically used for execution/flow ports.
   *
   * @generated from protobuf enum value: HANDLE_SHAPE_SQUARE = 1;
   */
  SQUARE = 1,
  /**
   * Diamond-shaped handle, for special port types.
   *
   * @generated from protobuf enum value: HANDLE_SHAPE_DIAMOND = 2;
   */
  DIAMOND = 2,
}
/**
 * Visual style for edges connected to this port type.
 *
 * @generated from protobuf enum soulfire.v1.EdgeStyle
 */
export enum EdgeStyle {
  /**
   * Default bezier curve style.
   *
   * @generated from protobuf enum value: EDGE_STYLE_DEFAULT = 0;
   */
  DEFAULT = 0,
  /**
   * Animated flow style with moving dashes, typically for execution edges.
   *
   * @generated from protobuf enum value: EDGE_STYLE_ANIMATED = 1;
   */
  ANIMATED = 1,
  /**
   * Dashed line style.
   *
   * @generated from protobuf enum value: EDGE_STYLE_DASHED = 2;
   */
  DASHED = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
  constructor() {
    super("soulfire.v1.Position", [
      { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
      { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
    ]);
  }
  create(value?: PartialMessage<Position>): Position {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.x = 0;
    message.y = 0;
    if (value !== undefined)
      reflectionMergePartial<Position>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Position,
  ): Position {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double x */ 1:
          message.x = reader.double();
          break;
        case /* double y */ 2:
          message.y = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: Position,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double x = 1; */
    if (message.x !== 0) writer.tag(1, WireType.Bit64).double(message.x);
    /* double y = 2; */
    if (message.y !== 0) writer.tag(2, WireType.Bit64).double(message.y);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortDefinition$Type extends MessageType<PortDefinition> {
  constructor() {
    super("soulfire.v1.PortDefinition", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "port_type",
        kind: "enum",
        T: () => ["soulfire.v1.PortType", PortType, "PORT_TYPE_"],
      },
      { no: 4, name: "required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 5,
        name: "default_value",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 7,
        name: "element_type",
        kind: "enum",
        opt: true,
        T: () => ["soulfire.v1.PortType", PortType, "PORT_TYPE_"],
      },
      { no: 8, name: "multi_input", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 9,
        name: "accepted_types",
        kind: "enum",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ["soulfire.v1.PortType", PortType, "PORT_TYPE_"],
      },
      {
        no: 10,
        name: "infer_type_from",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<PortDefinition>): PortDefinition {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.displayName = "";
    message.portType = 0;
    message.required = false;
    message.description = "";
    message.multiInput = false;
    message.acceptedTypes = [];
    message.inferTypeFrom = "";
    if (value !== undefined)
      reflectionMergePartial<PortDefinition>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PortDefinition,
  ): PortDefinition {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string display_name */ 2:
          message.displayName = reader.string();
          break;
        case /* soulfire.v1.PortType port_type */ 3:
          message.portType = reader.int32();
          break;
        case /* bool required */ 4:
          message.required = reader.bool();
          break;
        case /* optional string default_value */ 5:
          message.defaultValue = reader.string();
          break;
        case /* string description */ 6:
          message.description = reader.string();
          break;
        case /* optional soulfire.v1.PortType element_type */ 7:
          message.elementType = reader.int32();
          break;
        case /* bool multi_input */ 8:
          message.multiInput = reader.bool();
          break;
        case /* repeated soulfire.v1.PortType accepted_types */ 9:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.acceptedTypes.push(reader.int32());
          else message.acceptedTypes.push(reader.int32());
          break;
        case /* string infer_type_from */ 10:
          message.inferTypeFrom = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PortDefinition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string display_name = 2; */
    if (message.displayName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.displayName);
    /* soulfire.v1.PortType port_type = 3; */
    if (message.portType !== 0)
      writer.tag(3, WireType.Varint).int32(message.portType);
    /* bool required = 4; */
    if (message.required !== false)
      writer.tag(4, WireType.Varint).bool(message.required);
    /* optional string default_value = 5; */
    if (message.defaultValue !== undefined)
      writer.tag(5, WireType.LengthDelimited).string(message.defaultValue);
    /* string description = 6; */
    if (message.description !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.description);
    /* optional soulfire.v1.PortType element_type = 7; */
    if (message.elementType !== undefined)
      writer.tag(7, WireType.Varint).int32(message.elementType);
    /* bool multi_input = 8; */
    if (message.multiInput !== false)
      writer.tag(8, WireType.Varint).bool(message.multiInput);
    /* repeated soulfire.v1.PortType accepted_types = 9; */
    if (message.acceptedTypes.length) {
      writer.tag(9, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.acceptedTypes.length; i++)
        writer.int32(message.acceptedTypes[i]);
      writer.join();
    }
    /* string infer_type_from = 10; */
    if (message.inferTypeFrom !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.inferTypeFrom);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.PortDefinition
 */
export const PortDefinition = new PortDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeTypeDefinition$Type extends MessageType<NodeTypeDefinition> {
  constructor() {
    super("soulfire.v1.NodeTypeDefinition", [
      { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "is_trigger", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 6,
        name: "inputs",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => PortDefinition,
      },
      {
        no: 7,
        name: "outputs",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => PortDefinition,
      },
      { no: 8, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 9, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 10,
        name: "keywords",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 11, name: "deprecated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 12,
        name: "deprecation_message",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 13,
        name: "is_layout_node",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 14,
        name: "supports_muting",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 15,
        name: "supports_preview",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 16,
        name: "is_expensive",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<NodeTypeDefinition>): NodeTypeDefinition {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.type = "";
    message.displayName = "";
    message.description = "";
    message.category = "";
    message.isTrigger = false;
    message.inputs = [];
    message.outputs = [];
    message.icon = "";
    message.color = "";
    message.keywords = [];
    message.deprecated = false;
    message.deprecationMessage = "";
    message.isLayoutNode = false;
    message.supportsMuting = false;
    message.supportsPreview = false;
    message.isExpensive = false;
    if (value !== undefined)
      reflectionMergePartial<NodeTypeDefinition>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: NodeTypeDefinition,
  ): NodeTypeDefinition {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */ 1:
          message.type = reader.string();
          break;
        case /* string display_name */ 2:
          message.displayName = reader.string();
          break;
        case /* string description */ 3:
          message.description = reader.string();
          break;
        case /* string category */ 4:
          message.category = reader.string();
          break;
        case /* bool is_trigger */ 5:
          message.isTrigger = reader.bool();
          break;
        case /* repeated soulfire.v1.PortDefinition inputs */ 6:
          message.inputs.push(
            PortDefinition.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.PortDefinition outputs */ 7:
          message.outputs.push(
            PortDefinition.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string icon */ 8:
          message.icon = reader.string();
          break;
        case /* string color */ 9:
          message.color = reader.string();
          break;
        case /* repeated string keywords */ 10:
          message.keywords.push(reader.string());
          break;
        case /* bool deprecated */ 11:
          message.deprecated = reader.bool();
          break;
        case /* string deprecation_message */ 12:
          message.deprecationMessage = reader.string();
          break;
        case /* bool is_layout_node */ 13:
          message.isLayoutNode = reader.bool();
          break;
        case /* bool supports_muting */ 14:
          message.supportsMuting = reader.bool();
          break;
        case /* bool supports_preview */ 15:
          message.supportsPreview = reader.bool();
          break;
        case /* bool is_expensive */ 16:
          message.isExpensive = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: NodeTypeDefinition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string type = 1; */
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    /* string display_name = 2; */
    if (message.displayName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.displayName);
    /* string description = 3; */
    if (message.description !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    /* string category = 4; */
    if (message.category !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.category);
    /* bool is_trigger = 5; */
    if (message.isTrigger !== false)
      writer.tag(5, WireType.Varint).bool(message.isTrigger);
    /* repeated soulfire.v1.PortDefinition inputs = 6; */
    for (let i = 0; i < message.inputs.length; i++)
      PortDefinition.internalBinaryWrite(
        message.inputs[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.PortDefinition outputs = 7; */
    for (let i = 0; i < message.outputs.length; i++)
      PortDefinition.internalBinaryWrite(
        message.outputs[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string icon = 8; */
    if (message.icon !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.icon);
    /* string color = 9; */
    if (message.color !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.color);
    /* repeated string keywords = 10; */
    for (let i = 0; i < message.keywords.length; i++)
      writer.tag(10, WireType.LengthDelimited).string(message.keywords[i]);
    /* bool deprecated = 11; */
    if (message.deprecated !== false)
      writer.tag(11, WireType.Varint).bool(message.deprecated);
    /* string deprecation_message = 12; */
    if (message.deprecationMessage !== "")
      writer
        .tag(12, WireType.LengthDelimited)
        .string(message.deprecationMessage);
    /* bool is_layout_node = 13; */
    if (message.isLayoutNode !== false)
      writer.tag(13, WireType.Varint).bool(message.isLayoutNode);
    /* bool supports_muting = 14; */
    if (message.supportsMuting !== false)
      writer.tag(14, WireType.Varint).bool(message.supportsMuting);
    /* bool supports_preview = 15; */
    if (message.supportsPreview !== false)
      writer.tag(15, WireType.Varint).bool(message.supportsPreview);
    /* bool is_expensive = 16; */
    if (message.isExpensive !== false)
      writer.tag(16, WireType.Varint).bool(message.isExpensive);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.NodeTypeDefinition
 */
export const NodeTypeDefinition = new NodeTypeDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptNode$Type extends MessageType<ScriptNode> {
  constructor() {
    super("soulfire.v1.ScriptNode", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "position", kind: "message", T: () => Position },
      {
        no: 4,
        name: "data",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => Value },
      },
      { no: 5, name: "muted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 6, name: "collapsed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 7,
        name: "width",
        kind: "scalar",
        opt: true,
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 8,
        name: "height",
        kind: "scalar",
        opt: true,
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 9,
        name: "contained_nodes",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 10, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 11,
        name: "resolved_type",
        kind: "enum",
        opt: true,
        T: () => ["soulfire.v1.PortType", PortType, "PORT_TYPE_"],
      },
      {
        no: 12,
        name: "parent_frame_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<ScriptNode>): ScriptNode {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.type = "";
    message.data = {};
    message.muted = false;
    message.collapsed = false;
    message.containedNodes = [];
    message.label = "";
    message.parentFrameId = "";
    if (value !== undefined)
      reflectionMergePartial<ScriptNode>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptNode,
  ): ScriptNode {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string type */ 2:
          message.type = reader.string();
          break;
        case /* soulfire.v1.Position position */ 3:
          message.position = Position.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.position,
          );
          break;
        case /* map<string, google.protobuf.Value> data */ 4:
          this.binaryReadMap4(message.data, reader, options);
          break;
        case /* bool muted */ 5:
          message.muted = reader.bool();
          break;
        case /* bool collapsed */ 6:
          message.collapsed = reader.bool();
          break;
        case /* optional double width */ 7:
          message.width = reader.double();
          break;
        case /* optional double height */ 8:
          message.height = reader.double();
          break;
        case /* repeated string contained_nodes */ 9:
          message.containedNodes.push(reader.string());
          break;
        case /* string label */ 10:
          message.label = reader.string();
          break;
        case /* optional soulfire.v1.PortType resolved_type */ 11:
          message.resolvedType = reader.int32();
          break;
        case /* string parent_frame_id */ 12:
          message.parentFrameId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap4(
    map: ScriptNode["data"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ScriptNode["data"] | undefined,
      val: ScriptNode["data"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = Value.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for soulfire.v1.ScriptNode.data",
          );
      }
    }
    map[key ?? ""] = val ?? Value.create();
  }
  internalBinaryWrite(
    message: ScriptNode,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string type = 2; */
    if (message.type !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.type);
    /* soulfire.v1.Position position = 3; */
    if (message.position)
      Position.internalBinaryWrite(
        message.position,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* map<string, google.protobuf.Value> data = 4; */
    for (let k of globalThis.Object.keys(message.data)) {
      writer
        .tag(4, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      Value.internalBinaryWrite(message.data[k], writer, options);
      writer.join().join();
    }
    /* bool muted = 5; */
    if (message.muted !== false)
      writer.tag(5, WireType.Varint).bool(message.muted);
    /* bool collapsed = 6; */
    if (message.collapsed !== false)
      writer.tag(6, WireType.Varint).bool(message.collapsed);
    /* optional double width = 7; */
    if (message.width !== undefined)
      writer.tag(7, WireType.Bit64).double(message.width);
    /* optional double height = 8; */
    if (message.height !== undefined)
      writer.tag(8, WireType.Bit64).double(message.height);
    /* repeated string contained_nodes = 9; */
    for (let i = 0; i < message.containedNodes.length; i++)
      writer.tag(9, WireType.LengthDelimited).string(message.containedNodes[i]);
    /* string label = 10; */
    if (message.label !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.label);
    /* optional soulfire.v1.PortType resolved_type = 11; */
    if (message.resolvedType !== undefined)
      writer.tag(11, WireType.Varint).int32(message.resolvedType);
    /* string parent_frame_id = 12; */
    if (message.parentFrameId !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.parentFrameId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptNode
 */
export const ScriptNode = new ScriptNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptEdge$Type extends MessageType<ScriptEdge> {
  constructor() {
    super("soulfire.v1.ScriptEdge", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "source_handle",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 4, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: "target_handle",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "edge_type",
        kind: "enum",
        T: () => ["soulfire.v1.EdgeType", EdgeType, "EDGE_TYPE_"],
      },
    ]);
  }
  create(value?: PartialMessage<ScriptEdge>): ScriptEdge {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.source = "";
    message.sourceHandle = "";
    message.target = "";
    message.targetHandle = "";
    message.edgeType = 0;
    if (value !== undefined)
      reflectionMergePartial<ScriptEdge>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptEdge,
  ): ScriptEdge {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string source */ 2:
          message.source = reader.string();
          break;
        case /* string source_handle */ 3:
          message.sourceHandle = reader.string();
          break;
        case /* string target */ 4:
          message.target = reader.string();
          break;
        case /* string target_handle */ 5:
          message.targetHandle = reader.string();
          break;
        case /* soulfire.v1.EdgeType edge_type */ 6:
          message.edgeType = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptEdge,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string source = 2; */
    if (message.source !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.source);
    /* string source_handle = 3; */
    if (message.sourceHandle !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.sourceHandle);
    /* string target = 4; */
    if (message.target !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.target);
    /* string target_handle = 5; */
    if (message.targetHandle !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.targetHandle);
    /* soulfire.v1.EdgeType edge_type = 6; */
    if (message.edgeType !== 0)
      writer.tag(6, WireType.Varint).int32(message.edgeType);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptEdge
 */
export const ScriptEdge = new ScriptEdge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptData$Type extends MessageType<ScriptData> {
  constructor() {
    super("soulfire.v1.ScriptData", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "nodes",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptNode,
      },
      {
        no: 5,
        name: "edges",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptEdge,
      },
      {
        no: 7,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 8, name: "paused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 9, name: "quotas", kind: "message", T: () => ScriptQuotas },
    ]);
  }
  create(value?: PartialMessage<ScriptData>): ScriptData {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.name = "";
    message.description = "";
    message.nodes = [];
    message.edges = [];
    message.instanceId = "";
    message.paused = false;
    if (value !== undefined)
      reflectionMergePartial<ScriptData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptData,
  ): ScriptData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* string description */ 3:
          message.description = reader.string();
          break;
        case /* repeated soulfire.v1.ScriptNode nodes */ 4:
          message.nodes.push(
            ScriptNode.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.ScriptEdge edges */ 5:
          message.edges.push(
            ScriptEdge.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* string instance_id */ 7:
          message.instanceId = reader.string();
          break;
        case /* bool paused */ 8:
          message.paused = reader.bool();
          break;
        case /* soulfire.v1.ScriptQuotas quotas */ 9:
          message.quotas = ScriptQuotas.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.quotas,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string name = 2; */
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    /* string description = 3; */
    if (message.description !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    /* repeated soulfire.v1.ScriptNode nodes = 4; */
    for (let i = 0; i < message.nodes.length; i++)
      ScriptNode.internalBinaryWrite(
        message.nodes[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.ScriptEdge edges = 5; */
    for (let i = 0; i < message.edges.length; i++)
      ScriptEdge.internalBinaryWrite(
        message.edges[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* string instance_id = 7; */
    if (message.instanceId !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.instanceId);
    /* bool paused = 8; */
    if (message.paused !== false)
      writer.tag(8, WireType.Varint).bool(message.paused);
    /* soulfire.v1.ScriptQuotas quotas = 9; */
    if (message.quotas)
      ScriptQuotas.internalBinaryWrite(
        message.quotas,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptData
 */
export const ScriptData = new ScriptData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptQuotas$Type extends MessageType<ScriptQuotas> {
  constructor() {
    super("soulfire.v1.ScriptQuotas", [
      {
        no: 1,
        name: "max_execution_count",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
      },
      {
        no: 2,
        name: "max_execution_time_ms",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
      },
      {
        no: 3,
        name: "max_concurrent_triggers",
        kind: "scalar",
        opt: true,
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 4,
        name: "max_state_store_entries",
        kind: "scalar",
        opt: true,
        T: 3 /*ScalarType.INT64*/,
      },
    ]);
  }
  create(value?: PartialMessage<ScriptQuotas>): ScriptQuotas {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<ScriptQuotas>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptQuotas,
  ): ScriptQuotas {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional int64 max_execution_count */ 1:
          message.maxExecutionCount = reader.int64().toString();
          break;
        case /* optional int64 max_execution_time_ms */ 2:
          message.maxExecutionTimeMs = reader.int64().toString();
          break;
        case /* optional int32 max_concurrent_triggers */ 3:
          message.maxConcurrentTriggers = reader.int32();
          break;
        case /* optional int64 max_state_store_entries */ 4:
          message.maxStateStoreEntries = reader.int64().toString();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptQuotas,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional int64 max_execution_count = 1; */
    if (message.maxExecutionCount !== undefined)
      writer.tag(1, WireType.Varint).int64(message.maxExecutionCount);
    /* optional int64 max_execution_time_ms = 2; */
    if (message.maxExecutionTimeMs !== undefined)
      writer.tag(2, WireType.Varint).int64(message.maxExecutionTimeMs);
    /* optional int32 max_concurrent_triggers = 3; */
    if (message.maxConcurrentTriggers !== undefined)
      writer.tag(3, WireType.Varint).int32(message.maxConcurrentTriggers);
    /* optional int64 max_state_store_entries = 4; */
    if (message.maxStateStoreEntries !== undefined)
      writer.tag(4, WireType.Varint).int64(message.maxStateStoreEntries);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptQuotas
 */
export const ScriptQuotas = new ScriptQuotas$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptInfo$Type extends MessageType<ScriptInfo> {
  constructor() {
    super("soulfire.v1.ScriptInfo", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 6, name: "created_at", kind: "message", T: () => Timestamp },
      { no: 7, name: "updated_at", kind: "message", T: () => Timestamp },
      { no: 8, name: "paused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<ScriptInfo>): ScriptInfo {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.name = "";
    message.description = "";
    message.instanceId = "";
    message.paused = false;
    if (value !== undefined)
      reflectionMergePartial<ScriptInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptInfo,
  ): ScriptInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* string description */ 3:
          message.description = reader.string();
          break;
        case /* string instance_id */ 5:
          message.instanceId = reader.string();
          break;
        case /* google.protobuf.Timestamp created_at */ 6:
          message.createdAt = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.createdAt,
          );
          break;
        case /* google.protobuf.Timestamp updated_at */ 7:
          message.updatedAt = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.updatedAt,
          );
          break;
        case /* bool paused */ 8:
          message.paused = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string name = 2; */
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    /* string description = 3; */
    if (message.description !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    /* string instance_id = 5; */
    if (message.instanceId !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.instanceId);
    /* google.protobuf.Timestamp created_at = 6; */
    if (message.createdAt)
      Timestamp.internalBinaryWrite(
        message.createdAt,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* google.protobuf.Timestamp updated_at = 7; */
    if (message.updatedAt)
      Timestamp.internalBinaryWrite(
        message.updatedAt,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bool paused = 8; */
    if (message.paused !== false)
      writer.tag(8, WireType.Varint).bool(message.paused);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptInfo
 */
export const ScriptInfo = new ScriptInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptStatus$Type extends MessageType<ScriptStatus> {
  constructor() {
    super("soulfire.v1.ScriptStatus", [
      { no: 1, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 3,
        name: "active_node_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "activation_count",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
      },
    ]);
  }
  create(value?: PartialMessage<ScriptStatus>): ScriptStatus {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scriptId = "";
    message.isActive = false;
    message.activationCount = "0";
    if (value !== undefined)
      reflectionMergePartial<ScriptStatus>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptStatus,
  ): ScriptStatus {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string script_id */ 1:
          message.scriptId = reader.string();
          break;
        case /* bool is_active */ 2:
          message.isActive = reader.bool();
          break;
        case /* optional string active_node_id */ 3:
          message.activeNodeId = reader.string();
          break;
        case /* int64 activation_count */ 4:
          message.activationCount = reader.int64().toString();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptStatus,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string script_id = 1; */
    if (message.scriptId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.scriptId);
    /* bool is_active = 2; */
    if (message.isActive !== false)
      writer.tag(2, WireType.Varint).bool(message.isActive);
    /* optional string active_node_id = 3; */
    if (message.activeNodeId !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.activeNodeId);
    /* int64 activation_count = 4; */
    if (message.activationCount !== "0")
      writer.tag(4, WireType.Varint).int64(message.activationCount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptStatus
 */
export const ScriptStatus = new ScriptStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptLogEntry$Type extends MessageType<ScriptLogEntry> {
  constructor() {
    super("soulfire.v1.ScriptLogEntry", [
      { no: 1, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "level",
        kind: "enum",
        T: () => ["soulfire.v1.LogLevel", LogLevel, "LOG_LEVEL_"],
      },
      { no: 4, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: "timestamp", kind: "message", T: () => Timestamp },
    ]);
  }
  create(value?: PartialMessage<ScriptLogEntry>): ScriptLogEntry {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scriptId = "";
    message.nodeId = "";
    message.level = 0;
    message.message = "";
    if (value !== undefined)
      reflectionMergePartial<ScriptLogEntry>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptLogEntry,
  ): ScriptLogEntry {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string script_id */ 1:
          message.scriptId = reader.string();
          break;
        case /* string node_id */ 2:
          message.nodeId = reader.string();
          break;
        case /* soulfire.v1.LogLevel level */ 3:
          message.level = reader.int32();
          break;
        case /* string message */ 4:
          message.message = reader.string();
          break;
        case /* google.protobuf.Timestamp timestamp */ 5:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptLogEntry,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string script_id = 1; */
    if (message.scriptId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.scriptId);
    /* string node_id = 2; */
    if (message.nodeId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.nodeId);
    /* soulfire.v1.LogLevel level = 3; */
    if (message.level !== 0)
      writer.tag(3, WireType.Varint).int32(message.level);
    /* string message = 4; */
    if (message.message !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.message);
    /* google.protobuf.Timestamp timestamp = 5; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptLogEntry
 */
export const ScriptLogEntry = new ScriptLogEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeStarted$Type extends MessageType<NodeStarted> {
  constructor() {
    super("soulfire.v1.NodeStarted", [
      { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "timestamp", kind: "message", T: () => Timestamp },
    ]);
  }
  create(value?: PartialMessage<NodeStarted>): NodeStarted {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeId = "";
    if (value !== undefined)
      reflectionMergePartial<NodeStarted>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: NodeStarted,
  ): NodeStarted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string node_id */ 1:
          message.nodeId = reader.string();
          break;
        case /* google.protobuf.Timestamp timestamp */ 2:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: NodeStarted,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string node_id = 1; */
    if (message.nodeId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
    /* google.protobuf.Timestamp timestamp = 2; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.NodeStarted
 */
export const NodeStarted = new NodeStarted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeCompleted$Type extends MessageType<NodeCompleted> {
  constructor() {
    super("soulfire.v1.NodeCompleted", [
      { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "outputs",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => Value },
      },
      { no: 3, name: "timestamp", kind: "message", T: () => Timestamp },
      {
        no: 4,
        name: "execution_time_nanos",
        kind: "scalar",
        T: 3 /*ScalarType.INT64*/,
      },
    ]);
  }
  create(value?: PartialMessage<NodeCompleted>): NodeCompleted {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeId = "";
    message.outputs = {};
    message.executionTimeNanos = "0";
    if (value !== undefined)
      reflectionMergePartial<NodeCompleted>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: NodeCompleted,
  ): NodeCompleted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string node_id */ 1:
          message.nodeId = reader.string();
          break;
        case /* map<string, google.protobuf.Value> outputs */ 2:
          this.binaryReadMap2(message.outputs, reader, options);
          break;
        case /* google.protobuf.Timestamp timestamp */ 3:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        case /* int64 execution_time_nanos */ 4:
          message.executionTimeNanos = reader.int64().toString();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap2(
    map: NodeCompleted["outputs"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof NodeCompleted["outputs"] | undefined,
      val: NodeCompleted["outputs"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = Value.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for soulfire.v1.NodeCompleted.outputs",
          );
      }
    }
    map[key ?? ""] = val ?? Value.create();
  }
  internalBinaryWrite(
    message: NodeCompleted,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string node_id = 1; */
    if (message.nodeId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
    /* map<string, google.protobuf.Value> outputs = 2; */
    for (let k of globalThis.Object.keys(message.outputs)) {
      writer
        .tag(2, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      Value.internalBinaryWrite(message.outputs[k], writer, options);
      writer.join().join();
    }
    /* google.protobuf.Timestamp timestamp = 3; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* int64 execution_time_nanos = 4; */
    if (message.executionTimeNanos !== "0")
      writer.tag(4, WireType.Varint).int64(message.executionTimeNanos);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.NodeCompleted
 */
export const NodeCompleted = new NodeCompleted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecutionStats$Type extends MessageType<ExecutionStats> {
  constructor() {
    super("soulfire.v1.ExecutionStats", [
      { no: 1, name: "node_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
      { no: 2, name: "max_count", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
    ]);
  }
  create(value?: PartialMessage<ExecutionStats>): ExecutionStats {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeCount = "0";
    message.maxCount = "0";
    if (value !== undefined)
      reflectionMergePartial<ExecutionStats>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ExecutionStats,
  ): ExecutionStats {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* int64 node_count */ 1:
          message.nodeCount = reader.int64().toString();
          break;
        case /* int64 max_count */ 2:
          message.maxCount = reader.int64().toString();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ExecutionStats,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* int64 node_count = 1; */
    if (message.nodeCount !== "0")
      writer.tag(1, WireType.Varint).int64(message.nodeCount);
    /* int64 max_count = 2; */
    if (message.maxCount !== "0")
      writer.tag(2, WireType.Varint).int64(message.maxCount);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ExecutionStats
 */
export const ExecutionStats = new ExecutionStats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NodeError$Type extends MessageType<NodeError> {
  constructor() {
    super("soulfire.v1.NodeError", [
      { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "error_message",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "timestamp", kind: "message", T: () => Timestamp },
    ]);
  }
  create(value?: PartialMessage<NodeError>): NodeError {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeId = "";
    message.errorMessage = "";
    if (value !== undefined)
      reflectionMergePartial<NodeError>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: NodeError,
  ): NodeError {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string node_id */ 1:
          message.nodeId = reader.string();
          break;
        case /* string error_message */ 2:
          message.errorMessage = reader.string();
          break;
        case /* google.protobuf.Timestamp timestamp */ 3:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: NodeError,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string node_id = 1; */
    if (message.nodeId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
    /* string error_message = 2; */
    if (message.errorMessage !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
    /* google.protobuf.Timestamp timestamp = 3; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.NodeError
 */
export const NodeError = new NodeError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptLog$Type extends MessageType<ScriptLog> {
  constructor() {
    super("soulfire.v1.ScriptLog", [
      {
        no: 1,
        name: "node_id",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "level", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "timestamp", kind: "message", T: () => Timestamp },
    ]);
  }
  create(value?: PartialMessage<ScriptLog>): ScriptLog {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.level = "";
    message.message = "";
    if (value !== undefined)
      reflectionMergePartial<ScriptLog>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptLog,
  ): ScriptLog {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string node_id */ 1:
          message.nodeId = reader.string();
          break;
        case /* string level */ 2:
          message.level = reader.string();
          break;
        case /* string message */ 3:
          message.message = reader.string();
          break;
        case /* google.protobuf.Timestamp timestamp */ 4:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptLog,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string node_id = 1; */
    if (message.nodeId !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
    /* string level = 2; */
    if (message.level !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.level);
    /* string message = 3; */
    if (message.message !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.message);
    /* google.protobuf.Timestamp timestamp = 4; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptLog
 */
export const ScriptLog = new ScriptLog$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptStarted$Type extends MessageType<ScriptStarted> {
  constructor() {
    super("soulfire.v1.ScriptStarted", [
      { no: 1, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "timestamp", kind: "message", T: () => Timestamp },
    ]);
  }
  create(value?: PartialMessage<ScriptStarted>): ScriptStarted {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scriptId = "";
    if (value !== undefined)
      reflectionMergePartial<ScriptStarted>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptStarted,
  ): ScriptStarted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string script_id */ 1:
          message.scriptId = reader.string();
          break;
        case /* google.protobuf.Timestamp timestamp */ 2:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptStarted,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string script_id = 1; */
    if (message.scriptId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.scriptId);
    /* google.protobuf.Timestamp timestamp = 2; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptStarted
 */
export const ScriptStarted = new ScriptStarted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptCompleted$Type extends MessageType<ScriptCompleted> {
  constructor() {
    super("soulfire.v1.ScriptCompleted", [
      { no: 1, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: "timestamp", kind: "message", T: () => Timestamp },
    ]);
  }
  create(value?: PartialMessage<ScriptCompleted>): ScriptCompleted {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scriptId = "";
    message.success = false;
    if (value !== undefined)
      reflectionMergePartial<ScriptCompleted>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptCompleted,
  ): ScriptCompleted {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string script_id */ 1:
          message.scriptId = reader.string();
          break;
        case /* bool success */ 2:
          message.success = reader.bool();
          break;
        case /* google.protobuf.Timestamp timestamp */ 3:
          message.timestamp = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.timestamp,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptCompleted,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string script_id = 1; */
    if (message.scriptId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.scriptId);
    /* bool success = 2; */
    if (message.success !== false)
      writer.tag(2, WireType.Varint).bool(message.success);
    /* google.protobuf.Timestamp timestamp = 3; */
    if (message.timestamp)
      Timestamp.internalBinaryWrite(
        message.timestamp,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptCompleted
 */
export const ScriptCompleted = new ScriptCompleted$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidationDiagnostic$Type extends MessageType<ValidationDiagnostic> {
  constructor() {
    super("soulfire.v1.ValidationDiagnostic", [
      { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "edge_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "severity",
        kind: "enum",
        T: () => ["soulfire.v1.DiagnosticSeverity", DiagnosticSeverity],
      },
    ]);
  }
  create(value?: PartialMessage<ValidationDiagnostic>): ValidationDiagnostic {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeId = "";
    message.edgeId = "";
    message.message = "";
    message.severity = 0;
    if (value !== undefined)
      reflectionMergePartial<ValidationDiagnostic>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ValidationDiagnostic,
  ): ValidationDiagnostic {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string node_id */ 1:
          message.nodeId = reader.string();
          break;
        case /* string edge_id */ 2:
          message.edgeId = reader.string();
          break;
        case /* string message */ 3:
          message.message = reader.string();
          break;
        case /* soulfire.v1.DiagnosticSeverity severity */ 4:
          message.severity = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ValidationDiagnostic,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string node_id = 1; */
    if (message.nodeId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
    /* string edge_id = 2; */
    if (message.edgeId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.edgeId);
    /* string message = 3; */
    if (message.message !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.message);
    /* soulfire.v1.DiagnosticSeverity severity = 4; */
    if (message.severity !== 0)
      writer.tag(4, WireType.Varint).int32(message.severity);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ValidationDiagnostic
 */
export const ValidationDiagnostic = new ValidationDiagnostic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScriptEvent$Type extends MessageType<ScriptEvent> {
  constructor() {
    super("soulfire.v1.ScriptEvent", [
      {
        no: 1,
        name: "node_started",
        kind: "message",
        oneof: "event",
        T: () => NodeStarted,
      },
      {
        no: 2,
        name: "node_completed",
        kind: "message",
        oneof: "event",
        T: () => NodeCompleted,
      },
      {
        no: 3,
        name: "node_error",
        kind: "message",
        oneof: "event",
        T: () => NodeError,
      },
      {
        no: 4,
        name: "script_completed",
        kind: "message",
        oneof: "event",
        T: () => ScriptCompleted,
      },
      {
        no: 5,
        name: "script_started",
        kind: "message",
        oneof: "event",
        T: () => ScriptStarted,
      },
      {
        no: 6,
        name: "script_log",
        kind: "message",
        oneof: "event",
        T: () => ScriptLog,
      },
      {
        no: 7,
        name: "execution_stats",
        kind: "message",
        oneof: "event",
        T: () => ExecutionStats,
      },
    ]);
  }
  create(value?: PartialMessage<ScriptEvent>): ScriptEvent {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.event = { oneofKind: undefined };
    if (value !== undefined)
      reflectionMergePartial<ScriptEvent>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ScriptEvent,
  ): ScriptEvent {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.NodeStarted node_started */ 1:
          message.event = {
            oneofKind: "nodeStarted",
            nodeStarted: NodeStarted.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.event as any).nodeStarted,
            ),
          };
          break;
        case /* soulfire.v1.NodeCompleted node_completed */ 2:
          message.event = {
            oneofKind: "nodeCompleted",
            nodeCompleted: NodeCompleted.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.event as any).nodeCompleted,
            ),
          };
          break;
        case /* soulfire.v1.NodeError node_error */ 3:
          message.event = {
            oneofKind: "nodeError",
            nodeError: NodeError.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.event as any).nodeError,
            ),
          };
          break;
        case /* soulfire.v1.ScriptCompleted script_completed */ 4:
          message.event = {
            oneofKind: "scriptCompleted",
            scriptCompleted: ScriptCompleted.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.event as any).scriptCompleted,
            ),
          };
          break;
        case /* soulfire.v1.ScriptStarted script_started */ 5:
          message.event = {
            oneofKind: "scriptStarted",
            scriptStarted: ScriptStarted.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.event as any).scriptStarted,
            ),
          };
          break;
        case /* soulfire.v1.ScriptLog script_log */ 6:
          message.event = {
            oneofKind: "scriptLog",
            scriptLog: ScriptLog.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.event as any).scriptLog,
            ),
          };
          break;
        case /* soulfire.v1.ExecutionStats execution_stats */ 7:
          message.event = {
            oneofKind: "executionStats",
            executionStats: ExecutionStats.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.event as any).executionStats,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ScriptEvent,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.NodeStarted node_started = 1; */
    if (message.event.oneofKind === "nodeStarted")
      NodeStarted.internalBinaryWrite(
        message.event.nodeStarted,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.NodeCompleted node_completed = 2; */
    if (message.event.oneofKind === "nodeCompleted")
      NodeCompleted.internalBinaryWrite(
        message.event.nodeCompleted,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.NodeError node_error = 3; */
    if (message.event.oneofKind === "nodeError")
      NodeError.internalBinaryWrite(
        message.event.nodeError,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.ScriptCompleted script_completed = 4; */
    if (message.event.oneofKind === "scriptCompleted")
      ScriptCompleted.internalBinaryWrite(
        message.event.scriptCompleted,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.ScriptStarted script_started = 5; */
    if (message.event.oneofKind === "scriptStarted")
      ScriptStarted.internalBinaryWrite(
        message.event.scriptStarted,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.ScriptLog script_log = 6; */
    if (message.event.oneofKind === "scriptLog")
      ScriptLog.internalBinaryWrite(
        message.event.scriptLog,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* soulfire.v1.ExecutionStats execution_stats = 7; */
    if (message.event.oneofKind === "executionStats")
      ExecutionStats.internalBinaryWrite(
        message.event.executionStats,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ScriptEvent
 */
export const ScriptEvent = new ScriptEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateScriptRequest$Type extends MessageType<CreateScriptRequest> {
  constructor() {
    super("soulfire.v1.CreateScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "nodes",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptNode,
      },
      {
        no: 6,
        name: "edges",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptEdge,
      },
      { no: 7, name: "paused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<CreateScriptRequest>): CreateScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.name = "";
    message.description = "";
    message.nodes = [];
    message.edges = [];
    message.paused = false;
    if (value !== undefined)
      reflectionMergePartial<CreateScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateScriptRequest,
  ): CreateScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* string description */ 3:
          message.description = reader.string();
          break;
        case /* repeated soulfire.v1.ScriptNode nodes */ 5:
          message.nodes.push(
            ScriptNode.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.ScriptEdge edges */ 6:
          message.edges.push(
            ScriptEdge.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* bool paused */ 7:
          message.paused = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CreateScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string name = 2; */
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    /* string description = 3; */
    if (message.description !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.description);
    /* repeated soulfire.v1.ScriptNode nodes = 5; */
    for (let i = 0; i < message.nodes.length; i++)
      ScriptNode.internalBinaryWrite(
        message.nodes[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.ScriptEdge edges = 6; */
    for (let i = 0; i < message.edges.length; i++)
      ScriptEdge.internalBinaryWrite(
        message.edges[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bool paused = 7; */
    if (message.paused !== false)
      writer.tag(7, WireType.Varint).bool(message.paused);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CreateScriptRequest
 */
export const CreateScriptRequest = new CreateScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateScriptResponse$Type extends MessageType<CreateScriptResponse> {
  constructor() {
    super("soulfire.v1.CreateScriptResponse", [
      { no: 1, name: "script", kind: "message", T: () => ScriptData },
      {
        no: 2,
        name: "diagnostics",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ValidationDiagnostic,
      },
    ]);
  }
  create(value?: PartialMessage<CreateScriptResponse>): CreateScriptResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.diagnostics = [];
    if (value !== undefined)
      reflectionMergePartial<CreateScriptResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CreateScriptResponse,
  ): CreateScriptResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.ScriptData script */ 1:
          message.script = ScriptData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.script,
          );
          break;
        case /* repeated soulfire.v1.ValidationDiagnostic diagnostics */ 2:
          message.diagnostics.push(
            ValidationDiagnostic.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CreateScriptResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.ScriptData script = 1; */
    if (message.script)
      ScriptData.internalBinaryWrite(
        message.script,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.ValidationDiagnostic diagnostics = 2; */
    for (let i = 0; i < message.diagnostics.length; i++)
      ValidationDiagnostic.internalBinaryWrite(
        message.diagnostics[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CreateScriptResponse
 */
export const CreateScriptResponse = new CreateScriptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScriptRequest$Type extends MessageType<GetScriptRequest> {
  constructor() {
    super("soulfire.v1.GetScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<GetScriptRequest>): GetScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    if (value !== undefined)
      reflectionMergePartial<GetScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetScriptRequest,
  ): GetScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetScriptRequest
 */
export const GetScriptRequest = new GetScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScriptResponse$Type extends MessageType<GetScriptResponse> {
  constructor() {
    super("soulfire.v1.GetScriptResponse", [
      { no: 1, name: "script", kind: "message", T: () => ScriptData },
    ]);
  }
  create(value?: PartialMessage<GetScriptResponse>): GetScriptResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<GetScriptResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetScriptResponse,
  ): GetScriptResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.ScriptData script */ 1:
          message.script = ScriptData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.script,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetScriptResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.ScriptData script = 1; */
    if (message.script)
      ScriptData.internalBinaryWrite(
        message.script,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetScriptResponse
 */
export const GetScriptResponse = new GetScriptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateScriptRequest$Type extends MessageType<UpdateScriptRequest> {
  constructor() {
    super("soulfire.v1.UpdateScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "name",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "description",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 6,
        name: "nodes",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptNode,
      },
      {
        no: 7,
        name: "edges",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptEdge,
      },
      { no: 8, name: "update_nodes", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 9, name: "update_edges", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      {
        no: 10,
        name: "paused",
        kind: "scalar",
        opt: true,
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<UpdateScriptRequest>): UpdateScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    message.nodes = [];
    message.edges = [];
    message.updateNodes = false;
    message.updateEdges = false;
    if (value !== undefined)
      reflectionMergePartial<UpdateScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UpdateScriptRequest,
  ): UpdateScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        case /* optional string name */ 3:
          message.name = reader.string();
          break;
        case /* optional string description */ 4:
          message.description = reader.string();
          break;
        case /* repeated soulfire.v1.ScriptNode nodes */ 6:
          message.nodes.push(
            ScriptNode.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.ScriptEdge edges */ 7:
          message.edges.push(
            ScriptEdge.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* bool update_nodes */ 8:
          message.updateNodes = reader.bool();
          break;
        case /* bool update_edges */ 9:
          message.updateEdges = reader.bool();
          break;
        case /* optional bool paused */ 10:
          message.paused = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UpdateScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    /* optional string name = 3; */
    if (message.name !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.name);
    /* optional string description = 4; */
    if (message.description !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.description);
    /* repeated soulfire.v1.ScriptNode nodes = 6; */
    for (let i = 0; i < message.nodes.length; i++)
      ScriptNode.internalBinaryWrite(
        message.nodes[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.ScriptEdge edges = 7; */
    for (let i = 0; i < message.edges.length; i++)
      ScriptEdge.internalBinaryWrite(
        message.edges[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* bool update_nodes = 8; */
    if (message.updateNodes !== false)
      writer.tag(8, WireType.Varint).bool(message.updateNodes);
    /* bool update_edges = 9; */
    if (message.updateEdges !== false)
      writer.tag(9, WireType.Varint).bool(message.updateEdges);
    /* optional bool paused = 10; */
    if (message.paused !== undefined)
      writer.tag(10, WireType.Varint).bool(message.paused);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.UpdateScriptRequest
 */
export const UpdateScriptRequest = new UpdateScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateScriptResponse$Type extends MessageType<UpdateScriptResponse> {
  constructor() {
    super("soulfire.v1.UpdateScriptResponse", [
      { no: 1, name: "script", kind: "message", T: () => ScriptData },
      {
        no: 2,
        name: "diagnostics",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ValidationDiagnostic,
      },
    ]);
  }
  create(value?: PartialMessage<UpdateScriptResponse>): UpdateScriptResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.diagnostics = [];
    if (value !== undefined)
      reflectionMergePartial<UpdateScriptResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UpdateScriptResponse,
  ): UpdateScriptResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.ScriptData script */ 1:
          message.script = ScriptData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.script,
          );
          break;
        case /* repeated soulfire.v1.ValidationDiagnostic diagnostics */ 2:
          message.diagnostics.push(
            ValidationDiagnostic.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UpdateScriptResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.ScriptData script = 1; */
    if (message.script)
      ScriptData.internalBinaryWrite(
        message.script,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.ValidationDiagnostic diagnostics = 2; */
    for (let i = 0; i < message.diagnostics.length; i++)
      ValidationDiagnostic.internalBinaryWrite(
        message.diagnostics[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.UpdateScriptResponse
 */
export const UpdateScriptResponse = new UpdateScriptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteScriptRequest$Type extends MessageType<DeleteScriptRequest> {
  constructor() {
    super("soulfire.v1.DeleteScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<DeleteScriptRequest>): DeleteScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    if (value !== undefined)
      reflectionMergePartial<DeleteScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteScriptRequest,
  ): DeleteScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeleteScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DeleteScriptRequest
 */
export const DeleteScriptRequest = new DeleteScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteScriptResponse$Type extends MessageType<DeleteScriptResponse> {
  constructor() {
    super("soulfire.v1.DeleteScriptResponse", []);
  }
  create(value?: PartialMessage<DeleteScriptResponse>): DeleteScriptResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<DeleteScriptResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeleteScriptResponse,
  ): DeleteScriptResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeleteScriptResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DeleteScriptResponse
 */
export const DeleteScriptResponse = new DeleteScriptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListScriptsRequest$Type extends MessageType<ListScriptsRequest> {
  constructor() {
    super("soulfire.v1.ListScriptsRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<ListScriptsRequest>): ListScriptsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    if (value !== undefined)
      reflectionMergePartial<ListScriptsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListScriptsRequest,
  ): ListScriptsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListScriptsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ListScriptsRequest
 */
export const ListScriptsRequest = new ListScriptsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListScriptsResponse$Type extends MessageType<ListScriptsResponse> {
  constructor() {
    super("soulfire.v1.ListScriptsResponse", [
      {
        no: 1,
        name: "scripts",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptInfo,
      },
    ]);
  }
  create(value?: PartialMessage<ListScriptsResponse>): ListScriptsResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.scripts = [];
    if (value !== undefined)
      reflectionMergePartial<ListScriptsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListScriptsResponse,
  ): ListScriptsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.ScriptInfo scripts */ 1:
          message.scripts.push(
            ScriptInfo.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ListScriptsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.ScriptInfo scripts = 1; */
    for (let i = 0; i < message.scripts.length; i++)
      ScriptInfo.internalBinaryWrite(
        message.scripts[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ListScriptsResponse
 */
export const ListScriptsResponse = new ListScriptsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivateScriptRequest$Type extends MessageType<ActivateScriptRequest> {
  constructor() {
    super("soulfire.v1.ActivateScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ActivateScriptRequest>): ActivateScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    if (value !== undefined)
      reflectionMergePartial<ActivateScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ActivateScriptRequest,
  ): ActivateScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ActivateScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ActivateScriptRequest
 */
export const ActivateScriptRequest = new ActivateScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeactivateScriptRequest$Type extends MessageType<DeactivateScriptRequest> {
  constructor() {
    super("soulfire.v1.DeactivateScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<DeactivateScriptRequest>,
  ): DeactivateScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    if (value !== undefined)
      reflectionMergePartial<DeactivateScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeactivateScriptRequest,
  ): DeactivateScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeactivateScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DeactivateScriptRequest
 */
export const DeactivateScriptRequest = new DeactivateScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeactivateScriptResponse$Type extends MessageType<DeactivateScriptResponse> {
  constructor() {
    super("soulfire.v1.DeactivateScriptResponse", []);
  }
  create(
    value?: PartialMessage<DeactivateScriptResponse>,
  ): DeactivateScriptResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<DeactivateScriptResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeactivateScriptResponse,
  ): DeactivateScriptResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: DeactivateScriptResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DeactivateScriptResponse
 */
export const DeactivateScriptResponse = new DeactivateScriptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScriptStatusRequest$Type extends MessageType<GetScriptStatusRequest> {
  constructor() {
    super("soulfire.v1.GetScriptStatusRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(
    value?: PartialMessage<GetScriptStatusRequest>,
  ): GetScriptStatusRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    if (value !== undefined)
      reflectionMergePartial<GetScriptStatusRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetScriptStatusRequest,
  ): GetScriptStatusRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetScriptStatusRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetScriptStatusRequest
 */
export const GetScriptStatusRequest = new GetScriptStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetScriptStatusResponse$Type extends MessageType<GetScriptStatusResponse> {
  constructor() {
    super("soulfire.v1.GetScriptStatusResponse", [
      { no: 1, name: "status", kind: "message", T: () => ScriptStatus },
    ]);
  }
  create(
    value?: PartialMessage<GetScriptStatusResponse>,
  ): GetScriptStatusResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<GetScriptStatusResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetScriptStatusResponse,
  ): GetScriptStatusResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.ScriptStatus status */ 1:
          message.status = ScriptStatus.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.status,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetScriptStatusResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.ScriptStatus status = 1; */
    if (message.status)
      ScriptStatus.internalBinaryWrite(
        message.status,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetScriptStatusResponse
 */
export const GetScriptStatusResponse = new GetScriptStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeScriptLogsRequest$Type extends MessageType<SubscribeScriptLogsRequest> {
  constructor() {
    super("soulfire.v1.SubscribeScriptLogsRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "min_level",
        kind: "enum",
        T: () => ["soulfire.v1.LogLevel", LogLevel, "LOG_LEVEL_"],
      },
    ]);
  }
  create(
    value?: PartialMessage<SubscribeScriptLogsRequest>,
  ): SubscribeScriptLogsRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    message.minLevel = 0;
    if (value !== undefined)
      reflectionMergePartial<SubscribeScriptLogsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SubscribeScriptLogsRequest,
  ): SubscribeScriptLogsRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        case /* soulfire.v1.LogLevel min_level */ 3:
          message.minLevel = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SubscribeScriptLogsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    /* soulfire.v1.LogLevel min_level = 3; */
    if (message.minLevel !== 0)
      writer.tag(3, WireType.Varint).int32(message.minLevel);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.SubscribeScriptLogsRequest
 */
export const SubscribeScriptLogsRequest = new SubscribeScriptLogsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNodeTypesRequest$Type extends MessageType<GetNodeTypesRequest> {
  constructor() {
    super("soulfire.v1.GetNodeTypesRequest", [
      {
        no: 1,
        name: "category",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "include_deprecated",
        kind: "scalar",
        T: 8 /*ScalarType.BOOL*/,
      },
    ]);
  }
  create(value?: PartialMessage<GetNodeTypesRequest>): GetNodeTypesRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.includeDeprecated = false;
    if (value !== undefined)
      reflectionMergePartial<GetNodeTypesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetNodeTypesRequest,
  ): GetNodeTypesRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string category */ 1:
          message.category = reader.string();
          break;
        case /* bool include_deprecated */ 2:
          message.includeDeprecated = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetNodeTypesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string category = 1; */
    if (message.category !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.category);
    /* bool include_deprecated = 2; */
    if (message.includeDeprecated !== false)
      writer.tag(2, WireType.Varint).bool(message.includeDeprecated);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetNodeTypesRequest
 */
export const GetNodeTypesRequest = new GetNodeTypesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CategoryDefinition$Type extends MessageType<CategoryDefinition> {
  constructor() {
    super("soulfire.v1.CategoryDefinition", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: "description",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 5, name: "sort_order", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
    ]);
  }
  create(value?: PartialMessage<CategoryDefinition>): CategoryDefinition {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.displayName = "";
    message.icon = "";
    message.description = "";
    message.sortOrder = 0;
    if (value !== undefined)
      reflectionMergePartial<CategoryDefinition>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CategoryDefinition,
  ): CategoryDefinition {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string display_name */ 2:
          message.displayName = reader.string();
          break;
        case /* string icon */ 3:
          message.icon = reader.string();
          break;
        case /* string description */ 4:
          message.description = reader.string();
          break;
        case /* int32 sort_order */ 5:
          message.sortOrder = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CategoryDefinition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string display_name = 2; */
    if (message.displayName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.displayName);
    /* string icon = 3; */
    if (message.icon !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.icon);
    /* string description = 4; */
    if (message.description !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.description);
    /* int32 sort_order = 5; */
    if (message.sortOrder !== 0)
      writer.tag(5, WireType.Varint).int32(message.sortOrder);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.CategoryDefinition
 */
export const CategoryDefinition = new CategoryDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNodeTypesResponse$Type extends MessageType<GetNodeTypesResponse> {
  constructor() {
    super("soulfire.v1.GetNodeTypesResponse", [
      {
        no: 1,
        name: "node_types",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => NodeTypeDefinition,
      },
      {
        no: 2,
        name: "categories",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => CategoryDefinition,
      },
      {
        no: 3,
        name: "port_type_metadata",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => PortTypeMetadata,
      },
    ]);
  }
  create(value?: PartialMessage<GetNodeTypesResponse>): GetNodeTypesResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.nodeTypes = [];
    message.categories = [];
    message.portTypeMetadata = [];
    if (value !== undefined)
      reflectionMergePartial<GetNodeTypesResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetNodeTypesResponse,
  ): GetNodeTypesResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.NodeTypeDefinition node_types */ 1:
          message.nodeTypes.push(
            NodeTypeDefinition.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated soulfire.v1.CategoryDefinition categories */ 2:
          message.categories.push(
            CategoryDefinition.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        case /* repeated soulfire.v1.PortTypeMetadata port_type_metadata */ 3:
          message.portTypeMetadata.push(
            PortTypeMetadata.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetNodeTypesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.NodeTypeDefinition node_types = 1; */
    for (let i = 0; i < message.nodeTypes.length; i++)
      NodeTypeDefinition.internalBinaryWrite(
        message.nodeTypes[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.CategoryDefinition categories = 2; */
    for (let i = 0; i < message.categories.length; i++)
      CategoryDefinition.internalBinaryWrite(
        message.categories[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.PortTypeMetadata port_type_metadata = 3; */
    for (let i = 0; i < message.portTypeMetadata.length; i++)
      PortTypeMetadata.internalBinaryWrite(
        message.portTypeMetadata[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetNodeTypesResponse
 */
export const GetNodeTypesResponse = new GetNodeTypesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortTypeMetadata$Type extends MessageType<PortTypeMetadata> {
  constructor() {
    super("soulfire.v1.PortTypeMetadata", [
      {
        no: 1,
        name: "port_type",
        kind: "enum",
        T: () => ["soulfire.v1.PortType", PortType, "PORT_TYPE_"],
      },
      { no: 2, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "display_name",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "compatible_from",
        kind: "enum",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ["soulfire.v1.PortType", PortType, "PORT_TYPE_"],
      },
      {
        no: 5,
        name: "handle_shape",
        kind: "enum",
        T: () => ["soulfire.v1.HandleShape", HandleShape, "HANDLE_SHAPE_"],
      },
      {
        no: 6,
        name: "edge_style",
        kind: "enum",
        T: () => ["soulfire.v1.EdgeStyle", EdgeStyle, "EDGE_STYLE_"],
      },
    ]);
  }
  create(value?: PartialMessage<PortTypeMetadata>): PortTypeMetadata {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.portType = 0;
    message.color = "";
    message.displayName = "";
    message.compatibleFrom = [];
    message.handleShape = 0;
    message.edgeStyle = 0;
    if (value !== undefined)
      reflectionMergePartial<PortTypeMetadata>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PortTypeMetadata,
  ): PortTypeMetadata {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* soulfire.v1.PortType port_type */ 1:
          message.portType = reader.int32();
          break;
        case /* string color */ 2:
          message.color = reader.string();
          break;
        case /* string display_name */ 3:
          message.displayName = reader.string();
          break;
        case /* repeated soulfire.v1.PortType compatible_from */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.compatibleFrom.push(reader.int32());
          else message.compatibleFrom.push(reader.int32());
          break;
        case /* soulfire.v1.HandleShape handle_shape */ 5:
          message.handleShape = reader.int32();
          break;
        case /* soulfire.v1.EdgeStyle edge_style */ 6:
          message.edgeStyle = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: PortTypeMetadata,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* soulfire.v1.PortType port_type = 1; */
    if (message.portType !== 0)
      writer.tag(1, WireType.Varint).int32(message.portType);
    /* string color = 2; */
    if (message.color !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.color);
    /* string display_name = 3; */
    if (message.displayName !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.displayName);
    /* repeated soulfire.v1.PortType compatible_from = 4; */
    if (message.compatibleFrom.length) {
      writer.tag(4, WireType.LengthDelimited).fork();
      for (let i = 0; i < message.compatibleFrom.length; i++)
        writer.int32(message.compatibleFrom[i]);
      writer.join();
    }
    /* soulfire.v1.HandleShape handle_shape = 5; */
    if (message.handleShape !== 0)
      writer.tag(5, WireType.Varint).int32(message.handleShape);
    /* soulfire.v1.EdgeStyle edge_style = 6; */
    if (message.edgeStyle !== 0)
      writer.tag(6, WireType.Varint).int32(message.edgeStyle);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.PortTypeMetadata
 */
export const PortTypeMetadata = new PortTypeMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRegistryDataRequest$Type extends MessageType<GetRegistryDataRequest> {
  constructor() {
    super("soulfire.v1.GetRegistryDataRequest", [
      {
        no: 1,
        name: "registry",
        kind: "scalar",
        opt: true,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<GetRegistryDataRequest>,
  ): GetRegistryDataRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    if (value !== undefined)
      reflectionMergePartial<GetRegistryDataRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRegistryDataRequest,
  ): GetRegistryDataRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* optional string registry */ 1:
          message.registry = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetRegistryDataRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* optional string registry = 1; */
    if (message.registry !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.registry);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetRegistryDataRequest
 */
export const GetRegistryDataRequest = new GetRegistryDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegistryEntry$Type extends MessageType<RegistryEntry> {
  constructor() {
    super("soulfire.v1.RegistryEntry", [
      { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: "display_name",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 3, name: "icon", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "category", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<RegistryEntry>): RegistryEntry {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.id = "";
    message.displayName = "";
    message.icon = "";
    message.category = "";
    if (value !== undefined)
      reflectionMergePartial<RegistryEntry>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RegistryEntry,
  ): RegistryEntry {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string display_name */ 2:
          message.displayName = reader.string();
          break;
        case /* string icon */ 3:
          message.icon = reader.string();
          break;
        case /* string category */ 4:
          message.category = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RegistryEntry,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string display_name = 2; */
    if (message.displayName !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.displayName);
    /* string icon = 3; */
    if (message.icon !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.icon);
    /* string category = 4; */
    if (message.category !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.category);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.RegistryEntry
 */
export const RegistryEntry = new RegistryEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateScriptRequest$Type extends MessageType<ValidateScriptRequest> {
  constructor() {
    super("soulfire.v1.ValidateScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "nodes",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptNode,
      },
      {
        no: 3,
        name: "edges",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ScriptEdge,
      },
    ]);
  }
  create(value?: PartialMessage<ValidateScriptRequest>): ValidateScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.nodes = [];
    message.edges = [];
    if (value !== undefined)
      reflectionMergePartial<ValidateScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ValidateScriptRequest,
  ): ValidateScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* repeated soulfire.v1.ScriptNode nodes */ 2:
          message.nodes.push(
            ScriptNode.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.ScriptEdge edges */ 3:
          message.edges.push(
            ScriptEdge.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ValidateScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* repeated soulfire.v1.ScriptNode nodes = 2; */
    for (let i = 0; i < message.nodes.length; i++)
      ScriptNode.internalBinaryWrite(
        message.nodes[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.ScriptEdge edges = 3; */
    for (let i = 0; i < message.edges.length; i++)
      ScriptEdge.internalBinaryWrite(
        message.edges[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ValidateScriptRequest
 */
export const ValidateScriptRequest = new ValidateScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateScriptResponse$Type extends MessageType<ValidateScriptResponse> {
  constructor() {
    super("soulfire.v1.ValidateScriptResponse", [
      {
        no: 1,
        name: "diagnostics",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => ValidationDiagnostic,
      },
    ]);
  }
  create(
    value?: PartialMessage<ValidateScriptResponse>,
  ): ValidateScriptResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.diagnostics = [];
    if (value !== undefined)
      reflectionMergePartial<ValidateScriptResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ValidateScriptResponse,
  ): ValidateScriptResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.ValidationDiagnostic diagnostics */ 1:
          message.diagnostics.push(
            ValidationDiagnostic.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
            ),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ValidateScriptResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.ValidationDiagnostic diagnostics = 1; */
    for (let i = 0; i < message.diagnostics.length; i++)
      ValidationDiagnostic.internalBinaryWrite(
        message.diagnostics[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.ValidateScriptResponse
 */
export const ValidateScriptResponse = new ValidateScriptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DryRunScriptRequest$Type extends MessageType<DryRunScriptRequest> {
  constructor() {
    super("soulfire.v1.DryRunScriptRequest", [
      {
        no: 1,
        name: "instance_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      { no: 2, name: "script_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: "trigger_node_id",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 4,
        name: "mock_inputs",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => Value },
      },
    ]);
  }
  create(value?: PartialMessage<DryRunScriptRequest>): DryRunScriptRequest {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.instanceId = "";
    message.scriptId = "";
    message.triggerNodeId = "";
    message.mockInputs = {};
    if (value !== undefined)
      reflectionMergePartial<DryRunScriptRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DryRunScriptRequest,
  ): DryRunScriptRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string instance_id */ 1:
          message.instanceId = reader.string();
          break;
        case /* string script_id */ 2:
          message.scriptId = reader.string();
          break;
        case /* string trigger_node_id */ 3:
          message.triggerNodeId = reader.string();
          break;
        case /* map<string, google.protobuf.Value> mock_inputs */ 4:
          this.binaryReadMap4(message.mockInputs, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap4(
    map: DryRunScriptRequest["mockInputs"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof DryRunScriptRequest["mockInputs"] | undefined,
      val: DryRunScriptRequest["mockInputs"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = Value.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for soulfire.v1.DryRunScriptRequest.mock_inputs",
          );
      }
    }
    map[key ?? ""] = val ?? Value.create();
  }
  internalBinaryWrite(
    message: DryRunScriptRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string instance_id = 1; */
    if (message.instanceId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.instanceId);
    /* string script_id = 2; */
    if (message.scriptId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.scriptId);
    /* string trigger_node_id = 3; */
    if (message.triggerNodeId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.triggerNodeId);
    /* map<string, google.protobuf.Value> mock_inputs = 4; */
    for (let k of globalThis.Object.keys(message.mockInputs)) {
      writer
        .tag(4, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      Value.internalBinaryWrite(message.mockInputs[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.DryRunScriptRequest
 */
export const DryRunScriptRequest = new DryRunScriptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRegistryDataResponse$Type extends MessageType<GetRegistryDataResponse> {
  constructor() {
    super("soulfire.v1.GetRegistryDataResponse", [
      {
        no: 1,
        name: "blocks",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => RegistryEntry,
      },
      {
        no: 2,
        name: "entities",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => RegistryEntry,
      },
      {
        no: 3,
        name: "items",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => RegistryEntry,
      },
      {
        no: 4,
        name: "biomes",
        kind: "message",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: () => RegistryEntry,
      },
    ]);
  }
  create(
    value?: PartialMessage<GetRegistryDataResponse>,
  ): GetRegistryDataResponse {
    const message = globalThis.Object.create(this.messagePrototype!);
    message.blocks = [];
    message.entities = [];
    message.items = [];
    message.biomes = [];
    if (value !== undefined)
      reflectionMergePartial<GetRegistryDataResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetRegistryDataResponse,
  ): GetRegistryDataResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated soulfire.v1.RegistryEntry blocks */ 1:
          message.blocks.push(
            RegistryEntry.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.RegistryEntry entities */ 2:
          message.entities.push(
            RegistryEntry.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.RegistryEntry items */ 3:
          message.items.push(
            RegistryEntry.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        case /* repeated soulfire.v1.RegistryEntry biomes */ 4:
          message.biomes.push(
            RegistryEntry.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetRegistryDataResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated soulfire.v1.RegistryEntry blocks = 1; */
    for (let i = 0; i < message.blocks.length; i++)
      RegistryEntry.internalBinaryWrite(
        message.blocks[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.RegistryEntry entities = 2; */
    for (let i = 0; i < message.entities.length; i++)
      RegistryEntry.internalBinaryWrite(
        message.entities[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.RegistryEntry items = 3; */
    for (let i = 0; i < message.items.length; i++)
      RegistryEntry.internalBinaryWrite(
        message.items[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* repeated soulfire.v1.RegistryEntry biomes = 4; */
    for (let i = 0; i < message.biomes.length; i++)
      RegistryEntry.internalBinaryWrite(
        message.biomes[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message soulfire.v1.GetRegistryDataResponse
 */
export const GetRegistryDataResponse = new GetRegistryDataResponse$Type();
/**
 * @generated ServiceType for protobuf service soulfire.v1.ScriptService
 */
export const ScriptService = new ServiceType("soulfire.v1.ScriptService", [
  {
    name: "CreateScript",
    options: {},
    I: CreateScriptRequest,
    O: CreateScriptResponse,
  },
  { name: "GetScript", options: {}, I: GetScriptRequest, O: GetScriptResponse },
  {
    name: "UpdateScript",
    options: {},
    I: UpdateScriptRequest,
    O: UpdateScriptResponse,
  },
  {
    name: "DeleteScript",
    options: {},
    I: DeleteScriptRequest,
    O: DeleteScriptResponse,
  },
  {
    name: "ListScripts",
    options: {},
    I: ListScriptsRequest,
    O: ListScriptsResponse,
  },
  {
    name: "ActivateScript",
    serverStreaming: true,
    options: {},
    I: ActivateScriptRequest,
    O: ScriptEvent,
  },
  {
    name: "DeactivateScript",
    options: {},
    I: DeactivateScriptRequest,
    O: DeactivateScriptResponse,
  },
  {
    name: "GetScriptStatus",
    options: {},
    I: GetScriptStatusRequest,
    O: GetScriptStatusResponse,
  },
  {
    name: "SubscribeScriptLogs",
    serverStreaming: true,
    options: {},
    I: SubscribeScriptLogsRequest,
    O: ScriptLogEntry,
  },
  {
    name: "GetNodeTypes",
    options: {},
    I: GetNodeTypesRequest,
    O: GetNodeTypesResponse,
  },
  {
    name: "GetRegistryData",
    options: {},
    I: GetRegistryDataRequest,
    O: GetRegistryDataResponse,
  },
  {
    name: "ValidateScript",
    options: {},
    I: ValidateScriptRequest,
    O: ValidateScriptResponse,
  },
  {
    name: "DryRunScript",
    serverStreaming: true,
    options: {},
    I: DryRunScriptRequest,
    O: ScriptEvent,
  },
]);
